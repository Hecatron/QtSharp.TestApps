<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QtQuickSharp</name>
    </assembly>
    <members>
        <member name="T:QtQuick.QQuickItem">
            <summary>
            <para>The QQuickItem class provides the most basic of all visual items in Qt Quick.</para>
            </summary>
            <remarks>
            <para>All visual items in Qt Quick inherit from QQuickItem. Although a QQuickItem instance has no visual appearance, it defines all the attributes that are common across visual items, such as x and y position, width and height, anchoring and key handling support.</para>
            <para>You can subclass QQuickItem to provide your own custom visual item that inherits these features.</para>
            <para></para>
            <para>Custom Scene Graph Items</para>
            <para>All visual QML items are rendered using the scene graph, a low-level, high-performance rendering stack, closely tied to OpenGL. It is possible for subclasses of QQuickItem to add their own custom content into the scene graph by setting the QQuickItem::ItemHasContents flag and reimplementing the QQuickItem::updatePaintNode() function.</para>
            <para>Warning: It is crucial that OpenGL operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the updatePaintNode() call. The best rule of thumb is to only use classes with the &quot;QSG&quot; prefix inside the QQuickItem::updatePaintNode() function.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            <para></para>
            <para>Graphics Resource Handling</para>
            <para>The preferred way to handle cleanup of graphics resources used in the scene graph, is to rely on the automatic cleanup of nodes. A QSGNode returned from QQuickItem::updatePaintNode() is automatically deleted on the right thread at the right time. Trees of QSGNode instances are managed through the use of QSGNode::OwnedByParent, which is set by default. So, for the majority of custom scene graph items, no extra work will be required.</para>
            <para>Implementations that store graphics resources outside the node tree, such as an item implementing QQuickItem::textureProvider(), will need to take care in cleaning it up correctly depending on how the item is used in QML. The situations to handle are:</para>
            <para></para>
            <para>The scene graph is invalidated; This can happen, for instance, if the window is hidden using QQuickWindow::hide(). If the item class implements a slot named invalidateSceneGraph(), this slot will be called on the rendering thread while the GUI thread is blocked. This is equivalent to connecting to QQuickWindow::sceneGraphInvalidated(). The OpenGL context of this item's window will be bound when this slot is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</para>
            <para>The item is removed from the scene; If an item is taken out of the scene, for instance because it's parent was set to null or an item in another window, the QQuickItem::releaseResources() will be called on the GUI thread. QQuickWindow::scheduleRenderJob() should be used to schedule cleanup of rendering resources.</para>
            <para>The item is deleted; When the destructor if an item runs, it should delete any graphics resources it has. If neither of the two conditions above were already met, the item will be part of a window and it is possible to use QQuickWindow::scheduleRenderJob() to have them cleaned up. If an implementation ignores the call to QQuickItem::releaseResources(), the item will in many cases no longer have access to a QQuickWindow and thus no means of scheduling cleanup.</para>
            <para></para>
            <para>When scheduling cleanup of graphics resources using QQuickWindow::scheduleRenderJob(), one should use either QQuickWindow::BeforeSynchronizingStage or QQuickWindow::AfterSynchronizingStage. The synchronization stage is where the scene graph is changed as a result of changes to the QML tree. If cleanup is scheduled at any other time, it may result in other parts of the scene graph referencing the newly deleted objects as these parts have not been updated.</para>
            <para>Note: Use of QObject::deleteLater() to clean up graphics resources is not recommended as this will run at an arbitrary time and it is unknown if there will be an OpenGL context bound when the deletion takes place.</para>
            <para></para>
            <para>Custom QPainter Items</para>
            <para>The QQuickItem provides a subclass, QQuickPaintedItem, which allows the users to render content using QPainter.</para>
            <para>Warning: Using QQuickPaintedItem uses an indirect 2D surface to render its content, either using software rasterization or using an OpenGL framebuffer object (FBO), so the rendering is a two-step operation. First rasterize the surface, then draw the surface. Using scene graph API directly is always significantly faster.</para>
            <para></para>
            <para>Behavior Animations</para>
            <para>If your Item uses the Behavior type to define animations for property changes, you should always use either QObject::setProperty(), QQmlProperty(), or QMetaProperty::write() when you need to modify those properties from C++. This ensures that the QML engine knows about the property change. Otherwise, the engine won't be able to carry out your requested animation. Note that these functions incur a slight performance penalty. For more details, see Accessing Members of a QML Object Type from C++.</para>
            <para></para>
            <para>See also QQuickWindow and QQuickPaintedItem.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickItem.#ctor(QtQuick.QQuickItem)">
            <summary>
            <para>Constructs a QQuickItem with the given parent.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.StackBefore(QtQuick.QQuickItem)">
            <summary>
            <para>Moves the specified sibling item to the index before this item within the list of children. The order of children affects both the visual stacking order and tab focus navigation order.</para>
            <para>Assuming the z values of both items are the same, this will cause sibling to be rendered above this item.</para>
            <para>If both items have activeFocusOnTab set to true, this will also cause the tab focus order to change, with sibling receiving focus after this item.</para>
            <para>The given sibling must be a sibling of this item; that is, they must have the same immediate parent.</para>
            <para>See also Concepts - Visual Parent in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.StackAfter(QtQuick.QQuickItem)">
            <summary>
            <para>Moves the specified sibling item to the index after this item within the list of children. The order of children affects both the visual stacking order and tab focus navigation order.</para>
            <para>Assuming the z values of both items are the same, this will cause sibling to be rendered below this item.</para>
            <para>If both items have activeFocusOnTab set to true, this will also cause the tab focus order to change, with sibling receiving focus before this item.</para>
            <para>The given sibling must be a sibling of this item; that is, they must have the same immediate parent.</para>
            <para>See also Concepts - Visual Parent in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ResetWidth">
            <summary>
            <para>This property holds the width of this item.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ResetHeight">
            <summary>
            <para>This property holds the height of this item.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ResetAntialiasing">
            <summary>
            <para>This property specifies whether the item is antialiased or not.</para>
            <para>Used by visual elements to decide if the item should use antialiasing or not. In some cases items with antialiasing require more memory and are potentially slower to render (see Antialiasing for more details).</para>
            <para>The default is false, but may be overridden by derived elements.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.SetFlag(QtQuick.QQuickItem.Flag,System.Boolean)">
            <summary>
            <para>Enables the specified flag for this item if enabled is true; if enabled is false, the flag is disabled.</para>
            <para>These provide various hints for the item; for example, the ItemClipsChildrenToShape flag indicates that all children of this item should be clipped to fit within the item area.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.SetFocus(System.Boolean)">
            <summary>
            <para>This property holds whether the item has focus within the enclosing FocusScope. If true, this item will gain active focus when the enclosing FocusScope gains active focus.</para>
            <para>In the following example, input will be given active focus when scope gains active focus:</para>
            <para></para>
            <para></para>
            <para>  import QtQuick 2.0</para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      FocusScope {</para>
            <para>          id: scope</para>
            <para></para>
            <para>          TextInput {</para>
            <para>              id: input</para>
            <para>              focus: true</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>For the purposes of this property, the scene as a whole is assumed to act like a focus scope. On a practical level, that means the following QML will give active focus to input on startup.</para>
            <para></para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      TextInput {</para>
            <para>            id: input</para>
            <para>            focus: true</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Access functions:</para>
            <para></para>
            <para> bool 	hasFocus() const</para>
            <para> void 	setFocus(bool)</para>
            <para> void 	setFocus(bool focus, Qt::FocusReason reason)</para>
            <para></para>
            <para>See also activeFocus and Keyboard Focus in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.SetFocus(System.Boolean,QtCore.Qt.FocusReason)">
            <summary>
            <para>This property holds whether the item has focus within the enclosing FocusScope. If true, this item will gain active focus when the enclosing FocusScope gains active focus.</para>
            <para>In the following example, input will be given active focus when scope gains active focus:</para>
            <para></para>
            <para></para>
            <para>  import QtQuick 2.0</para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      FocusScope {</para>
            <para>          id: scope</para>
            <para></para>
            <para>          TextInput {</para>
            <para>              id: input</para>
            <para>              focus: true</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>For the purposes of this property, the scene as a whole is assumed to act like a focus scope. On a practical level, that means the following QML will give active focus to input on startup.</para>
            <para></para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      TextInput {</para>
            <para>            id: input</para>
            <para>            focus: true</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Access functions:</para>
            <para></para>
            <para> bool 	hasFocus() const</para>
            <para> void 	setFocus(bool)</para>
            <para> void 	setFocus(bool focus, Qt::FocusReason reason)</para>
            <para></para>
            <para>See also activeFocus and Keyboard Focus in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.UnsetCursor">
            <summary>
            <para>Clears the cursor shape for this item.</para>
            <para>See also cursor() and setCursor().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.GrabMouse">
            <summary>
            <para>Grabs the mouse input.</para>
            <para>This item will receive all mouse events until ungrabMouse() is called.</para>
            <para>Warning: This function should be used with caution.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.UngrabMouse">
            <summary>
            <para>Releases the mouse grab following a call to grabMouse().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.UngrabTouchPoints">
            <summary>
            <para>Ungrabs the touch points owned by this item.</para>
            <para>See also grabTouchPoints().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.Contains(QtCore.QPointF)">
            <summary>
            <para>Returns true if this item contains point, which is in local coordinates; returns false otherwise.</para>
            <para>This function can be overwritten in order to handle point collisions in items with custom shapes. The default implementation checks if the point is inside the item's bounding rect.</para>
            <para>Note that this method is generally used to check whether the item is under the mouse cursor, and for that reason, the implementation of this function should be as light-weight as possible.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapToItem(QtQuick.QQuickItem,QtCore.QPointF)">
            <summary>
            <para>Maps the given point in this item's coordinate system to the equivalent point within item's coordinate system, and returns the mapped coordinate.</para>
            <para>If item is 0, this maps point to the coordinate system of the scene.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapToScene(QtCore.QPointF)">
            <summary>
            <para>Maps the given point in this item's coordinate system to the equivalent point within the scene's coordinate system, and returns the mapped coordinate.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapRectToItem(QtQuick.QQuickItem,QtCore.QRectF)">
            <summary>
            <para>Maps the given rect in this item's coordinate system to the equivalent rectangular area within item's coordinate system, and returns the mapped rectangle value.</para>
            <para>If item is 0, this maps rect to the coordinate system of the scene.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapRectToScene(QtCore.QRectF)">
            <summary>
            <para>Maps the given rect in this item's coordinate system to the equivalent rectangular area within the scene's coordinate system, and returns the mapped rectangle value.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapFromItem(QtQuick.QQuickItem,QtCore.QPointF)">
            <summary>
            <para>Maps the given point in item's coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</para>
            <para>If item is 0, this maps point from the coordinate system of the scene.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapFromScene(QtCore.QPointF)">
            <summary>
            <para>Maps the given point in the scene's coordinate system to the equivalent point within this item's coordinate system, and returns the mapped coordinate.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapRectFromItem(QtQuick.QQuickItem,QtCore.QRectF)">
            <summary>
            <para>Maps the given rect in item's coordinate system to the equivalent rectangular area within this item's coordinate system, and returns the mapped rectangle value.</para>
            <para>If item is 0, this maps rect from the coordinate system of the scene.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MapRectFromScene(QtCore.QRectF)">
            <summary>
            <para>Maps the given rect in the scene's coordinate system to the equivalent rectangular area within this item's coordinate system, and returns the mapped rectangle value.</para>
            <para>See also Concepts - Visual Coordinates in Qt Quick.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.Polish">
            <summary>
            <para>Schedules a polish event for this item.</para>
            <para>When the scene graph processes the request, it will call updatePolish() on this item.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ForceActiveFocus">
            <summary>
            <para>Forces active focus on the item.</para>
            <para>This method sets focus on the item and ensures that all ancestor FocusScope objects in the object hierarchy are also given focus.</para>
            <para>The reason for the focus change will be Qt::OtherFocusReason. Use the overloaded method to specify the focus reason to enable better handling of the focus change.</para>
            <para>See also activeFocus.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ForceActiveFocus(QtCore.Qt.FocusReason)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Forces active focus on the item with the given reason.</para>
            <para>This method sets focus on the item and ensures that all ancestor FocusScope objects in the object hierarchy are also given focus.</para>
            <para>This function was introduced in  Qt 5.1.</para>
            <para>See also activeFocus and Qt::FocusReason.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.NextItemInFocusChain(System.Boolean)">
            <summary>
            <para>Returns the item in the focus chain which is next to this item. If forward is true, or not supplied, it is the next item in the forwards direction. If forward is false, it is the next item in the backwards direction.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ChildAt(System.Double,System.Double)">
            <summary>
            <para>Returns the first visible child item found at point (x, y) within the coordinate system of this item.</para>
            <para>Returns 0 if there is no such item.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.InputMethodQuery(QtCore.Qt.InputMethodQuery)">
            <summary>
            <para>This method is only relevant for input items.</para>
            <para>If this item is an input item, this method should be reimplemented to return the relevant input method flags for the given query.</para>
            <para>See also QWidget::inputMethodQuery().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.Update">
            <summary>
            <para>Schedules a call to updatePaintNode() for this item.</para>
            <para>The call to QQuickItem::updatePaintNode() will always happen if the item is showing in a QQuickWindow.</para>
            <para>Only items which specify QQuickItem::ItemHasContents are allowed to call QQuickItem::update().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnEvent(QtCore.QEvent)">
            <summary>
            <para>Reimplemented from QObject::event().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.itemChange(QtQuick.QQuickItem.ItemChange,QtQuick.QQuickItem.ItemChangeData)">
            <summary>
            <para>Called when change occurs for this item.</para>
            <para>value contains extra information relating to the change, when applicable.</para>
            <para>If you re-implement this method in a subclass, be sure to call</para>
            <para></para>
            <para></para>
            <para>  QQuickItem::itemChange(change, value);</para>
            <para></para>
            <para></para>
            <para>typically at the end of your implementation, to ensure the windowChanged() signal will be emitted.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.UpdateInputMethod(QtCore.Qt.InputMethodQuery)">
            <summary>
            <para>Notify input method on updated query values if needed. queries indicates the changed attributes.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ClassBegin">
            <summary>
            <para>Reimplemented from QQmlParserStatus::classBegin().</para>
            <para>Derived classes should call the base class method before adding their own action to perform at classBegin.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ComponentComplete">
            <summary>
            <para>Reimplemented from QQmlParserStatus::componentComplete().</para>
            <para>Derived classes should call the base class method before adding their own actions to perform at componentComplete.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnKeyPressEvent(QtGui.QKeyEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive key press events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnKeyReleaseEvent(QtGui.QKeyEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive key release events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnInputMethodEvent(QtGui.QInputMethodEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive input method events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnFocusInEvent(QtGui.QFocusEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive focus-in events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnFocusOutEvent(QtGui.QFocusEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive focus-out events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnMousePressEvent(QtGui.QMouseEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse press events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnMouseMoveEvent(QtGui.QMouseEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse move events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnMouseReleaseEvent(QtGui.QMouseEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse release events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnMouseDoubleClickEvent(QtGui.QMouseEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse double-click events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.MouseUngrabEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to be notified when a mouse ungrab event has occurred on this item.</para>
            <para>See also ungrabMouse().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.TouchUngrabEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to be notified when a touch ungrab event has occurred on this item.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnWheelEvent(QtGui.QWheelEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive wheel events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnTouchEvent(QtGui.QTouchEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive touch events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnHoverEnterEvent(QtGui.QHoverEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive hover-enter events for an item. The event information is provided by the event parameter.</para>
            <para>Hover events are only provided if acceptHoverEvents() is true.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnHoverMoveEvent(QtGui.QHoverEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive hover-move events for an item. The event information is provided by the event parameter.</para>
            <para>Hover events are only provided if acceptHoverEvents() is true.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnHoverLeaveEvent(QtGui.QHoverEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive hover-leave events for an item. The event information is provided by the event parameter.</para>
            <para>Hover events are only provided if acceptHoverEvents() is true.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnDragEnterEvent(QtGui.QDragEnterEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drag-enter events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnDragMoveEvent(QtGui.QDragMoveEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drag-move events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnDragLeaveEvent(QtGui.QDragLeaveEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drag-leave events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.OnDropEvent(QtGui.QDropEvent)">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drop events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ChildMouseEventFilter(QtQuick.QQuickItem,QtCore.QEvent)">
            <summary>
            <para>Reimplement this method to filter the mouse events that are received by this item's children.</para>
            <para>This method will only be called if filtersChildMouseEvents() is true.</para>
            <para>Return true if the specified event should not be passed onto the specified child item, and false otherwise.</para>
            <para>See also setFiltersChildMouseEvents().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.GeometryChanged(QtCore.QRectF,QtCore.QRectF)">
            <summary>
            <para>This function is called to handle this item's changes in geometry from oldGeometry to newGeometry. If the two geometries are the same, it doesn't do anything.</para>
            <para>Derived classes must call the base class method within their implementation.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.UpdatePaintNode(QtQuick.QSGNode,QtQuick.QQuickItem.UpdatePaintNodeData)">
            <summary>
            <para>Called on the render thread when it is time to sync the state of the item with the scene graph.</para>
            <para>The function is called as a result of QQuickItem::update(), if the user has set the QQuickItem::ItemHasContents flag on the item.</para>
            <para>The function should return the root of the scene graph subtree for this item. Most implementations will return a single QSGGeometryNode containing the visual representation of this item. oldNode is the node that was returned the last time the function was called. updatePaintNodeData provides a pointer to the QSGTransformNode associated with this QQuickItem.</para>
            <para></para>
            <para></para>
            <para>  QSGNode *MyItem::updatePaintNode(QSGNode *node, UpdatePaintNodeData *)</para>
            <para>  {</para>
            <para>      QSGSimpleRectNode *n = static_cast&lt;QSGSimpleRectNode *&gt;(node);</para>
            <para>      if (!n) {</para>
            <para>          n = new QSGSimpleRectNode();</para>
            <para>          n-&gt;setColor(Qt::red);</para>
            <para>      }</para>
            <para>      n-&gt;setRect(boundingRect());</para>
            <para>      return n;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>The main thread is blocked while this function is executed so it is safe to read values from the QQuickItem instance and other objects in the main thread.</para>
            <para>If no call to QQuickItem::updatePaintNode() result in actual scene graph changes, like QSGNode::markDirty() or adding and removing nodes, then the underlying implementation may decide to not render the scene again as the visual outcome is identical.</para>
            <para>Warning: It is crucial that OpenGL operations and interaction with the scene graph happens exclusively on the render thread, primarily during the QQuickItem::updatePaintNode() call. The best rule of thumb is to only use classes with the &quot;QSG&quot; prefix inside the QQuickItem::updatePaintNode() function.</para>
            <para>Warning: This function is called on the render thread. This means any QObjects or thread local storage that is created will have affinity to the render thread, so apply caution when doing anything other than rendering in this function. Similarly for signals, these will be emitted on the render thread and will thus often be delivered via queued connections.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            <para>See also QSGMaterial, QSGSimpleMaterial, QSGGeometryNode, QSGGeometry, QSGFlatColorMaterial, QSGTextureMaterial, QSGNode::markDirty(), and Graphics Resource Handling.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.ReleaseResources">
            <summary>
            <para>This function is called when an item should release graphics resources which are not already managed by the nodes returend from QQuickItem::updatePaintNode().</para>
            <para>This happens when the item is about to be removed from window it was previously rendering to. The item is guaranteed to have a window when the function is called.</para>
            <para>The function is called on the GUI thread and the state of the rendering thread, when it is used, is unknown. Objects should not be deleted directly, but instead scheduled for cleanup using QQuickWindow::scheduleRenderJob().</para>
            <para>See also Graphics Resource Handling.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickItem.UpdatePolish">
            <summary>
            <para>This function should perform any layout as required for this item.</para>
            <para>When polish() is called, the scene graph schedules a polish event for this item. When the scene graph is ready to render this item, it calls updatePolish() to do any item layout as required before it renders the next frame.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.WindowChanged">
            <summary>
            <para>This signal is emitted when the item's window changes.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.KeyPressEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive key press events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.KeyReleaseEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive key release events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.InputMethodEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive input method events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.FocusInEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive focus-in events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.FocusOutEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive focus-out events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.MousePressEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse press events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.MouseMoveEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse move events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.MouseReleaseEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse release events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.MouseDoubleClickEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive mouse double-click events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.WheelEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive wheel events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.TouchEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive touch events for an item. The event information is provided by the event parameter.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.HoverEnterEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive hover-enter events for an item. The event information is provided by the event parameter.</para>
            <para>Hover events are only provided if acceptHoverEvents() is true.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.HoverMoveEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive hover-move events for an item. The event information is provided by the event parameter.</para>
            <para>Hover events are only provided if acceptHoverEvents() is true.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.HoverLeaveEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive hover-leave events for an item. The event information is provided by the event parameter.</para>
            <para>Hover events are only provided if acceptHoverEvents() is true.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.DragEnterEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drag-enter events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.DragMoveEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drag-move events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.DragLeaveEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drag-leave events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItem.DropEvent">
            <summary>
            <para>This event handler can be reimplemented in a subclass to receive drop events for an item. The event information is provided by the event parameter.</para>
            <para>Drag and drop events are only provided if the ItemAcceptsDrops flag has been set for this item.</para>
            <para>See also Drag and Drag and Drop.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ParentItem">
            <summary>
            <para>This property holds the visual parent of the item.</para>
            <para>Note: The concept of the visual parent differs from that of the QObject parent. An item's visual parent may not necessarily be the same as its object parent. See Concepts - Visual Parent in Qt Quick for more details.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QQuickItem *	parentItem() const</para>
            <para> void 	setParentItem(QQuickItem *parent)</para>
            <para></para>
            <para></para>
            <para>This property holds the visual parent of the item.</para>
            <para>Note: The concept of the visual parent differs from that of the QObject parent. An item's visual parent may not necessarily be the same as its object parent. See Concepts - Visual Parent in Qt Quick for more details.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QQuickItem *	parentItem() const</para>
            <para> void 	setParentItem(QQuickItem *parent)</para>
            <para></para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Clip">
            <summary>
            <para>This property holds whether clipping is enabled. The default clip value is false.</para>
            <para>If clipping is enabled, an item will clip its own painting, as well as the painting of its children, to its bounding rectangle. If you set clipping during an item's paint operation, remember to re-set it to prevent clipping the rest of your scene.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.State">
            <summary>
            <para>This property holds the name of the current state of the item.</para>
            <para>If the item is in its default state, that is, no explicit state has been set, then this property holds an empty string. Likewise, you can return an item to its default state by setting this property to an empty string.</para>
            <para>See also Qt Quick States.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.BaselineOffset">
            <summary>
            <para>Specifies the position of the item's baseline in local coordinates.</para>
            <para>The baseline of a Text item is the imaginary line on which the text sits. Controls containing text usually set their baseline to the baseline of their text.</para>
            <para>For non-text items, a default baseline offset of 0 is used.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.X">
            <summary>
            <para>Defines the item's x position relative to its parent.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Y">
            <summary>
            <para>Defines the item's y position relative to its parent.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Width">
            <summary>
            <para>This property holds the width of this item.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ImplicitWidth">
            <summary>
            <para>Defines the natural width or height of the Item if no width or height is specified.</para>
            <para>The default implicit size for most items is 0x0, however some items have an inherent implicit size which cannot be overridden, for example, Image and Text.</para>
            <para>Setting the implicit size is useful for defining components that have a preferred size based on their content, for example:</para>
            <para></para>
            <para></para>
            <para>  // Label.qml</para>
            <para>  import QtQuick 2.0</para>
            <para></para>
            <para>  Item {</para>
            <para>      property alias icon: image.source</para>
            <para>      property alias label: text.text</para>
            <para>      implicitWidth: text.implicitWidth + image.implicitWidth</para>
            <para>      implicitHeight: Math.max(text.implicitHeight, image.implicitHeight)</para>
            <para>      Image { id: image }</para>
            <para>      Text {</para>
            <para>          id: text</para>
            <para>          wrapMode: Text.Wrap</para>
            <para>          anchors.left: image.right; anchors.right: parent.right</para>
            <para>          anchors.verticalCenter: parent.verticalCenter</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Note: Using implicitWidth of Text or TextEdit and setting the width explicitly incurs a performance penalty as the text must be laid out twice.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Height">
            <summary>
            <para>This property holds the height of this item.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ImplicitHeight">
            <summary>
            <para>Defines the natural width or height of the Item if no width or height is specified.</para>
            <para>The default implicit size for most items is 0x0, however some items have an inherent implicit size which cannot be overridden, for example, Image and Text.</para>
            <para>Setting the implicit size is useful for defining components that have a preferred size based on their content, for example:</para>
            <para></para>
            <para></para>
            <para>  // Label.qml</para>
            <para>  import QtQuick 2.0</para>
            <para></para>
            <para>  Item {</para>
            <para>      property alias icon: image.source</para>
            <para>      property alias label: text.text</para>
            <para>      implicitWidth: text.implicitWidth + image.implicitWidth</para>
            <para>      implicitHeight: Math.max(text.implicitHeight, image.implicitHeight)</para>
            <para>      Image { id: image }</para>
            <para>      Text {</para>
            <para>          id: text</para>
            <para>          wrapMode: Text.Wrap</para>
            <para>          anchors.left: image.right; anchors.right: parent.right</para>
            <para>          anchors.verticalCenter: parent.verticalCenter</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Note: Using implicitWidth of Text or TextEdit and setting the width explicitly incurs a performance penalty as the text must be laid out twice.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.transformOrigin">
            <summary>
            <para>This property holds the origin point around which scale and rotation transform.</para>
            <para>Nine transform origins are available, as shown in the image below. The default transform origin is Item.Center.</para>
            <para></para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Z">
            <summary>
            <para>Sets the stacking order of sibling items. By default the stacking order is 0.</para>
            <para>Items with a higher stacking value are drawn on top of siblings with a lower stacking order. Items with the same stacking value are drawn bottom up in the order they appear. Items with a negative stacking value are drawn under their parent's content.</para>
            <para>The following example shows the various effects of stacking order.</para>
            <para></para>
            <para> 	Same z - later children above earlier children:</para>
            <para></para>
            <para>  Item {</para>
            <para>      Rectangle {</para>
            <para>          color: &quot;red&quot;</para>
            <para>          width: 100; height: 100</para>
            <para>      }</para>
            <para>      Rectangle {</para>
            <para>          color: &quot;blue&quot;</para>
            <para>          x: 50; y: 50; width: 100; height: 100</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para>	Higher z on top:</para>
            <para></para>
            <para>  Item {</para>
            <para>      Rectangle {</para>
            <para>          z: 1</para>
            <para>          color: &quot;red&quot;</para>
            <para>          width: 100; height: 100</para>
            <para>      }</para>
            <para>      Rectangle {</para>
            <para>          color: &quot;blue&quot;</para>
            <para>          x: 50; y: 50; width: 100; height: 100</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para>	Same z - children above parents:</para>
            <para></para>
            <para>  Item {</para>
            <para>      Rectangle {</para>
            <para>          color: &quot;red&quot;</para>
            <para>          width: 100; height: 100</para>
            <para>          Rectangle {</para>
            <para>              color: &quot;blue&quot;</para>
            <para>              x: 50; y: 50; width: 100; height: 100</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para>	Lower z below:</para>
            <para></para>
            <para>  Item {</para>
            <para>      Rectangle {</para>
            <para>          color: &quot;red&quot;</para>
            <para>          width: 100; height: 100</para>
            <para>          Rectangle {</para>
            <para>              z: -1</para>
            <para>              color: &quot;blue&quot;</para>
            <para>              x: 50; y: 50; width: 100; height: 100</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para></para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Rotation">
            <summary>
            <para>This property holds the rotation of the item in degrees clockwise around its transformOrigin.</para>
            <para>The default value is 0 degrees (that is, no rotation).</para>
            <para></para>
            <para> 	</para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      color: &quot;blue&quot;</para>
            <para>      width: 100; height: 100</para>
            <para>      Rectangle {</para>
            <para>          color: &quot;red&quot;</para>
            <para>          x: 25; y: 25; width: 50; height: 50</para>
            <para>          rotation: 30</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para></para>
            <para>See also Transform and Rotation.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Scale">
            <summary>
            <para>This property holds the scale factor for this item.</para>
            <para>A scale of less than 1.0 causes the item to be rendered at a smaller size, and a scale greater than 1.0 renders the item at a larger size. A negative scale causes the item to be mirrored when rendered.</para>
            <para>The default value is 1.0.</para>
            <para>Scaling is applied from the transformOrigin.</para>
            <para></para>
            <para> 	</para>
            <para></para>
            <para>  import QtQuick 2.0</para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      color: &quot;blue&quot;</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      Rectangle {</para>
            <para>          color: &quot;green&quot;</para>
            <para>          width: 25; height: 25</para>
            <para>      }</para>
            <para></para>
            <para>      Rectangle {</para>
            <para>          color: &quot;red&quot;</para>
            <para>          x: 25; y: 25; width: 50; height: 50</para>
            <para>          scale: 1.4</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para></para>
            <para>See also Transform and Scale.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Opacity">
            <summary>
            <para>This property holds the opacity of the item. Opacity is specified as a number between 0.0 (fully transparent) and 1.0 (fully opaque). The default value is 1.0.</para>
            <para>When this property is set, the specified opacity is also applied individually to child items. This may have an unintended effect in some circumstances. For example in the second set of rectangles below, the red rectangle has specified an opacity of 0.5, which affects the opacity of its blue child rectangle even though the child has not specified an opacity.</para>
            <para>Values outside the range of 0 to 1 will be clamped.</para>
            <para></para>
            <para> 	</para>
            <para></para>
            <para>  Item {</para>
            <para>      Rectangle {</para>
            <para>          color: &quot;red&quot;</para>
            <para>          width: 100; height: 100</para>
            <para>          Rectangle {</para>
            <para>              color: &quot;blue&quot;</para>
            <para>              x: 50; y: 50; width: 100; height: 100</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para>	</para>
            <para></para>
            <para>  Item {</para>
            <para>      Rectangle {</para>
            <para>          opacity: 0.5</para>
            <para>          color: &quot;red&quot;</para>
            <para>          width: 100; height: 100</para>
            <para>          Rectangle {</para>
            <para>              color: &quot;blue&quot;</para>
            <para>              x: 50; y: 50; width: 100; height: 100</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para></para>
            <para></para>
            <para>Changing an item's opacity does not affect whether the item receives user input events. (In contrast, setting visible property to false stops mouse events, and setting the enabled property to false stops mouse and keyboard events, and also removes active focus from the item.)</para>
            <para>See also visible.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Visible">
            <summary>
            <para>This property holds whether the item is visible. By default this is true.</para>
            <para>Setting this property directly affects the visible value of child items. When set to false, the visible values of all child items also become false. When set to true, the visible values of child items are returned to true, unless they have explicitly been set to false.</para>
            <para>(Because of this flow-on behavior, using the visible property may not have the intended effect if a property binding should only respond to explicit property changes. In such cases it may be better to use the opacity property instead.)</para>
            <para>If this property is set to false, the item will no longer receive mouse events, but will continue to receive key events and will retain the keyboard focus if it has been set. (In contrast, setting the enabled property to false stops both mouse and keyboard events, and also removes focus from the item.)</para>
            <para>Note: This property's value is only affected by changes to this property or the parent's visible property. It does not change, for example, if this item moves off-screen, or if the opacity changes to 0.</para>
            <para>See also opacity and enabled.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Enabled">
            <summary>
            <para>This property holds whether the item receives mouse and keyboard events. By default this is true.</para>
            <para>Setting this property directly affects the enabled value of child items. When set to false, the enabled values of all child items also become false. When set to true, the enabled values of child items are returned to true, unless they have explicitly been set to false.</para>
            <para>Setting this property to false automatically causes activeFocus to be set to false, and this item will longer receive keyboard events.</para>
            <para>See also visible.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Smooth">
            <summary>
            <para>This property specifies whether the item is smoothed or not.</para>
            <para>Primarily used in image based items to decide if the item should use smooth sampling or not. Smooth sampling is performed using linear interpolation, while non-smooth is performed using nearest neighbor.</para>
            <para>In Qt Quick 2.0, this property has minimal impact on performance.</para>
            <para>By default, this property is set to true.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ActiveFocusOnTab">
            <summary>
            <para>This property holds whether the item wants to be in the tab focus chain. By default, this is set to false.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Antialiasing">
            <summary>
            <para>This property specifies whether the item is antialiased or not.</para>
            <para>Used by visual elements to decide if the item should use antialiasing or not. In some cases items with antialiasing require more memory and are potentially slower to render (see Antialiasing for more details).</para>
            <para>The default is false, but may be overridden by derived elements.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Flags">
            <summary>
            <para>Returns the item flags for this item.</para>
            <para>See also setFlags() and setFlag().</para>
            <para></para>
            <para>Enables the specified flags for this item.</para>
            <para>See also flags() and setFlag().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.AcceptedMouseButtons">
            <summary>
            <para>Returns the mouse buttons accepted by this item.</para>
            <para>The default value is Qt::NoButton; that is, no mouse buttons are accepted.</para>
            <para>If an item does not accept the mouse button for a particular mouse event, the mouse event will not be delivered to the item and will be delivered to the next item in the item hierarchy instead.</para>
            <para>See also setAcceptedMouseButtons().</para>
            <para></para>
            <para>Sets the mouse buttons accepted by this item to buttons.</para>
            <para>See also acceptedMouseButtons().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.AcceptHoverEvents">
            <summary>
            <para>Returns whether hover events are accepted by this item.</para>
            <para>The default value is false.</para>
            <para>If this is false, then the item will not receive any hover events through the hoverEnterEvent(), hoverMoveEvent() and hoverLeaveEvent() functions.</para>
            <para>See also setAcceptHoverEvents().</para>
            <para></para>
            <para>If enabled is true, this sets the item to accept hover events; otherwise, hover events are not accepted by this item.</para>
            <para>See also acceptHoverEvents().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Cursor">
            <summary>
            <para>Returns the cursor shape for this item.</para>
            <para>The mouse cursor will assume this shape when it is over this item, unless an override cursor is set. See the list of predefined cursor objects for a range of useful shapes.</para>
            <para>If no cursor shape has been set this returns a cursor with the Qt::ArrowCursor shape, however another cursor shape may be displayed if an overlapping item has a valid cursor.</para>
            <para>See also setCursor() and unsetCursor().</para>
            <para></para>
            <para>Sets the cursor shape for this item.</para>
            <para>See also cursor() and unsetCursor().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.KeepMouseGrab">
            <summary>
            <para>Returns whether mouse input should exclusively remain with this item.</para>
            <para>See also setKeepMouseGrab().</para>
            <para></para>
            <para>Sets whether the mouse input should remain exclusively with this item.</para>
            <para>This is useful for items that wish to grab and keep mouse interaction following a predefined gesture. For example, an item that is interested in horizontal mouse movement may set keepMouseGrab to true once a threshold has been exceeded. Once keepMouseGrab has been set to true, filtering items will not react to mouse events.</para>
            <para>If keep is false, a filtering item may steal the grab. For example, Flickable may attempt to steal a mouse grab if it detects that the user has begun to move the viewport.</para>
            <para>See also keepMouseGrab().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.FiltersChildMouseEvents">
            <summary>
            <para>Returns whether mouse events of this item's children should be filtered through this item.</para>
            <para>See also setFiltersChildMouseEvents() and childMouseEventFilter().</para>
            <para></para>
            <para>Sets whether mouse events of this item's children should be filtered through this item.</para>
            <para>If filter is true, childMouseEventFilter() will be called when a mouse event is triggered for a child item.</para>
            <para>See also filtersChildMouseEvents().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.KeepTouchGrab">
            <summary>
            <para>Returns whether the touch points grabbed by this item should exclusively remain with this item.</para>
            <para>See also setKeepTouchGrab() and keepMouseGrab().</para>
            <para></para>
            <para>Sets whether the touch points grabbed by this item should remain exclusively with this item.</para>
            <para>This is useful for items that wish to grab and keep specific touch points following a predefined gesture. For example, an item that is interested in horizontal touch point movement may set setKeepTouchGrab to true once a threshold has been exceeded. Once setKeepTouchGrab has been set to true, filtering items will not react to the relevant touch points.</para>
            <para>If keep is false, a filtering item may steal the grab. For example, Flickable may attempt to steal a touch point grab if it detects that the user has begun to move the viewport.</para>
            <para>See also keepTouchGrab() and setKeepMouseGrab().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.Window">
            <summary>
            <para>Returns the window in which this item is rendered.</para>
            <para>The item does not have a window until it has been assigned into a scene. The windowChanged() signal provides a notification both when the item is entered into a scene and when it is removed from a scene.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ChildrenRect">
            <summary>
            <para>This property holds the collective position and size of the item's children.</para>
            <para>This property is useful if you need to access the collective geometry of an item's children in order to correctly size the item.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.HasActiveFocus">
            <summary>
            <para>This read-only property indicates whether the item has active focus.</para>
            <para>If activeFocus is true, either this item is the one that currently receives keyboard input, or it is a FocusScope ancestor of the item that currently receives keyboard input.</para>
            <para>Usually, activeFocus is gained by setting focus on an item and its enclosing FocusScope objects. In the following example, the input and focusScope objects will have active focus, while the root rectangle object will not.</para>
            <para></para>
            <para></para>
            <para>  import QtQuick 2.0</para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      FocusScope {</para>
            <para>          focus: true</para>
            <para></para>
            <para>          TextInput {</para>
            <para>              id: input</para>
            <para>              focus: true</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Access functions:</para>
            <para></para>
            <para> bool 	hasActiveFocus() const</para>
            <para></para>
            <para>See also focus and Keyboard Focus in Qt Quick.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.HasFocus">
            <summary>
            <para>This property holds whether the item has focus within the enclosing FocusScope. If true, this item will gain active focus when the enclosing FocusScope gains active focus.</para>
            <para>In the following example, input will be given active focus when scope gains active focus:</para>
            <para></para>
            <para></para>
            <para>  import QtQuick 2.0</para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      FocusScope {</para>
            <para>          id: scope</para>
            <para></para>
            <para>          TextInput {</para>
            <para>              id: input</para>
            <para>              focus: true</para>
            <para>          }</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>For the purposes of this property, the scene as a whole is assumed to act like a focus scope. On a practical level, that means the following QML will give active focus to input on startup.</para>
            <para></para>
            <para></para>
            <para>  Rectangle {</para>
            <para>      width: 100; height: 100</para>
            <para></para>
            <para>      TextInput {</para>
            <para>            id: input</para>
            <para>            focus: true</para>
            <para>      }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Access functions:</para>
            <para></para>
            <para> bool 	hasFocus() const</para>
            <para> void 	setFocus(bool)</para>
            <para> void 	setFocus(bool focus, Qt::FocusReason reason)</para>
            <para></para>
            <para>See also activeFocus and Keyboard Focus in Qt Quick.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.IsFocusScope">
            <summary>
            <para>Returns true if this item is a focus scope, and false otherwise.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ScopedFocusItem">
            <summary>
            <para>If this item is a focus scope, this returns the item in its focus chain that currently has focus.</para>
            <para>Returns 0 if this item is not a focus scope.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.IsTextureProvider">
            <summary>
            <para>Returns true if this item is a texture provider. The default implementation returns false.</para>
            <para>This function can be called from any thread.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.TextureProvider">
            <summary>
            <para>Returns the texture provider for an item. The default implementation returns 0.</para>
            <para>This function may only be called on the rendering thread.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.IsComponentComplete">
            <summary>
            <para>Returns true if construction of the QML component is complete; otherwise returns false.</para>
            <para>It is often desirable to delay some processing until the component is completed.</para>
            <para>See also componentComplete().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.WidthValid">
            <summary>
            <para>Returns whether the width property has been set explicitly.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.HeightValid">
            <summary>
            <para>Returns whether the height property has been set explicitly.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickItem.Flag">
            <summary>
            <para>This enum type is used to specify various item properties.</para>
            <para>The Flags type is a typedef for QFlags&lt;Flag&gt;. It stores an OR combination of Flag values.</para>
            <para>See also setFlag(), setFlags(), and flags().</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickItem.Flag.ItemClipsChildrenToShape">
            <summary>Indicates this item should visually clip its children so that they are rendered only within the boundaries of this item.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.Flag.ItemAcceptsInputMethod">
            <summary>Indicates the item supports text input methods.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.Flag.ItemIsFocusScope">
            <summary>Indicates the item is a focus scope. See Keyboard Focus in Qt Quick for more information.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.Flag.ItemHasContents">
            <summary>Indicates the item has visual content and should be rendered by the scene graph.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.Flag.ItemAcceptsDrops">
            <summary>Indicates the item accepts drag and drop events.</summary>
        </member>
        <member name="T:QtQuick.QQuickItem.ItemChange">
            <summary>
            <para>Used in conjunction with QQuickItem::itemChange() to notify the item about certain types of changes.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemChildAddedChange">
            <summary>A child was added. ItemChangeData::item contains the added child.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemChildRemovedChange">
            <summary>A child was removed. ItemChangeData::item contains the removed child.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemSceneChange">
            <summary>The item was added to or removed from a scene. The QQuickWindow rendering the scene is specified in using ItemChangeData::window. The window parameter is null when the item is removed from a scene.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemVisibleHasChanged">
            <summary>The item's visibility has changed. ItemChangeData::boolValue contains the new visibility.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemParentHasChanged">
            <summary>The item's parent has changed. ItemChangeData::item contains the new parent.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemOpacityHasChanged">
            <summary>The item's opacity has changed. ItemChangeData::realValue contains the new opacity.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemActiveFocusHasChanged">
            <summary>The item's focus has changed. ItemChangeData::boolValue contains whether the item has focus or not.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemRotationHasChanged">
            <summary>The item's rotation has changed. ItemChangeData::realValue contains the new rotation.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.ItemChange.ItemDevicePixelRatioHasChanged">
            <summary>The device pixel ratio of the screen the item is on has changed. ItemChangedData::realValue contains the new device pixel ratio.</summary>
        </member>
        <member name="T:QtQuick.QQuickItem.TransformOrigin">
            <summary>
            <para>Controls the point about which simple transforms like scale apply.</para>
            <para>See also transformOrigin() and setTransformOrigin().</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.TopLeft">
            <summary>The top-left corner of the item.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.Top">
            <summary>The center point of the top of the item.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.TopRight">
            <summary>The top-right corner of the item.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.Left">
            <summary>The left most point of the vertical middle.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.Center">
            <summary>The center of the item.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.Right">
            <summary>The right most point of the vertical middle.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.BottomLeft">
            <summary>The bottom-left corner of the item.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.Bottom">
            <summary>The center point of the bottom of the item.</summary>
        </member>
        <member name="F:QtQuick.QQuickItem.TransformOrigin.BottomRight">
            <summary>The bottom-right corner of the item.</summary>
        </member>
        <member name="T:QtQuick.QQuickItem.ItemChangeData">
            <summary>
            <para>Adds supplimentary information to the QQuickItem::itemChange() function.</para>
            </summary>
            <remarks>
            <para>The meaning of each member of this class is defined by the change type.</para>
            <para></para>
            <para>See also QQuickItem::ItemChange.</para>
            </remarks>
        </member>
        <member name="P:QtQuick.QQuickItem.ItemChangeData.Item">
            <summary>
            <para>Contains supplimentary information to the QQuickItem::itemChange() function.</para>
            <para>See also QQuickItem::ItemChange.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ItemChangeData.Window">
            <summary>
            <para>Contains supplimentary information to the QQuickItem::itemChange() function.</para>
            <para>See also QQuickItem::ItemChange.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ItemChangeData.RealValue">
            <summary>
            <para>Contains supplimentary information to the QQuickItem::itemChange() function.</para>
            <para>See also QQuickItem::ItemChange.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItem.ItemChangeData.BoolValue">
            <summary>
            <para>Contains supplimentary information to the QQuickItem::itemChange() function.</para>
            <para>See also QQuickItem::ItemChange.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickFramebufferObject">
            <summary>
            <para>The QQuickFramebufferObject class is a convenience class for integrating OpenGL rendering using a framebuffer object (FBO) with Qt Quick.</para>
            </summary>
            <remarks>
            <para>On most platforms, the rendering will occur on a dedicated thread. For this reason, the QQuickFramebufferObject class enforces a strict separation between the item implementation and the FBO rendering. All item logic, such as properties and UI-related helper functions needed by QML should be located in a QQuickFramebufferObject class subclass. Everything that relates to rendering must be located in the QQuickFramebufferObject::Renderer class.</para>
            <para>To avoid race conditions and read/write issues from two threads it is important that the renderer and the item never read or write shared variables. Communication between the item and the renderer should primarily happen via the QQuickFramebufferObject::Renderer::synchronize() function. This function will be called on the render thread while the GUI thread is blocked.</para>
            <para>Using queued connections or events for communication between item and renderer is also possible.</para>
            <para>Both the Renderer and the FBO are memory managed internally.</para>
            <para>To render into the FBO, the user should subclass the Renderer class and reimplement its Renderer::render() function. The Renderer subclass is returned from createRenderer().</para>
            <para>The size of the FBO will by default adapt to the size of the item. If a fixed size is preferred, set textureFollowsItemSize to false and return a texture of your choosing from QQuickFramebufferObject::Renderer::createFramebufferObject().</para>
            <para>Starting Qt 5.4, the QQuickFramebufferObject class is a texture provider and can be used directly in ShaderEffects and other classes that consume texture providers.</para>
            <para></para>
            <para>See also Scene Graph - Rendering FBOs and Scene Graph and Rendering.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.#ctor(QtQuick.QQuickItem)">
            <summary>
            <para>Constructs a new QQuickFramebufferObject with parent parent.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.CreateRenderer">
            <summary>
            <para>Reimplement this function to create a renderer used to render into the FBO.</para>
            <para>This function will be called on the rendering thread while the GUI thread is blocked.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.ReleaseResources">
            <summary>
            <para>Reimplemented from QQuickItem::releaseResources().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickFramebufferObject.TextureFollowsItemSizeChanged">
            <summary>
            <para>This property controls if the size of the FBO's texture should follow the dimensions of the QQuickFramebufferObject item. When this property is false, the FBO will be created once the first time it is displayed. If it is set to true, the FBO will be recreated every time the dimensions of the item change.</para>
            <para>The default value is true.</para>
            <para>Access functions:</para>
            <para></para>
            <para> bool 	textureFollowsItemSize() const</para>
            <para> void 	setTextureFollowsItemSize(bool follows)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	textureFollowsItemSizeChanged(bool)</para>
            <para></para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickFramebufferObject.MirrorVerticallyChanged">
            <summary>
            <para>This property controls if the size of the FBO's contents should be mirrored vertically when drawing. This allows easy integration of third-party rendering code that does not follow the standard expectations.</para>
            <para>The default value is false.</para>
            <para>This property was introduced in  Qt 5.6.</para>
            <para>Access functions:</para>
            <para></para>
            <para> bool 	mirrorVertically() const</para>
            <para> void 	setMirrorVertically(bool enable)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	mirrorVerticallyChanged(bool)</para>
            <para></para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickFramebufferObject.TextureFollowsItemSize">
            <summary>
            <para>This property controls if the size of the FBO's texture should follow the dimensions of the QQuickFramebufferObject item. When this property is false, the FBO will be created once the first time it is displayed. If it is set to true, the FBO will be recreated every time the dimensions of the item change.</para>
            <para>The default value is true.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickFramebufferObject.MirrorVertically">
            <summary>
            <para>This property controls if the size of the FBO's contents should be mirrored vertically when drawing. This allows easy integration of third-party rendering code that does not follow the standard expectations.</para>
            <para>The default value is false.</para>
            <para>This property was introduced in  Qt 5.6.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickFramebufferObject.IsTextureProvider">
            <summary>
            <para>Reimplemented from QQuickItem::isTextureProvider().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickFramebufferObject.TextureProvider">
            <summary>
            <para>Reimplemented from QQuickItem::textureProvider().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickFramebufferObject.Renderer">
            <summary>
            <para>The QQuickFramebufferObject::Renderer class is used to implement the rendering logic of a QQuickFramebufferObject.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.Renderer.#ctor">
            <summary>
            <para>Constructs a new renderer.</para>
            <para>This function is called during the scene graph sync phase when the GUI thread is blocked.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.Renderer.Render">
            <summary>
            <para>This function is called when the FBO should be rendered into. The framebuffer is bound at this point and the glViewport has been set up to match the FBO size.</para>
            <para>The FBO will be automatically unbound after the function returns.</para>
            <para>Note: Do not assume that the OpenGL state is all set to the defaults when this function is invoked, or that it is maintained between calls. Both the Qt Quick renderer and the custom rendering code uses the same OpenGL context. This means that the state might have been modified by Quick before invoking this function.</para>
            <para>Note: It is recommended to call QQuickWindow::resetOpenGLState() before returning. This resets OpenGL state used by the Qt Quick renderer and thus avoids interference from the state changes made by the rendering code in this function.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.Renderer.CreateFramebufferObject(QtCore.QSize)">
            <summary>
            <para>This function is called when a new FBO is needed. This happens on the initial frame. If QQuickFramebufferObject::textureFollowsItemSize is set to true, it is called again every time the dimensions of the item changes.</para>
            <para>The returned FBO can have any attachment. If the QOpenGLFramebufferObjectFormat indicates that the FBO should be multisampled, the internal implementation of the Renderer will allocate a second FBO and blit the multisampled FBO into the FBO used to display the texture.</para>
            <para>Note: Some hardware has issues with small FBO sizes. size takes that into account, so be cautious when overriding the size with a fixed size. A minimal size of 64x64 should always work.</para>
            <para>Note: size takes the device pixel ratio into account, meaning that it is already multiplied by the correct scale factor. When moving the window containing the QQuickFramebufferObject item to a screen with different settings, the FBO is automatically recreated and this function is invoked with the correct size.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.Renderer.Synchronize(QtQuick.QQuickFramebufferObject)">
            <summary>
            <para>This function is called as a result of QQuickFramebufferObject::update().</para>
            <para>Use this function to update the renderer with changes that have occurred in the item. item is the item that instantiated this renderer. The function is called once before the FBO is created.</para>
            <para>For instance, if the item has a color property which is controlled by QML, one should call QQuickFramebufferObject::update() and use synchronize() to copy the new color into the renderer so that it can be used to render the next frame.</para>
            <para>This function is the only place when it is safe for the renderer and the item to read and write each others members.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.Renderer.Update">
            <summary>
            <para>Call this function when the FBO should be rendered again.</para>
            <para>This function can be called from render() to force the FBO to be rendered again before the next frame.</para>
            <para>Note: This function should be used from inside the renderer. To update the item on the GUI thread, use QQuickFramebufferObject::update().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickFramebufferObject.Renderer.InvalidateFramebufferObject">
            <summary>
            <para>Call this function during synchronize() to invalidate the current FBO. This will result in a new FBO being created with createFramebufferObject().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickFramebufferObject.Renderer.FramebufferObject">
            <summary>
            <para>Returns the framebuffer object currently being rendered to.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickItemGrabResult">
            <summary>
            <para>The QQuickItemGrabResult contains the result from QQuickItem::grabToImage().</para>
            </summary>
            <remarks>
            <para>See also QQuickItem::grabToImage().</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickItemGrabResult.SaveToFile(System.String)">
            <summary>
            <para>Saves the grab result as an image to fileName. Returns true if successful; otherwise returns false.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickItemGrabResult.Ready">
            <summary>
            <para>This signal is emitted when the grab has completed.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItemGrabResult.Image">
            <summary>
            <para>This property holds the pixel results from a grab.</para>
            <para>If the grab is not yet complete or if it failed, an empty image is returned.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickItemGrabResult.Url">
            <summary>
            <para>This property holds a URL which can be used in conjunction with URL based image consumers, such as the QtQuick::Image type.</para>
            <para>The URL is valid until the QQuickItemGrabResult object is deleted.</para>
            <para>The URL does not represent a valid file or location to read it from, it is primarily a key to access images through Qt Quick's image-based types.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickPaintedItem">
            <summary>
            <para>The QQuickPaintedItem class provides a way to use the QPainter API in the QML Scene Graph.</para>
            </summary>
            <remarks>
            <para>The QQuickPaintedItem makes it possible to use the QPainter API with the QML Scene Graph. It sets up a textured rectangle in the Scene Graph and uses a QPainter to paint onto the texture. The render target can be either a QImage or a QOpenGLFramebufferObject. When the render target is a QImage, QPainter first renders into the image then the content is uploaded to the texture. When a QOpenGLFramebufferObject is used, QPainter paints directly onto the texture. Call update() to trigger a repaint.</para>
            <para>To enable QPainter to do anti-aliased rendering, use setAntialiasing().</para>
            <para>To write your own painted item, you first create a subclass of QQuickPaintedItem, and then start by implementing its only pure virtual public function: paint(), which implements the actual painting. The painting will be inside the rectangle spanning from 0,0 to width(),height().</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickPaintedItem.#ctor(QtQuick.QQuickItem)">
            <summary>
            <para>Constructs a QQuickPaintedItem with the given parent item.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickPaintedItem.Update(QtCore.QRect)">
            <summary>
            <para>Schedules a redraw of the area covered by rect in this item. You can call this function whenever your item needs to be redrawn, such as if it changes appearance or size.</para>
            <para>This function does not cause an immediate paint; instead it schedules a paint request that is processed by the QML Scene Graph when the next frame is rendered. The item will only be redrawn if it is visible.</para>
            <para>Note that calling this function will trigger a repaint of the whole scene.</para>
            <para>See also paint().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickPaintedItem.SetPerformanceHint(QtQuick.QQuickPaintedItem.PerformanceHint,System.Boolean)">
            <summary>
            <para>Sets the given performance hint on the item if enabled is true; otherwise clears the performance hint.</para>
            <para>By default, no performance hint is enabled/</para>
            <para>See also setPerformanceHints() and performanceHints().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickPaintedItem.ResetContentsSize">
            <summary>
            <para>This convenience function is equivalent to calling setContentsSize(QSize()).</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickPaintedItem.Paint(QtGui.QPainter)">
            <summary>
            <para>This function, which is usually called by the QML Scene Graph, paints the contents of an item in local coordinates.</para>
            <para>The underlying texture will have a size defined by textureSize when set, or the item's size, multiplied by the window's device pixel ratio.</para>
            <para>The function is called after the item has been filled with the fillColor.</para>
            <para>Reimplement this function in a QQuickPaintedItem subclass to provide the item's painting implementation, using painter.</para>
            <para>Note: The QML Scene Graph uses two separate threads, the main thread does things such as processing events or updating animations while a second thread does the actual OpenGL rendering. As a consequence, paint() is not called from the main GUI thread but from the GL enabled renderer thread. At the moment paint() is called, the GUI thread is blocked and this is therefore thread-safe.</para>
            <para>Warning: Extreme caution must be used when creating QObjects, emitting signals, starting timers and similar inside this function as these will have affinity to the rendering thread.</para>
            <para>See also width(), height(), and textureSize.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickPaintedItem.UpdatePaintNode(QtQuick.QSGNode,QtQuick.QQuickItem.UpdatePaintNodeData)">
            <summary>
            <para>Reimplemented from QQuickItem::updatePaintNode().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickPaintedItem.ReleaseResources">
            <summary>
            <para>Reimplemented from QQuickItem::releaseResources().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickPaintedItem.FillColorChanged">
            <summary>
            <para>This property holds the item's background fill color.</para>
            <para>By default, the fill color is set to Qt::transparent.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QColor 	fillColor() const</para>
            <para> void 	setFillColor(const QColor &amp;)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	fillColorChanged()</para>
            <para></para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickPaintedItem.ContentsSizeChanged">
            <summary>
            <para>This property holds obsolete method for setting the contents size.</para>
            <para>This function is provided for compatibility, use size in combination with textureSize to decide the size of what you are drawing.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QSize 	contentsSize() const</para>
            <para> void 	setContentsSize(const QSize &amp;)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	contentsSizeChanged()</para>
            <para></para>
            <para>See also width(), height(), and textureSize().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickPaintedItem.ContentsScaleChanged">
            <summary>
            <para>This property holds obsolete method for scaling the contents.</para>
            <para>This function is provided for compatibility, use size() in combination with textureSize() to decide the size of what you are drawing.</para>
            <para>Access functions:</para>
            <para></para>
            <para> qreal 	contentsScale() const</para>
            <para> void 	setContentsScale(qreal)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	contentsScaleChanged()</para>
            <para></para>
            <para>See also width(), height(), and textureSize().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickPaintedItem.RenderTargetChanged">
            <summary>
            <para>This property holds the item's render target.</para>
            <para>This property defines which render target the QPainter renders into, it can be either QQuickPaintedItem::Image, QQuickPaintedItem::FramebufferObject or QQuickPaintedItem::InvertedYFramebufferObject.</para>
            <para>Each has certain benefits, typically performance versus quality. Using a framebuffer object avoids a costly upload of the image contents to the texture in graphics memory, while using an image enables high quality anti-aliasing.</para>
            <para>Warning: Resizing a framebuffer object is a costly operation, avoid using the QQuickPaintedItem::FramebufferObject render target if the item gets resized often.</para>
            <para>By default, the render target is QQuickPaintedItem::Image.</para>
            <para>Access functions:</para>
            <para></para>
            <para> RenderTarget 	renderTarget() const</para>
            <para> void 	setRenderTarget(RenderTarget target)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	renderTargetChanged()</para>
            <para></para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickPaintedItem.TextureSizeChanged">
            <summary>
            <para>This property defines the size of the texture.</para>
            <para>Changing the texture's size does not affect the coordinate system used in paint(). A scale factor is instead applied so painting should still happen inside 0,0 to width(),height().</para>
            <para>By default, the texture size will have the same size as this item.</para>
            <para>Note: If the item is on a window with a device pixel ratio different from 1, this scale factor will be implicitly applied to the texture size.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QSize 	textureSize() const</para>
            <para> void 	setTextureSize(const QSize &amp;size)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	textureSizeChanged()</para>
            <para></para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.OpaquePainting">
            <summary>
            <para>Returns true if this item is opaque; otherwise, false is returned.</para>
            <para>By default, painted items are not opaque.</para>
            <para>See also setOpaquePainting().</para>
            <para></para>
            <para>If opaque is true, the item is opaque; otherwise, it is considered as translucent.</para>
            <para>Opaque items are not blended with the rest of the scene, you should set this to true if the content of the item is opaque to speed up rendering.</para>
            <para>By default, painted items are not opaque.</para>
            <para>See also opaquePainting().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.Antialiasing">
            <summary>
            <para>Returns true if antialiased painting is enabled; otherwise, false is returned.</para>
            <para>By default, antialiasing is not enabled.</para>
            <para>See also setAntialiasing().</para>
            <para></para>
            <para>If enable is true, antialiased painting is enabled.</para>
            <para>By default, antialiasing is not enabled.</para>
            <para>See also antialiasing().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.Mipmap">
            <summary>
            <para>Returns true if mipmaps are enabled; otherwise, false is returned.</para>
            <para>By default, mipmapping is not enabled.</para>
            <para>See also setMipmap().</para>
            <para></para>
            <para>If enable is true, mipmapping is enabled on the associated texture.</para>
            <para>Mipmapping increases rendering speed and reduces aliasing artifacts when the item is scaled down.</para>
            <para>By default, mipmapping is not enabled.</para>
            <para>See also mipmap().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.PerformanceHints">
            <summary>
            <para>Returns the performance hints.</para>
            <para>By default, no performance hint is enabled.</para>
            <para>See also setPerformanceHint() and setPerformanceHints().</para>
            <para></para>
            <para>Sets the performance hints to hints</para>
            <para>By default, no performance hint is enabled/</para>
            <para>See also setPerformanceHint() and performanceHints().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.ContentsSize">
            <summary>
            <para>This property holds obsolete method for setting the contents size.</para>
            <para>This function is provided for compatibility, use size in combination with textureSize to decide the size of what you are drawing.</para>
            <para>See also width(), height(), and textureSize().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.ContentsScale">
            <summary>
            <para>This property holds obsolete method for scaling the contents.</para>
            <para>This function is provided for compatibility, use size() in combination with textureSize() to decide the size of what you are drawing.</para>
            <para>See also width(), height(), and textureSize().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.TextureSize">
            <summary>
            <para>This property defines the size of the texture.</para>
            <para>Changing the texture's size does not affect the coordinate system used in paint(). A scale factor is instead applied so painting should still happen inside 0,0 to width(),height().</para>
            <para>By default, the texture size will have the same size as this item.</para>
            <para>Note: If the item is on a window with a device pixel ratio different from 1, this scale factor will be implicitly applied to the texture size.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.FillColor">
            <summary>
            <para>This property holds the item's background fill color.</para>
            <para>By default, the fill color is set to Qt::transparent.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.renderTarget">
            <summary>
            <para>This property holds the item's render target.</para>
            <para>This property defines which render target the QPainter renders into, it can be either QQuickPaintedItem::Image, QQuickPaintedItem::FramebufferObject or QQuickPaintedItem::InvertedYFramebufferObject.</para>
            <para>Each has certain benefits, typically performance versus quality. Using a framebuffer object avoids a costly upload of the image contents to the texture in graphics memory, while using an image enables high quality anti-aliasing.</para>
            <para>Warning: Resizing a framebuffer object is a costly operation, avoid using the QQuickPaintedItem::FramebufferObject render target if the item gets resized often.</para>
            <para>By default, the render target is QQuickPaintedItem::Image.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.IsTextureProvider">
            <summary>
            <para>Reimplemented from QQuickItem::isTextureProvider().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.TextureProvider">
            <summary>
            <para>Reimplemented from QQuickItem::textureProvider().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickPaintedItem.ContentsBoundingRect">
            <summary>
            <para>This function is provided for compatibility, use size in combination with textureSize to decide the size of what you are drawing.</para>
            <para>See also width(), height(), and textureSize().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickPaintedItem.RenderTarget">
            <summary>
            <para>This enum describes QQuickPaintedItem's render targets. The render target is the surface QPainter paints onto before the item is rendered on screen.</para>
            <para>See also setRenderTarget().</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickPaintedItem.RenderTarget.Image">
            <summary>The default; QPainter paints into a QImage using the raster paint engine. The image's content needs to be uploaded to graphics memory afterward, this operation can potentially be slow if the item is large. This render target allows high quality anti-aliasing and fast item resizing.</summary>
        </member>
        <member name="F:QtQuick.QQuickPaintedItem.RenderTarget.FramebufferObject">
            <summary>QPainter paints into a QOpenGLFramebufferObject using the GL paint engine. Painting can be faster as no texture upload is required, but anti-aliasing quality is not as good as if using an image. This render target allows faster rendering in some cases, but you should avoid using it if the item is resized often.</summary>
        </member>
        <member name="F:QtQuick.QQuickPaintedItem.RenderTarget.InvertedYFramebufferObject">
            <summary>Exactly as for FramebufferObject above, except once the painting is done, prior to rendering the painted image is flipped about the x-axis so that the top-most pixels are now at the bottom. Since this is done with the OpenGL texture coordinates it is a much faster way to achieve this effect than using a painter transform.</summary>
        </member>
        <member name="T:QtQuick.QQuickPaintedItem.PerformanceHint">
            <summary>
            <para>This enum describes flags that you can enable to improve rendering performance in QQuickPaintedItem. By default, none of these flags are set.</para>
            <para>The PerformanceHints type is a typedef for QFlags&lt;PerformanceHint&gt;. It stores an OR combination of PerformanceHint values.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickPaintedItem.PerformanceHint.FastFBOResizing">
            <summary>Resizing an FBO can be a costly operation on a few OpenGL driver implementations. To work around this, one can set this flag to let the QQuickPaintedItem allocate one large framebuffer object and instead draw into a subregion of it. This saves the resize at the cost of using more memory. Please note that this is not a common problem.</summary>
        </member>
        <member name="T:QtQuick.QQuickRenderControl">
            <summary>
            <para>The QQuickRenderControl class provides a mechanism for rendering the Qt Quick scenegraph onto an offscreen render target in a fully application-controlled manner.</para>
            </summary>
            <remarks>
            <para>QQuickWindow and QQuickView and their associated internal render loops render the Qt Quick scene onto a native window. In some cases, for example when integrating with 3rd party OpenGL renderers, it might be beneficial to get the scene into a texture that can then be used in arbitrary ways by the external rendering engine. QQuickRenderControl makes this possible in a hardware accelerated manner, unlike the performance-wise limited alternative of using QQuickWindow::grabWindow()</para>
            <para>When using a QQuickRenderControl, the QQuickWindow does not have to be shown or even created at all. This means there will not be an underlying native window for it. Instead, the QQuickWindow instance is associated with the render control, using the overload of the QQuickWindow constructor, and an OpenGL framebuffer object by calling QQuickWindow::setRenderTarget().</para>
            <para>Management of the context and framebuffer object is up to the application. The context that will be used by Qt Quick must be created before calling initialize(). The creation of the framebuffer object can be deferred, see below. Qt 5.4 introduces the ability for QOpenGLContext to adopt existing native contexts. Together with QQuickRenderControl this makes it possible to create a QOpenGLContext that shares with an external rendering engine's existing context. This new QOpenGLContext can then be used to render the Qt Quick scene into a texture that is accessible by the other engine's context too.</para>
            <para>Loading and instantiation of the QML components happen by using a QQmlEngine. Once the root object is created, it will need to be parented to the QQuickWindow's contentItem().</para>
            <para>Applications will usually have to connect to 4 important signals:</para>
            <para></para>
            <para>QQuickWindow::sceneGraphInitialized() Emitted at some point after calling QQuickRenderControl::initialize(). Upon this signal, the application is expected to create its framebuffer object and associate it with the QQuickWindow.</para>
            <para>QQuickWindow::sceneGraphInvalidated() When the scenegraph resources are released, the framebuffer object can be destroyed too.</para>
            <para>QQuickRenderControl::renderRequested() Indicates that the scene has to be rendered by calling render(). After making the context current, applications are expected to call render().</para>
            <para>QQuickRenderControl::sceneChanged() Indicates that the scene has changed meaning that, before rendering, polishing and synchronizing is also necessary.</para>
            <para></para>
            <para>To send events, for example mouse or keyboard events, to the scene, use QCoreApplication::sendEvent() with the QQuickWindow instance as the receiver.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QQuickRenderControl object, with parent object parent.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.PrepareThread(QtCore.QThread)">
            <summary>
            <para>Prepares rendering the Qt Quick scene outside the gui thread.</para>
            <para>targetThread specifies the thread on which synchronization and rendering will happen. There is no need to call this function in a single threaded scenario.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.Initialize(QtGui.QOpenGLContext)">
            <summary>
            <para>Initializes the scene graph resources. The context gl has to be the current context.</para>
            <para>Note: Qt Quick does not take ownership of the context. It is up to the application to destroy it after a call to invalidate() or after the QQuickRenderControl instance is destroyed.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.Invalidate">
            <summary>
            <para>Stop rendering and release resources. Requires a current context.</para>
            <para>This is the equivalent of the cleanup operations that happen with a real QQuickWindow when the window becomes hidden.</para>
            <para>This function is called from the destructor. Therefore there will typically be no need to call it directly. Pay attention however to the fact that this requires the context, that was passed to initialize(), to be the current one at the time of destroying the QQuickRenderControl instance.</para>
            <para>Once invalidate() has been called, it is possible to reuse the QQuickRenderControl instance by calling initialize() again.</para>
            <para>Note: This function does not take QQuickWindow::persistentSceneGraph() or QQuickWindow::persistentOpenGLContext() into account. This means that context-specific resources are always released.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.PolishItems">
            <summary>
            <para>This function should be called as late as possible before sync(). In a threaded scenario, rendering can happen in parallel with this function.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.Render">
            <summary>
            <para>Renders the scenegraph using the current context.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.RenderWindow(QtCore.QPoint)">
            <summary>
            <para>Reimplemented in subclasses to return the real window this render control is rendering into.</para>
            <para>If offset in non-null, it is set to the offset of the control inside the window.</para>
            <para>Note: While not mandatory, reimplementing this function becomes essential for supporting multiple screens with different device pixel ratios and properly positioning popup windows opened from QML. Therefore providing it in subclasses is highly recommended.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickRenderControl.RenderWindowFor(QtQuick.QQuickWindow,QtCore.QPoint)">
            <summary>
            <para>Returns the real window that win is being rendered to, if any.</para>
            <para>If offset in non-null, it is set to the offset of the rendering inside its window.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickRenderControl.RenderRequested">
            <summary>
            <para>This signal is emitted when the scene graph needs to be rendered. It is not necessary to call sync().</para>
            <para>Note: Avoid triggering rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickRenderControl.SceneChanged">
            <summary>
            <para>This signal is emitted when the scene graph is updated, meaning that polishItems() and sync() needs to be called. If sync() returns true, then render() needs to be called.</para>
            <para>Note: Avoid triggering polishing, synchronization and rendering directly when this signal is emitted. Instead, prefer deferring it by using a timer for example. This will lead to better performance.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickRenderControl.Sync">
            <summary>
            <para>This function is used to synchronize the QML scene with the rendering scene graph.</para>
            <para>If a dedicated render thread is used, the GUI thread should be blocked for the duration of this call.</para>
            <para>Returns true if the synchronization changed the scene graph.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickRenderControl.Grab">
            <summary>
            <para>Grabs the contents of the scene and returns it as an image.</para>
            <para>Note: Requires the context to be current.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickTextDocument">
            <summary>
            <para>The QQuickTextDocument class provides access to the QTextDocument of QQuickTextEdit</para>
            </summary>
            <remarks>
            <para>This class provides access to the QTextDocument of QQuickTextEdit elements. This is provided to allow usage of the Rich Text Processing functionalities of Qt. You are not allowed to modify the document, but it can be used to output content, for example with QTextDocumentWriter), or provide additional formatting, for example with QSyntaxHighlighter.</para>
            <para>The class has to be used from C++ directly, using the property of the TextEdit.</para>
            <para>Warning: The QTextDocument provided is used internally by Qt Quick elements to provide text manipulation primitives. You are not allowed to perform any modification of the internal state of the QTextDocument. If you do, the element in question may stop functioning or crash.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickTextDocument.#ctor(QtQuick.QQuickItem)">
            <summary>
            <para>Constructs a QQuickTextDocument object with parent as the parent object.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickTextDocument.TextDocument">
            <summary>
            <para>Returns a pointer to the QTextDocument object.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickWindow">
            <summary>
            <para>The QQuickWindow class provides the window for displaying a graphical QML scene</para>
            </summary>
            <remarks>
            <para>QQuickWindow provides the graphical scene management needed to interact with and display a scene of QQuickItems.</para>
            <para>A QQuickWindow always has a single invisible root item. To add items to this window, reparent the items to the root item or to an existing item in the scene.</para>
            <para>For easily displaying a scene from a QML file, see QQuickView.</para>
            <para></para>
            <para>Rendering</para>
            <para>QQuickWindow uses a scene graph on top of OpenGL to render. This scene graph is disconnected from the QML scene and potentially lives in another thread, depending on the platform implementation. Since the rendering scene graph lives independently from the QML scene, it can also be completely released without affecting the state of the QML scene.</para>
            <para>The sceneGraphInitialized() signal is emitted on the rendering thread before the QML scene is rendered to the screen for the first time. If the rendering scene graph has been released, the signal will be emitted again before the next frame is rendered.</para>
            <para></para>
            <para>Integration with OpenGL</para>
            <para>It is possible to integrate OpenGL calls directly into the QQuickWindow using the same OpenGL context as the Qt Quick Scene Graph. This is done by connecting to the QQuickWindow::beforeRendering() or QQuickWindow::afterRendering() signal.</para>
            <para>Note: When using QQuickWindow::beforeRendering(), make sure to disable clearing before rendering with QQuickWindow::setClearBeforeRendering().</para>
            <para></para>
            <para>Exposure and Visibility</para>
            <para>When a QQuickWindow instance is deliberately hidden with hide() or setVisible(false), it will stop rendering and its scene graph and OpenGL context might be released. The sceneGraphInvalidated() signal will be emitted when this happens.</para>
            <para>Warning: It is crucial that OpenGL operations and interaction with the scene graph happens exclusively on the rendering thread, primarily during the updatePaintNode() phase.</para>
            <para>Warning: As signals related to rendering might be emitted from the rendering thread, connections should be made using Qt::DirectConnection.</para>
            <para></para>
            <para>Resource Management</para>
            <para>QML will try to cache images and scene graph nodes to improve performance, but in some low-memory scenarios it might be required to aggressively release these resources. The releaseResources() can be used to force the clean up of certain resources. Calling releaseResources() may result in the entire scene graph and its OpenGL context being deleted. The sceneGraphInvalidated() signal will be emitted when this happens.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            <para></para>
            <para>Context and surface formats</para>
            <para>While it is possible to specify a QSurfaceFormat for every QQuickWindow by calling the member function setFormat(), windows may also be created from QML by using the Window and ApplicationWindow elements. In this case there is no C++ code involved in the creation of the window instance, yet applications may still wish to set certain surface format values, for example to request a given OpenGL version or profile. Such applications can call the static function QSurfaceFormat::setDefaultFormat() at startup. The specified format will be used for all Quick windows created afterwards.</para>
            <para></para>
            <para>See also Scene Graph - OpenGL Under QML.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickWindow.#ctor(QtGui.QWindow)">
            <summary>
            <para>Constructs a window for displaying a QML scene with parent window parent.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.SendEvent(QtQuick.QQuickItem,QtCore.QEvent)">
            <summary>
            <para>Propagates an event e to a QQuickItem item on the window.</para>
            <para>The return value is currently not used.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.SetRenderTarget(System.UInt32,QtCore.QSize)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the render target for this window to be an FBO with fboId and size.</para>
            <para>The specified FBO must be created in the context of the window or one that shares with it.</para>
            <para>Warning: This function can only be called from the thread doing the rendering.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.ResetOpenGLState">
            <summary>
            <para>Call this function to reset the OpenGL context its default state.</para>
            <para>The scene graph uses the OpenGL context and will both rely on and clobber its state. When mixing raw OpenGL commands with scene graph rendering, this function provides a convenient way of resetting the OpenGL context state back to its default values.</para>
            <para>This function does not touch state in the fixed-function pipeline.</para>
            <para>This function does not clear the color, depth and stencil buffers. Use QQuickWindow::setClearBeforeRendering to control clearing of the color buffer. The depth and stencil buffer might be clobbered by the scene graph renderer. Clear these manually on demand.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also QQuickWindow::beforeRendering().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.CreateTextureFromImage(QtGui.QImage)">
            <summary>
            <para>This is an overloaded function.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.CreateTextureFromImage(QtGui.QImage,QtQuick.QQuickWindow.CreateTextureOption)">
            <summary>
            <para>Creates a new QSGTexture from the supplied image. If the image has an alpha channel, the corresponding texture will have an alpha channel.</para>
            <para>The caller of the function is responsible for deleting the returned texture. The actual GL texture will be deleted when the texture object is deleted.</para>
            <para>When options contains TextureCanUseAtlas, the engine may put the image into a texture atlas. Textures in an atlas need to rely on QSGTexture::normalizedTextureSubRect() for their geometry and will not support QSGTexture::Repeat. Other values from CreateTextureOption are ignored.</para>
            <para>When options contains TextureIsOpaque, the engine will create an RGB texture which returns false for QSGTexture::hasAlphaChannel(). Opaque textures will in most cases be faster to render. When this flag is not set, the texture will have an alpha channel based on the image's format.</para>
            <para>When options contains TextureHasMipmaps, the engine will create a texture which can use mipmap filtering. Mipmapped textures can not be in an atlas.</para>
            <para>The returned texture will be using GL_TEXTURE_2D as texture target and GL_RGBA as internal format. Reimplement QSGTexture to create textures with different parameters.</para>
            <para>Warning: This function will return 0 if the scene graph has not yet been initialized.</para>
            <para>Warning: The returned texture is not memory managed by the scene graph and must be explicitly deleted by the caller on the rendering thread. This is achieved by deleting the texture from a QSGNode destructor or by using deleteLater() in the case where the texture already has affinity to the rendering thread.</para>
            <para>This function can be called from any thread.</para>
            <para>See also sceneGraphInitialized() and QSGTexture.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.CreateTextureFromId(System.UInt32,QtCore.QSize,QtQuick.QQuickWindow.CreateTextureOption)">
            <summary>
            <para>Creates a new QSGTexture object from an existing GL texture id and size.</para>
            <para>The caller of the function is responsible for deleting the returned texture.</para>
            <para>The returned texture will be using GL_TEXTURE_2D as texture target and assumes that internal format is GL_RGBA. Reimplement QSGTexture to create textures with different parameters.</para>
            <para>Use options to customize the texture attributes. The TextureUsesAtlas option is ignored.</para>
            <para>Warning: This function will return 0 if the scenegraph has not yet been initialized.</para>
            <para>See also sceneGraphInitialized() and QSGTexture.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.ScheduleRenderJob(QtCore.IQRunnable,QtQuick.QQuickWindow.RenderStage)">
            <summary>
            <para>Schedules job to run when the rendering of this window reaches the given stage.</para>
            <para>This is a convenience to the equivalent signals in QQuickWindow for &quot;one shot&quot; tasks.</para>
            <para>The window takes ownership over job and will delete it when the job is completed.</para>
            <para>If rendering is shut down before job has a chance to run, the job will be run and then deleted as part of the scene graph cleanup. If the window is never shown and no rendering happens before the QQuickWindow is destroyed, all pending jobs will be destroyed without their run() method being called.</para>
            <para>If the rendering is happening on a different thread, then the job will happen on the rendering thread.</para>
            <para>If stage is NoStage, job will be run at the earliest opportunity whenever the render thread is not busy rendering a frame. If there is no OpenGL context available or the window is not exposed at the time the job is either posted or handled, it is deleted without executing the run() method. If a non-threaded renderer is in use, the run() method of the job is executed synchronously. The OpenGL context is changed to the renderer context before executing a NoStage job.</para>
            <para>Note: This function does not trigger rendering; the jobs targeting any other stage than NoStage will be stored run until rendering is triggered elsewhere. To force the job to run earlier, call QQuickWindow::update();</para>
            <para>This function was introduced in  Qt 5.4.</para>
            <para>See also beforeRendering(), afterRendering(), beforeSynchronizing(), afterSynchronizing(), frameSwapped(), and sceneGraphInvalidated().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.Update">
            <summary>
            <para>Schedules the window to render another frame.</para>
            <para>Calling QQuickWindow::update() differs from QQuickItem::update() in that it always triggers a repaint, regardless of changes in the underlying scene graph or not.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.ReleaseResources">
            <summary>
            <para>This function tries to release redundant resources currently held by the QML scene.</para>
            <para>Calling this function might result in the scene graph and the OpenGL context used for rendering being released to release graphics memory. If this happens, the sceneGraphInvalidated() signal will be called, allowing users to clean up their own graphics resources. The setPersistentOpenGLContext() and setPersistentSceneGraph() functions can be used to prevent this from happening, if handling the cleanup is not feasible in the application, at the cost of higher memory usage.</para>
            <para>See also sceneGraphInvalidated(), setPersistentOpenGLContext(), and setPersistentSceneGraph().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnExposeEvent(QtGui.QExposeEvent)">
            <summary>
            <para>Reimplemented from QWindow::exposeEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnResizeEvent(QtGui.QResizeEvent)">
            <summary>
            <para>Reimplemented from QWindow::resizeEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnShowEvent(QtGui.QShowEvent)">
            <summary>
            <para>Reimplemented from QWindow::showEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnHideEvent(QtGui.QHideEvent)">
            <summary>
            <para>Reimplemented from QWindow::hideEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnFocusInEvent(QtGui.QFocusEvent)">
            <summary>
            <para>Reimplemented from QWindow::focusInEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnFocusOutEvent(QtGui.QFocusEvent)">
            <summary>
            <para>Reimplemented from QWindow::focusOutEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnEvent(QtCore.QEvent)">
            <summary>
            <para>Reimplemented from QWindow::event().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnKeyPressEvent(QtGui.QKeyEvent)">
            <summary>
            <para>Reimplemented from QWindow::keyPressEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnKeyReleaseEvent(QtGui.QKeyEvent)">
            <summary>
            <para>Reimplemented from QWindow::keyReleaseEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnMousePressEvent(QtGui.QMouseEvent)">
            <summary>
            <para>Reimplemented from QWindow::mousePressEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnMouseReleaseEvent(QtGui.QMouseEvent)">
            <summary>
            <para>Reimplemented from QWindow::mouseReleaseEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnMouseDoubleClickEvent(QtGui.QMouseEvent)">
            <summary>
            <para>Reimplemented from QWindow::mouseDoubleClickEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnMouseMoveEvent(QtGui.QMouseEvent)">
            <summary>
            <para>Reimplemented from QWindow::mouseMoveEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.OnWheelEvent(QtGui.QWheelEvent)">
            <summary>
            <para>Reimplemented from QWindow::wheelEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickWindow.SetDefaultAlphaBuffer(System.Boolean)">
            <summary>
            <para>useAlpha specifies whether to use alpha transparency on newly created windows.</para>
            <para>In any application which expects to create translucent windows, it's necessary to set this to true before creating the first QQuickWindow. The default value is false.</para>
            <para>This function was introduced in  Qt 5.1.</para>
            <para>See also hasDefaultAlphaBuffer().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.FrameSwapped">
            <summary>
            <para>This signal is emitted when the frame buffers have been swapped.</para>
            <para>This signal will be emitted from the scene graph rendering thread.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.OpenglContextCreated">
            <summary>
            <para>This signal is emitted on the gui thread when the OpenGL context for this window is created, before it is made current.</para>
            <para>Some implementations will share the same OpenGL context between multiple QQuickWindow instances. The openglContextCreated() signal will in this case only be emitted for the first window, when the OpenGL context is actually created.</para>
            <para>QQuickWindow::openglContext() will still return 0 for this window until after the QQuickWindow::sceneGraphInitialize() has been emitted.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.SceneGraphInitialized">
            <summary>
            <para>This signal is emitted when the scene graph has been initialized.</para>
            <para>This signal will be emitted from the scene graph rendering thread.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.SceneGraphInvalidated">
            <summary>
            <para>This signal is emitted when the scene graph has been invalidated.</para>
            <para>This signal implies that the opengl rendering context used has been invalidated and all user resources tied to that context should be released.</para>
            <para>The OpenGL context of this window will be bound when this function is called. The only exception is if the native OpenGL has been destroyed outside Qt's control, for instance through EGL_CONTEXT_LOST.</para>
            <para>This signal will be emitted from the scene graph rendering thread.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.BeforeSynchronizing">
            <summary>
            <para>This signal is emitted before the scene graph is synchronized with the QML state.</para>
            <para>This signal can be used to do any preparation required before calls to QQuickItem::updatePaintNode().</para>
            <para>The GL context used for rendering the scene graph will be bound at this point.</para>
            <para>Warning: This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see Qt::ConnectionType).</para>
            <para>Warning: Make very sure that a signal handler for beforeSynchronizing leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</para>
            <para>See also resetOpenGLState().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.AfterSynchronizing">
            <summary>
            <para>This signal is emitted after the scene graph is synchronized with the QML state.</para>
            <para>This signal can be used to do preparation required after calls to QQuickItem::updatePaintNode(), while the GUI thread is still locked.</para>
            <para>The GL context used for rendering the scene graph will be bound at this point.</para>
            <para>Warning: This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see Qt::ConnectionType).</para>
            <para>Warning: Make very sure that a signal handler for afterSynchronizing leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            <para>See also resetOpenGLState().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.BeforeRendering">
            <summary>
            <para>This signal is emitted before the scene starts rendering.</para>
            <para>Combined with the modes for clearing the background, this option can be used to paint using raw GL under QML content.</para>
            <para>The GL context used for rendering the scene graph will be bound at this point.</para>
            <para>Warning: This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see Qt::ConnectionType).</para>
            <para>Warning: Make very sure that a signal handler for beforeRendering leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</para>
            <para>See also resetOpenGLState().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.AfterRendering">
            <summary>
            <para>This signal is emitted after the scene has completed rendering, before swapbuffers is called.</para>
            <para>This signal can be used to paint using raw GL on top of QML content, or to do screen scraping of the current frame buffer.</para>
            <para>The GL context used for rendering the scene graph will be bound at this point.</para>
            <para>Warning: This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see Qt::ConnectionType).</para>
            <para>Warning: Make very sure that a signal handler for afterRendering() leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</para>
            <para>See also resetOpenGLState().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.AfterAnimating">
            <summary>
            <para>This signal is emitted on the gui thread before requesting the render thread to perform the synchronization of the scene graph.</para>
            <para>Unlike the other similar signals, this one is emitted on the gui thread instead of the render thread. It can be used to synchronize external animation systems with the QML content.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.SceneGraphAboutToStop">
            <summary>
            <para>This signal is emitted on the render thread when the scene graph is about to stop rendering. This happens usually because the window has been hidden.</para>
            <para>Applications may use this signal to release resources, but should be prepared to reinstantiated them again fast. The scene graph and the OpenGL context are not released at this time.</para>
            <para>Warning: This signal is emitted from the scene graph rendering thread. If your slot function needs to finish before execution continues, you must make sure that the connection is direct (see Qt::ConnectionType).</para>
            <para>Warning: Make very sure that a signal handler for sceneGraphAboutToStop() leaves the GL context in the same state as it was when the signal handler was entered. Failing to do so can result in the scene not rendering properly.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            <para>See also sceneGraphInvalidated() and resetOpenGLState().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.ColorChanged">
            <summary>
            <para>This property holds the color used to clear the OpenGL context.</para>
            <para>Setting the clear color has no effect when clearing is disabled. By default, the clear color is white.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QColor 	color() const</para>
            <para> void 	setColor(const QColor &amp;color)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	colorChanged(const QColor &amp;)</para>
            <para></para>
            <para>See also setClearBeforeRendering() and setDefaultAlphaBuffer().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.ActiveFocusItemChanged">
            <summary>
            <para>This property holds the item which currently has active focus or  if there is no item with active focus.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QQuickItem *	activeFocusItem() const</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	activeFocusItemChanged()</para>
            <para></para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickWindow.SceneGraphErrorSignal">
            <summary>
            <para>This signal is emitted when an error occurred during scene graph initialization.</para>
            <para>Applications should connect to this signal if they wish to handle errors, like OpenGL context creation failures, in a custom way. When no slot is connected to the signal, the behavior will be different: Quick will print the message, or show a message box, and terminate the application.</para>
            <para>This signal will be emitted from the gui thread.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.RenderTarget">
            <summary>
            <para>Returns the render target for this window.</para>
            <para>The default is to render to the surface of the window, in which case the render target is 0.</para>
            <para>See also setRenderTarget().</para>
            <para></para>
            <para>Sets the render target for this window to be fbo.</para>
            <para>The specified fbo must be created in the context of the window or one that shares with it.</para>
            <para>Warning: This function can only be called from the thread doing the rendering.</para>
            <para>See also renderTarget().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.ClearBeforeRendering">
            <summary>
            <para>Returns whether clearing of the color buffer is done before rendering or not.</para>
            <para>See also setClearBeforeRendering().</para>
            <para></para>
            <para>Sets whether the scene graph rendering of QML should clear the color buffer before it starts rendering to enabled.</para>
            <para>By disabling clearing of the color buffer, it is possible to do GL painting under the scene graph.</para>
            <para>The color buffer is cleared by default.</para>
            <para>See also clearBeforeRendering() and beforeRendering().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.Color">
            <summary>
            <para>This property holds the color used to clear the OpenGL context.</para>
            <para>Setting the clear color has no effect when clearing is disabled. By default, the clear color is white.</para>
            <para>See also setClearBeforeRendering() and setDefaultAlphaBuffer().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.PersistentOpenGLContext">
            <summary>
            <para>Returns whether the OpenGL context can be released during the lifetime of the QQuickWindow.</para>
            <para>Note: This is a hint. When and how this happens is implementation specific.</para>
            <para></para>
            <para>Sets whether the OpenGL context should be preserved, and cannot be released until the last window is deleted, to persistent. The default value is true.</para>
            <para>The OpenGL context can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</para>
            <para>The QOpenGLContext::aboutToBeDestroyed() signal is emitted from the QQuickWindow::openglContext() when the OpenGL context is about to be released. The QQuickWindow::sceneGraphInitialized() signal is emitted when a new OpenGL context is created for this window. Make a Qt::DirectConnection to these signals to be notified.</para>
            <para>The OpenGL context is still released when the last QQuickWindow is deleted.</para>
            <para>See also isPersistentOpenGLContext(), setPersistentSceneGraph(), QOpenGLContext::aboutToBeDestroyed(), and sceneGraphInitialized().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.PersistentSceneGraph">
            <summary>
            <para>Returns whether the scene graph nodes and resources can be released during the lifetime of this QQuickWindow.</para>
            <para>Note: This is a hint. When and how this happens is implementation specific.</para>
            <para></para>
            <para>Sets whether the scene graph nodes and resources can be released to persistent. The default value is true.</para>
            <para>The scene graph nodes and resources can be released to free up graphics resources when the window is obscured, hidden or not rendering. When this happens is implementation specific.</para>
            <para>The QQuickWindow::sceneGraphInvalidated() signal is emitted when cleanup occurs. The QQuickWindow::sceneGraphInitialized() signal is emitted when a new scene graph is recreated for this window. Make a Qt::DirectConnection to these signals to be notified.</para>
            <para>The scene graph nodes and resources are still released when the last QQuickWindow is deleted.</para>
            <para>See also isPersistentSceneGraph(), setPersistentOpenGLContext(), sceneGraphInvalidated(), and sceneGraphInitialized().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.AccessibleRoot">
            <summary>
            <para>Returns an accessibility interface for this window, or 0 if such an interface cannot be created.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.ContentItem">
            <summary>
            <para>This property holds the invisible root item of the scene.</para>
            <para>A QQuickWindow always has a single invisible root item containing all of its content. To add items to this window, reparent the items to the contentItem or to an existing item in the scene.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.ActiveFocusItem">
            <summary>
            <para>This property holds the item which currently has active focus or  if there is no item with active focus.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.MouseGrabberItem">
            <summary>
            <para>Returns the item which currently has the mouse grab.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.GrabWindow">
            <summary>
            <para>Grabs the contents of the window and returns it as an image.</para>
            <para>It is possible to call the grabWindow() function when the window is not visible. This requires that the window is created and has a valid size and that no other QQuickWindow instances are rendering in the same process.</para>
            <para>Warning: Calling this function will cause performance problems.</para>
            <para>Warning: This function can only be called from the GUI thread.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.RenderTargetId">
            <summary>
            <para>Returns the FBO id of the render target when set; otherwise returns 0.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.RenderTargetSize">
            <summary>
            <para>Returns the size of the currently set render target; otherwise returns an empty size.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.IncubationController">
            <summary>
            <para>Returns an incubation controller that splices incubation between frames for this window. QQuickView automatically installs this controller for you, otherwise you will need to install it yourself using QQmlEngine::setIncubationController().</para>
            <para>The controller is owned by the window and will be destroyed when the window is deleted.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.HasDefaultAlphaBuffer">
            <summary>
            <para>Returns whether to use alpha transparency on newly created windows.</para>
            <para>This function was introduced in  Qt 5.1.</para>
            <para>See also setDefaultAlphaBuffer().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.OpenglContext">
            <summary>
            <para>Returns the opengl context used for rendering.</para>
            <para>If the scene graph is not ready, this function will return 0.</para>
            <para>See also sceneGraphInitialized() and sceneGraphInvalidated().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.IsSceneGraphInitialized">
            <summary>
            <para>Returns true if the scene graph has been initialized; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickWindow.EffectiveDevicePixelRatio">
            <summary>
            <para>Returns the device pixel ratio for this window.</para>
            <para>This is different from QWindow::devicePixelRatio() in that it supports redirected rendering via QQuickRenderControl. When using a QQuickRenderControl, the QQuickWindow is often not created, meaning it is never shown and there is no underlying native window created in the windowing system. As a result, querying properties like the device pixel ratio cannot give correct results. Use this function instead.</para>
            <para>See also QWindow::devicePixelRatio().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickWindow.CreateTextureOption">
            <summary>
            <para>The CreateTextureOption enums are used to customize a texture is wrapped.</para>
            <para>The CreateTextureOptions type is a typedef for QFlags&lt;CreateTextureOption&gt;. It stores an OR combination of CreateTextureOption values.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.CreateTextureOption.TextureHasAlphaChannel">
            <summary>The texture has an alpha channel and should be drawn using blending.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.CreateTextureOption.TextureHasMipmaps">
            <summary>The texture has mipmaps and can be drawn with mipmapping enabled.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.CreateTextureOption.TextureOwnsGLTexture">
            <summary>The texture object owns the texture id and will delete the GL texture when the texture object is deleted.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.CreateTextureOption.TextureCanUseAtlas">
            <summary>The image can be uploaded into a texture atlas.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.CreateTextureOption.TextureIsOpaque">
            <summary>The texture will return false for QSGTexture::hasAlphaChannel() and will not be blended. This flag was added in Qt 5.6.</summary>
        </member>
        <member name="T:QtQuick.QQuickWindow.RenderStage">
            <summary>
            <para>This enum was introduced or modified in  Qt 5.4.</para>
            <para>See also Scene Graph and Rendering.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.RenderStage.BeforeSynchronizingStage">
            <summary>Before synchronization.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.RenderStage.AfterSynchronizingStage">
            <summary>After synchronization.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.RenderStage.BeforeRenderingStage">
            <summary>Before rendering.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.RenderStage.AfterRenderingStage">
            <summary>After rendering.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.RenderStage.AfterSwapStage">
            <summary>After the frame is swapped.</summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.RenderStage.NoStage">
            <summary>As soon as possible. This value was added in Qt 5.6.</summary>
        </member>
        <member name="T:QtQuick.QQuickWindow.SceneGraphError">
            <summary>
            <para>This enum describes the error in a sceneGraphError() signal.</para>
            <para>This enum was introduced or modified in  Qt 5.3.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickWindow.SceneGraphError.ContextNotAvailable">
            <summary>OpenGL context creation failed. This typically means that no suitable OpenGL implementation was found, for example because no graphics drivers are installed and so no OpenGL 2 support is present. On mobile and embedded boards that use OpenGL ES such an error is likely to indicate issues in the windowing system integration and possibly an incorrect configuration of Qt.</summary>
        </member>
        <member name="T:QtQuick.QQuickView">
            <summary>
            <para>The QQuickView class provides a window for displaying a Qt Quick user interface.</para>
            </summary>
            <remarks>
            <para>This is a convenience subclass of QQuickWindow which will automatically load and display a QML scene when given the URL of the main source file. Alternatively, you can instantiate your own objects using QQmlComponent and place them in a manually setup QQuickWindow.</para>
            <para>Typical usage:</para>
            <para></para>
            <para></para>
            <para>  QQuickView *view = new QQuickView;</para>
            <para>  view-&gt;setSource(QUrl::fromLocalFile(&quot;myqmlfile.qml&quot;));</para>
            <para>  view-&gt;show();</para>
            <para></para>
            <para></para>
            <para>To receive errors related to loading and executing QML with QQuickView, you can connect to the statusChanged() signal and monitor for QQuickView::Error. The errors are available via QQuickView::errors().</para>
            <para>QQuickView also manages sizing of the view and root object. By default, the resizeMode is SizeViewToRootObject, which will load the component and resize it to the size of the view. Alternatively the resizeMode may be set to SizeRootObjectToView which will resize the view to the size of the root object.</para>
            <para></para>
            <para>See also Exposing Attributes of C++ Types to QML and QQuickWidget.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickView.#ctor(QtGui.QWindow)">
            <summary>
            <para>Constructs a QQuickView with the given parent. The default value of parent is 0.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickView.#ctor(QtQml.QQmlEngine,QtGui.QWindow)">
            <summary>
            <para>Constructs a QQuickView with the given QML engine and parent.</para>
            <para>Note: In this case, the QQuickView does not own the given engine object; it is the caller's responsibility to destroy the engine. If the engine is deleted before the view, status() will return QQuickView::Error.</para>
            <para>See also Status, status(), and errors().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickView.#ctor(QtCore.QUrl,QtGui.QWindow)">
            <summary>
            <para>Constructs a QQuickView with the given QML source and parent. The default value of parent is 0.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickView.OnKeyPressEvent(QtGui.QKeyEvent)">
            <summary>
            <para>Reimplemented from QWindow::keyPressEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickView.OnKeyReleaseEvent(QtGui.QKeyEvent)">
            <summary>
            <para>Reimplemented from QWindow::keyReleaseEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickView.OnMousePressEvent(QtGui.QMouseEvent)">
            <summary>
            <para>Reimplemented from QWindow::mousePressEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickView.OnMouseReleaseEvent(QtGui.QMouseEvent)">
            <summary>
            <para>Reimplemented from QWindow::mouseReleaseEvent().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickView.OnMouseMoveEvent(QtGui.QMouseEvent)">
            <summary>
            <para>Reimplemented from QWindow::mouseMoveEvent().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickView.StatusChanged">
            <summary>
            <para>This signal is emitted when the component's current status changes.</para>
            <para>Note: Notifier signal for property status. </para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickView.resizeMode">
            <summary>
            <para>This property holds whether the view should resize the window contents.</para>
            <para>If this property is set to SizeViewToRootObject (the default), the view resizes to the size of the root item in the QML.</para>
            <para>If this property is set to SizeRootObjectToView, the view will automatically resize the root item to the size of the view.</para>
            <para>See also initialSize().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickView.Source">
            <summary>
            <para>This property holds the URL of the source of the QML component.</para>
            <para>Ensure that the URL provided is full and correct, in particular, use QUrl::fromLocalFile() when loading a file from the local filesystem.</para>
            <para>Note that setting a source URL will result in the QML component being instantiated, even if the URL is unchanged from the current value.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickView.Engine">
            <summary>
            <para>Returns a pointer to the QQmlEngine used for instantiating QML Components.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickView.RootContext">
            <summary>
            <para>This function returns the root of the context hierarchy. Each QML component is instantiated in a QQmlContext. QQmlContext's are essential for passing data to QML components. In QML, contexts are arranged hierarchically and this hierarchy is managed by the QQmlEngine.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickView.RootObject">
            <summary>
            <para>Returns the view's root item.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickView.status">
            <summary>
            <para>The component's current status.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickView.InitialSize">
            <summary>
            <para>Returns the initial size of the root object.</para>
            <para>If resizeMode is QQuickItem::SizeRootObjectToView the root object will be resized to the size of the view. initialSize contains the size of the root object before it was resized.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickView.ResizeMode">
            <summary>
            <para>This enum specifies how to resize the view.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickView.ResizeMode.SizeViewToRootObject">
            <summary>The view resizes with the root item in the QML.</summary>
        </member>
        <member name="F:QtQuick.QQuickView.ResizeMode.SizeRootObjectToView">
            <summary>The view will automatically resize the root item to the size of the view.</summary>
        </member>
        <member name="T:QtQuick.QQuickView.Status">
            <summary>
            <para>Specifies the loading status of the QQuickView.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QQuickView.Status.Null">
            <summary>This QQuickView has no source set.</summary>
        </member>
        <member name="F:QtQuick.QQuickView.Status.Ready">
            <summary>This QQuickView has loaded and created the QML component.</summary>
        </member>
        <member name="F:QtQuick.QQuickView.Status.Loading">
            <summary>This QQuickView is loading network data.</summary>
        </member>
        <member name="F:QtQuick.QQuickView.Status.Error">
            <summary>One or more errors has occurred. Call errors() to retrieve a list of errors.</summary>
        </member>
        <member name="T:QtQuick.QQuickTextureFactory">
            <summary>
            <para>The QQuickTextureFactory class provides an interface for loading custom textures from QML.</para>
            </summary>
            <remarks>
            <para>The purpose of the texture factory is to provide a placeholder for a image data that can be converted into an OpenGL texture.</para>
            <para>Creating a texture directly is not possible as there is rarely an OpenGL context available in the thread that is responsible for loading the image data.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickTextureFactory.#ctor">
            <summary>
            <para>Constructs a texture factory. Since QQuickTextureFactory is abstract, it cannot be instantiated directly.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickTextureFactory.CreateTexture(QtQuick.QQuickWindow)">
            <summary>
            <para>This function is called on the scene graph rendering thread to create a QSGTexture instance from the factory. window provides the context which this texture is created in.</para>
            <para>QML will internally cache the returned texture as needed. Each call to this function should return a unique instance.</para>
            <para>The OpenGL context used for rendering is bound when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickTextureFactory.TextureFactoryForImage(QtGui.QImage)">
            <summary>
            <para>Returns a QQuickTextureFactory holding the given image.</para>
            <para>This is typically used as a helper in QQuickImageResponse::textureFactory.</para>
            <para>This function was introduced in  Qt 5.6.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickTextureFactory.TextureSize">
            <summary>
            <para>Returns the size of the texture. This function will be called from arbitrary threads and should not rely on an OpenGL context bound.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickTextureFactory.TextureByteCount">
            <summary>
            <para>Returns the number of bytes of memory the texture consumes.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickTextureFactory.Image">
            <summary>
            <para>Returns an image version of this texture.</para>
            <para>The lifespan of the returned image is unknown, so the implementation should return a self contained QImage, not make use of the QImage(uchar *, ...) constructor.</para>
            <para>This function is not commonly used and is expected to be slow.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickImageResponse">
            <summary>
            <para>The QQuickImageResponse class provides an interface for asynchronous image loading in QQuickAsyncImageProvider.</para>
            </summary>
            <remarks>
            <para>The purpose of an image response is to provide a way for image provider jobs to be executed in an asynchronous way.</para>
            <para>Responses are deleted via deleteLater once the finished() signal has been emitted. If you are using QRunnable as base for your QQuickImageResponse ensure automatic deletion is disabled.</para>
            <para></para>
            <para>See also QQuickImageProvider.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickImageResponse.#ctor">
            <summary>
            <para>Constructs the image response</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickImageResponse.Cancel">
            <summary>
            <para>This method is used to communicate that the response is no longer required by the engine.</para>
            <para>It may be reimplemented to cancel a request in the provider side, however, it is not mandatory.</para>
            </summary>
        </member>
        <member name="E:QtQuick.QQuickImageResponse.Finished">
            <summary>
            <para>Signals that the job execution has finished (be it successfully, because an error happened or because it was cancelled).</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickImageResponse.TextureFactory">
            <summary>
            <para>Returns the texture factory for the job. You can use QQuickTextureFactory::textureFactoryForImage if your provider works with QImage. The engine takes ownership of the returned QQuickTextureFactory.</para>
            <para>Note: This method will be called only when needed. For example, it may not be called if there is an error or the job is cancelled. Therefore, allocate the QQuickTextureFactory instance only in this method or otherwise ensure its deletion.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickImageResponse.ErrorString">
            <summary>
            <para>Returns the error string for the job execution. An empty string means no error.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickImageProvider">
            <summary>
            <para>The QQuickImageProvider class provides an interface for supporting pixmaps and threaded image requests in QML.</para>
            </summary>
            <remarks>
            <para>QQuickImageProvider is used to provide advanced image loading features in QML applications. It allows images in QML to be:</para>
            <para></para>
            <para>Loaded using QPixmaps rather than actual image files</para>
            <para>Loaded asynchronously in a separate thread</para>
            <para></para>
            <para>To specify that an image should be loaded by an image provider, use the &quot;image:&quot; scheme for the URL source of the image, followed by the identifiers of the image provider and the requested image. For example:</para>
            <para></para>
            <para></para>
            <para>  Image { source: &quot;image://myimageprovider/image.png&quot; }</para>
            <para></para>
            <para></para>
            <para>This specifies that the image should be loaded by the image provider named &quot;myimageprovider&quot;, and the image to be loaded is named &quot;image.png&quot;. The QML engine invokes the appropriate image provider according to the providers that have been registered through QQmlEngine::addImageProvider().</para>
            <para>Note that the identifiers are case-insensitive, but the rest of the URL will be passed on with preserved case. For example, the below snippet would still specify that the image is loaded by the image provider named &quot;myimageprovider&quot;, but it would request a different image than the above snippet (&quot;Image.png&quot; instead of &quot;image.png&quot;).</para>
            <para></para>
            <para></para>
            <para>  Image { source: &quot;image://MyImageProvider/Image.png&quot; }</para>
            <para></para>
            <para></para>
            <para>If you want the rest of the URL to be case insensitive, you will have to take care of that yourself inside your image provider.</para>
            <para></para>
            <para>An example</para>
            <para>Here are two images. Their source values indicate they should be loaded by an image provider named &quot;colors&quot;, and the images to be loaded are &quot;yellow&quot; and &quot;red&quot;, respectively:</para>
            <para></para>
            <para></para>
            <para>  Column {</para>
            <para>      Image { source: &quot;image://colors/yellow&quot; }</para>
            <para>      Image { source: &quot;image://colors/red&quot; }</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>When these images are loaded by QML, it looks for a matching image provider and calls its requestImage() or requestPixmap() method (depending on its imageType()) to load the image. The method is called with the id parameter set to &quot;yellow&quot; for the first image, and &quot;red&quot; for the second.</para>
            <para>Here is an image provider implementation that can load the images requested by the above QML. This implementation dynamically generates QPixmap images that are filled with the requested color:</para>
            <para></para>
            <para></para>
            <para>  class ColorImageProvider : public QQuickImageProvider</para>
            <para>  {</para>
            <para>  public:</para>
            <para>      ColorImageProvider()</para>
            <para>          : QQuickImageProvider(QQuickImageProvider::Pixmap)</para>
            <para>      {</para>
            <para>      }</para>
            <para></para>
            <para>      QPixmap requestPixmap(const QString &amp;id, QSize *size, const QSize &amp;requestedSize)</para>
            <para>      {</para>
            <para>          int width = 100;</para>
            <para>          int height = 50;</para>
            <para></para>
            <para>          if (size)</para>
            <para>              *size = QSize(width, height);</para>
            <para>          QPixmap pixmap(requestedSize.width() &gt; 0 ? requestedSize.width() : width,</para>
            <para>                         requestedSize.height() &gt; 0 ? requestedSize.height() : height);</para>
            <para>          pixmap.fill(QColor(id).rgba());</para>
            <para></para>
            <para>          return pixmap;</para>
            <para>      }</para>
            <para>  };</para>
            <para></para>
            <para></para>
            <para>To make this provider accessible to QML, it is registered with the QML engine with a &quot;colors&quot; identifier:</para>
            <para></para>
            <para></para>
            <para>  int main(int argc, char *argv[])</para>
            <para>  {</para>
            <para>      ...</para>
            <para></para>
            <para>      QQuickView view;</para>
            <para>      QQmlEngine *engine = view.engine();</para>
            <para>      engine-&gt;addImageProvider(QLatin1String(&quot;colors&quot;), new ColorPixmapProvider);</para>
            <para></para>
            <para>      ...</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Now the images can be successfully loaded in QML:</para>
            <para></para>
            <para>See the Image Provider Example for the complete implementation. Note that the example registers the provider via a plugin instead of registering it in the application main() function as shown above.</para>
            <para></para>
            <para>Asynchronous image loading</para>
            <para>Image providers that support QImage or Texture loading automatically include support for asychronous loading of images. To enable asynchronous loading for an image source, set the asynchronous property to true for the relevant Image, BorderImage or AnimatedImage object. When this is enabled, the image request to the provider is run in a low priority thread, allowing image loading to be executed in the background, and reducing the performance impact on the user interface.</para>
            <para>To force asynchronous image loading, even for image sources that do not have the asynchronous property set to true, you may pass the QQmlImageProviderBase::ForceAsynchronousImageLoading flag to the image provider constructor. This ensures that all image requests for the provider are handled in a separate thread.</para>
            <para>Asynchronous loading for image providers that provide QPixmap is only supported in platforms that have the ThreadedPixmaps feature, in platforms where pixmaps can only be created in the main thread (i.e. ThreadedPixmaps is not supported) if asynchronous is set to true, the value is ignored and the image is loaded synchronously.</para>
            <para>Asynchronous image loading for providers of type other than ImageResponse are executed on a single thread per engine basis. That means that a slow image provider will block the loading of any other request. To avoid that we suggest using QQuickAsyncImageProvider and implement threading on the provider side via a QThreadPool or similar. See the Image Response Provider Example for a complete implementation.</para>
            <para></para>
            <para>Image caching</para>
            <para>Images returned by a QQuickImageProvider are automatically cached, similar to any image loaded by the QML engine. When an image with a &quot;image://&quot; prefix is loaded from cache, requestImage() and requestPixmap() will not be called for the relevant image provider. If an image should always be fetched from the image provider, and should not be cached at all, set the cache property to false for the relevant Image, BorderImage or AnimatedImage object.</para>
            <para>The Qt Quick 1 version of this class is named QDeclarativeImageProvider.</para>
            <para></para>
            <para>See also QQmlEngine::addImageProvider().</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickImageProvider.#ctor(QtQml.QQmlImageProviderBase.ImageType,QtQml.QQmlImageProviderBase.Flag)">
            <summary>
            <para>Creates an image provider that will provide images of the given type and behave according to the given flags.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickImageProvider.RequestImage(System.String,QtCore.QSize,QtCore.QSize)">
            <summary>
            <para>Implement this method to return the image with id. The default implementation returns an empty image.</para>
            <para>The id is the requested image source, with the &quot;image:&quot; scheme and provider identifier removed. For example, if the image source was &quot;image://myprovider/icons/home&quot;, the given id would be &quot;icons/home&quot;.</para>
            <para>The requestedSize corresponds to the Image::sourceSize requested by an Image item. If requestedSize is a valid size, the image returned should be of that size.</para>
            <para>In all cases, size must be set to the original size of the image. This is used to set the width and height of the relevant Image if these values have not been set explicitly.</para>
            <para>Note: this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickImageProvider.RequestPixmap(System.String,QtCore.QSize,QtCore.QSize)">
            <summary>
            <para>Implement this method to return the pixmap with id. The default implementation returns an empty pixmap.</para>
            <para>The id is the requested image source, with the &quot;image:&quot; scheme and provider identifier removed. For example, if the image source was &quot;image://myprovider/icons/home&quot;, the given id would be &quot;icons/home&quot;.</para>
            <para>The requestedSize corresponds to the Image::sourceSize requested by an Image item. If requestedSize is a valid size, the image returned should be of that size.</para>
            <para>In all cases, size must be set to the original size of the image. This is used to set the width and height of the relevant Image if these values have not been set explicitly.</para>
            <para>Note: this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickImageProvider.RequestTexture(System.String,QtCore.QSize,QtCore.QSize)">
            <summary>
            <para>Implement this method to return the texture with id. The default implementation returns 0.</para>
            <para>The id is the requested image source, with the &quot;image:&quot; scheme and provider identifier removed. For example, if the image source was &quot;image://myprovider/icons/home&quot;, the given id would be &quot;icons/home&quot;.</para>
            <para>The requestedSize corresponds to the Image::sourceSize requested by an Image item. If requestedSize is a valid size, the image returned should be of that size.</para>
            <para>In all cases, size must be set to the original size of the image. This is used to set the width and height of the relevant Image if these values have not been set explicitly.</para>
            <para>Note: this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickImageProvider.imageType">
            <summary>
            <para>Reimplemented from QQmlImageProviderBase::imageType().</para>
            <para>Returns the image type supported by this provider.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QQuickImageProvider.Flags">
            <summary>
            <para>Reimplemented from QQmlImageProviderBase::flags().</para>
            <para>Returns the flags set for this provider.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QQuickAsyncImageProvider">
            <summary>
            <para>The QQuickAsyncImageProvider class provides an interface for for asynchronous control of QML image requests.</para>
            </summary>
            <remarks>
            <para>See also QQuickImageProvider.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QQuickAsyncImageProvider.#ctor">
            <summary>
            <para>Default constructs an instance of QQuickAsyncImageProvider.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QQuickAsyncImageProvider.RequestImageResponse(System.String,QtCore.QSize)">
            <summary>
            <para>Implement this method to return the job that will provide the texture with id.</para>
            <para>The id is the requested image source, with the &quot;image:&quot; scheme and provider identifier removed. For example, if the image source was &quot;image://myprovider/icons/home&quot;, the given id would be &quot;icons/home&quot;.</para>
            <para>The requestedSize corresponds to the Image::sourceSize requested by an Image item. If requestedSize is a valid size, the image returned should be of that size.</para>
            <para>Note: this method may be called by multiple threads, so ensure the implementation of this method is reentrant.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGGeometry">
            <summary>
            <para>The QSGGeometry class provides low-level storage for graphics primitives in the Qt Quick Scene Graph.</para>
            </summary>
            <remarks>
            <para>The QSGGeometry class stores the geometry of the primitives rendered with the scene graph. It contains vertex data and optionally index data. The mode used to draw the geometry is specified with setDrawingMode(), which maps directly to the OpenGL drawing mode, such as GL_TRIANGLE_STRIP, GL_TRIANGLES, or GL_POINTS.</para>
            <para>Vertices can be as simple as points defined by x and y values or can be more complex where each vertex contains a normal, texture coordinates and a 3D position. The QSGGeometry::AttributeSet is used to describe how the vertex data is built up. The attribute set can only be specified on construction. The QSGGeometry class provides a few convenience attributes and attribute sets by default. The defaultAttributes_Point2D() function returns an attribute set to be used in normal solid color rectangles, while the defaultAttributes_TexturedPoint2D function returns attributes to be used for textured 2D geometry. The vertex data is internally stored as a void * and is accessible with the vertexData() function. Convenience accessors for the common attribute sets are available with vertexDataAsPoint2D() and vertexDataAsTexturedPoint2D(). Vertex data is allocated by passing a vertex count to the constructor or by calling allocate() later.</para>
            <para>The QSGGeometry can optionally contain indices of either unsigned 32-bit, unsigned 16-bit, or unsigned 8-bit integers. The index type must be specified during construction and cannot be changed.</para>
            <para>Below is a snippet illustrating how a geometry composed of position and color vertices can be built.</para>
            <para></para>
            <para></para>
            <para>  struct MyPoint2D {</para>
            <para>      float x;</para>
            <para>      float y;</para>
            <para>      float r;</para>
            <para>      float g;</para>
            <para>      float b;</para>
            <para>      float a;</para>
            <para></para>
            <para>      void set(float x_, float y_, float r_, float g_, float b_, float a_) {</para>
            <para>          x = x_;</para>
            <para>          y = y_;</para>
            <para>          r = r_;</para>
            <para>          g = g_;</para>
            <para>          b = b_;</para>
            <para>          a = a_;</para>
            <para>      }</para>
            <para>  };</para>
            <para></para>
            <para>  QSGGeometry::Attribute MyPoint2D_Attributes[] = {</para>
            <para>      QSGGeometry::Attribute::create(0, 2, GL_FLOAT, true),</para>
            <para>      QSGGeometry::Attribute::create(1, 4, GL_FLOAT, false)</para>
            <para>  };</para>
            <para></para>
            <para>  QSGGeometry::AttributeSet MyPoint2D_AttributeSet = {</para>
            <para>      2,</para>
            <para>      sizeof(MyPoint2D),</para>
            <para>      MyPoint2D_Attributes</para>
            <para>  };</para>
            <para></para>
            <para>  ...</para>
            <para></para>
            <para>  geometry = new QSGGeometry(MyPoint2D_AttributeSet, 2);</para>
            <para>  geometry-&gt;setDrawingMode(GL_LINES);</para>
            <para></para>
            <para>  MyPoint2D *vertices = static_cast&lt;MyPoint2D *&gt;(geometry-&gt;vertexData());</para>
            <para>  vertices[0].set(0, 0, 1, 0, 0, 1);</para>
            <para>  vertices[1].set(width(), height(), 0, 0, 1, 1);</para>
            <para></para>
            <para></para>
            <para>The QSGGeometry is a software buffer and client-side in terms of OpenGL rendering, as the buffers used in 2D graphics typically consist of many small buffers that change every frame and do not benefit from being uploaded to graphics memory. However, the QSGGeometry supports hinting to the renderer that a buffer should be uploaded using the setVertexDataPattern() and setIndexDataPattern() functions. Whether this hint is respected or not is implementation specific.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            <para></para>
            <para>See also QSGGeometryNode and Scene Graph - Custom Geometry.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGGeometry.#ctor(QtQuick.QSGGeometry.AttributeSet,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Constructs a geometry object based on attributes.</para>
            <para>The object allocate space for vertexCount vertices based on the accumulated size in attributes and for indexCount.</para>
            <para>The indexType maps to the OpenGL index type and can be GL_UNSIGNED_SHORT and GL_UNSIGNED_BYTE. On OpenGL implementations that support it, such as desktop OpenGL, GL_UNSIGNED_INT can also be used.</para>
            <para>Geometry objects are constructed with GL_TRIANGLE_STRIP as default drawing mode.</para>
            <para>The attribute structure is assumed to be POD and the geometry object assumes this will not go away. There is no memory management involved.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.Allocate(System.Int32,System.Int32)">
            <summary>
            <para>Resizes the vertex and index data of this geometry object to fit vertexCount vertices and indexCount indices.</para>
            <para>Vertex and index data will be invalidated after this call and the caller must mark the associated geometry node as dirty, by calling node-&gt;markDirty(QSGNode::DirtyGeometry) to ensure that the renderer has a chance to update internal buffers.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.MarkIndexDataDirty">
            <summary>
            <para>Mark that the vertices in this geometry has changed and must be uploaded again.</para>
            <para>This function only has an effect when the usage pattern for vertices is StaticData and the renderer that renders this geometry uploads the geometry into Vertex Buffer Objects (VBOs).</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.MarkVertexDataDirty">
            <summary>
            <para>Mark that the vertices in this geometry has changed and must be uploaded again.</para>
            <para>This function only has an effect when the usage pattern for vertices is StaticData and the renderer that renders this geometry uploads the geometry into Vertex Buffer Objects (VBOs).</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.UpdateRectGeometry(QtQuick.QSGGeometry,QtCore.QRectF)">
            <summary>
            <para>Updates the geometry g with the coordinates in rect.</para>
            <para>The function assumes the geometry object contains a single triangle strip of QSGGeometry::Point2D vertices</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.UpdateTexturedRectGeometry(QtQuick.QSGGeometry,QtCore.QRectF,QtCore.QRectF)">
            <summary>
            <para>Updates the geometry g with the coordinates in rect and texture coordinates from textureRect.</para>
            <para>textureRect should be in normalized coordinates.</para>
            <para>g is assumed to be a triangle strip of four vertices of type QSGGeometry::TexturedPoint2D.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.DrawingMode">
            <summary>
            <para>Returns the drawing mode of this geometry.</para>
            <para>The default value is GL_TRIANGLE_STRIP.</para>
            <para>See also setDrawingMode().</para>
            <para></para>
            <para>Sets the mode to be used for drawing this geometry.</para>
            <para>The default value is GL_TRIANGLE_STRIP.</para>
            <para>See also drawingMode().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.IndexDataPattern">
            <summary>
            <para>Returns the usage pattern for indices in this geometry. The default pattern is AlwaysUploadPattern.</para>
            <para>See also setIndexDataPattern().</para>
            <para></para>
            <para>Sets the usage pattern for indices to p.</para>
            <para>The default is AlwaysUploadPattern. When set to anything other than the default, the user must call markIndexDataDirty() after changing the index data, in addition to calling QSGNode::markDirty() with QSGNode::DirtyGeometry.</para>
            <para>See also indexDataPattern().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.VertexDataPattern">
            <summary>
            <para>Returns the usage pattern for vertices in this geometry. The default pattern is AlwaysUploadPattern.</para>
            <para>See also setVertexDataPattern().</para>
            <para></para>
            <para>Sets the usage pattern for vertices to p.</para>
            <para>The default is AlwaysUploadPattern. When set to anything other than the default, the user must call markVertexDataDirty() after changing the vertex data, in addition to calling QSGNode::markDirty() with QSGNode::DirtyGeometry.</para>
            <para>See also vertexDataPattern().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.LineWidth">
            <summary>
            <para>Gets the current line or point width or to be used for this geometry. This property only applies to line width when the drawingMode is GL_LINES, GL_LINE_STRIP, or GL_LINE_LOOP. For desktop OpenGL, it also applies to point size when the drawingMode is GL_POINTS.</para>
            <para>The default value is 1.0</para>
            <para>See also setLineWidth() and drawingMode().</para>
            <para></para>
            <para>Sets the line or point width to be used for this geometry to width. This property only applies to line width when the drawingMode is GL_LINES, GL_LINE_STRIP, or GL_LINE_LOOP. For Desktop OpenGL, it also applies to point size when the drawingMode is GL_POINTS.</para>
            <para>Note: How line width and point size are treated is implementation dependent: The application should not rely on these, but rather create triangles or similar to draw areas. On OpenGL ES, line width support is limited and point size is unsupported.</para>
            <para>See also lineWidth() and drawingMode().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.DefaultAttributes_Point2D">
            <summary>
            <para>Convenience function which returns attributes to be used for 2D solid color drawing.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.DefaultAttributes_TexturedPoint2D">
            <summary>
            <para>Convenience function which returns attributes to be used for textured 2D drawing.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.DefaultAttributes_ColoredPoint2D">
            <summary>
            <para>Convenience function which returns attributes to be used for per vertex colored 2D drawing.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.VertexCount">
            <summary>
            <para>Returns the number of vertices in this geometry object.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.VertexData">
            <summary>
            <para>Returns a pointer to the raw vertex data of this geometry object.</para>
            <para>See also vertexDataAsPoint2D() and vertexDataAsTexturedPoint2D().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.VertexDataAsPoint2D">
            <summary>
            <para>Convenience function to access the vertex data as a mutable array of QSGGeometry::Point2D.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.VertexDataAsTexturedPoint2D">
            <summary>
            <para>Convenience function to access the vertex data as a mutable array of QSGGeometry::TexturedPoint2D.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.VertexDataAsColoredPoint2D">
            <summary>
            <para>Convenience function to access the vertex data as a mutable array of QSGGeometry::ColoredPoint2D.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.IndexType">
            <summary>
            <para>Returns the primitive type used for indices in this geometry object.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.IndexCount">
            <summary>
            <para>Returns the number of indices in this geometry object.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.IndexData">
            <summary>
            <para>Returns a pointer to the raw index data of this geometry object.</para>
            <para>See also indexDataAsUShort() and indexDataAsUInt().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.IndexDataAsUInt">
            <summary>
            <para>Convenience function to access the index data as a mutable array of 32-bit unsigned integers.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.IndexDataAsUShort">
            <summary>
            <para>Convenience function to access the index data as a mutable array of 16-bit unsigned integers.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.SizeOfIndex">
            <summary>
            <para>Returns the byte size of the index type.</para>
            <para>This value is either 1 when index type is GL_UNSIGNED_BYTE or 2 when index type is GL_UNSIGNED_SHORT. For Desktop OpenGL, GL_UNSIGNED_INT with the value 4 is also supported.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.AttributeCount">
            <summary>
            <para>Returns the number of attributes in the attrbute set used by this geometry.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.Attributes">
            <summary>
            <para>Returns an array with the attributes of this geometry. The size of the array is given with attributeCount().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometry.SizeOfVertex">
            <summary>
            <para>Returns the size in bytes of one vertex.</para>
            <para>This value comes from the attributes.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGGeometry.DataPattern">
            <summary>
            <para>The DataPattern enum is used to specify the use pattern for the vertex and index data in a geometry object.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGGeometry.DataPattern.AlwaysUploadPattern">
            <summary>The data is always uploaded. This means that the user does not need to explicitly mark index and vertex data as dirty after changing it. This is the default.</summary>
        </member>
        <member name="F:QtQuick.QSGGeometry.DataPattern.StreamPattern">
            <summary>The data is modified for almost every time it is drawn. This is a hint that may provide better performance. When set, the user must make sure to mark the data as dirty after changing it.</summary>
        </member>
        <member name="F:QtQuick.QSGGeometry.DataPattern.DynamicPattern">
            <summary>The data is modified repeatedly and drawn many times. This is a hint that may provide better performance. When set the user must make sure to mark the data as dirty after changing it.</summary>
        </member>
        <member name="F:QtQuick.QSGGeometry.DataPattern.StaticPattern">
            <summary>The data is modified once and drawn many times. This is a hint that may provide better performance. When set the user must make sure to mark the data as dirty after changing it.</summary>
        </member>
        <member name="T:QtQuick.QSGGeometry.Attribute">
            <summary>
            <para>The QSGGeometry::Attribute describes a single vertex attribute in a QSGGeometry</para>
            </summary>
            <remarks>
            <para>The QSGGeometry::Attribute struct describes the attribute register position, the size of the attribute tuple and the attribute type.</para>
            <para>It also contains a hint to the renderer if this attribute is the attribute describing the position. The scene graph renderer may use this information to perform optimizations.</para>
            <para>It contains a number of bits which are reserved for future use.</para>
            <para></para>
            <para>See also QSGGeometry.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGGeometry.Attribute.Create(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            <para>Creates a new QSGGeometry::Attribute for attribute register pos with tupleSize. The primitiveType can be any of the supported OpenGL types, such as GL_FLOAT or GL_UNSIGNED_BYTE.</para>
            <para>If the attribute describes the position for the vertex, the isPosition hint should be set to true. The scene graph renderer may use this information to perform optimizations.</para>
            <para>Use the create function to construct the attribute, rather than an initialization list, to ensure that all fields are initialized.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGGeometry.AttributeSet">
            <summary>
            <para>The QSGGeometry::AttributeSet describes how the vertices in a QSGGeometry are built up.</para>
            </summary>
            <remarks>
            <para>See also QSGGeometry.</para>
            </remarks>
        </member>
        <member name="T:QtQuick.QSGGeometry.Point2D">
            <summary>
            <para>The QSGGeometry::Point2D struct is a convenience struct for accessing 2D Points.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.Point2D.Set(System.Single,System.Single)">
            <summary>
            <para>Sets the x and y values of this point to x and y.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGGeometry.TexturedPoint2D">
            <summary>
            <para>The QSGGeometry::TexturedPoint2D struct is a convenience struct for accessing 2D Points with texture coordinates.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.TexturedPoint2D.Set(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Sets the position of the vertex to x and y and the texture coordinate to tx and ty.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGGeometry.ColoredPoint2D">
            <summary>
            <para>The QSGGeometry::ColoredPoint2D struct is a convenience struct for accessing 2D Points with a color.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGGeometry.ColoredPoint2D.Set(System.Single,System.Single,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            <para>Sets the position of the vertex to x and y and the color to red, green, blue, and alpha.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGNode">
            <summary>
            <para>The QSGNode class is the base class for all nodes in the scene graph.</para>
            </summary>
            <remarks>
            <para>The QSGNode class can be used as a child container. Children are added with the appendChildNode(), prependChildNode(), insertChildNodeBefore() and insertChildNodeAfter(). The order of nodes is important as geometry nodes are rendered according to their ordering in the scene graph.</para>
            <para>The scene graph nodes contains a mechanism to describe which parts of the scene has changed. This includes the combined matrices, accumulated opacity, changes to the node hierarchy, and so on. This information can be used for optimizations inside the scene graph renderer. For the renderer to properly render the nodes, it is important that users call QSGNode::markDirty() with the correct flags when nodes are changed. Most of the functions on the node classes will implicitly call markDirty(). For example, QSGNode::appendChildNode() will call markDirty() passing in QSGNode::DirtyNodeAdded.</para>
            <para>If nodes change every frame, the preprocess() function can be used to apply changes to a node for every frame it is rendered. The use of preprocess() must be explicitly enabled by setting the QSGNode::UsePreprocess flag on the node.</para>
            <para>The virtual isSubtreeBlocked() function can be used to disable a subtree all together. Nodes in a blocked subtree will not be preprocessed() and not rendered.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGNode.#ctor">
            <summary>
            <para>Constructs a new node</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.RemoveChildNode(QtQuick.QSGNode)">
            <summary>
            <para>Removes node from this node's list of children.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.RemoveAllChildNodes">
            <summary>
            <para>Removes all child nodes from this node's list of children.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.PrependChildNode(QtQuick.QSGNode)">
            <summary>
            <para>Prepends node to this node's the list of children.</para>
            <para>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.AppendChildNode(QtQuick.QSGNode)">
            <summary>
            <para>Appends node to this node's list of children.</para>
            <para>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.InsertChildNodeBefore(QtQuick.QSGNode,QtQuick.QSGNode)">
            <summary>
            <para>Inserts node to this node's list of children before the node specified with before.</para>
            <para>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.InsertChildNodeAfter(QtQuick.QSGNode,QtQuick.QSGNode)">
            <summary>
            <para>Inserts node to this node's list of children after the node specified with after.</para>
            <para>Ordering of nodes is important as geometry nodes will be rendered in the order they are added to the scene graph.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.ChildAtIndex(System.Int32)">
            <summary>
            <para>Returns the child at index i.</para>
            <para>Children are stored internally as a linked list, so iterating over the children via the index is suboptimal.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.MarkDirty(QtQuick.QSGNode.DirtyStateBit)">
            <summary>
            <para>Notifies all connected renderers that the node has dirty bits.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.SetFlag(QtQuick.QSGNode.Flag,System.Boolean)">
            <summary>
            <para>Sets the flag f on this node if enabled is true; otherwise clears the flag.</para>
            <para>See also flags().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.SetFlags(QtQuick.QSGNode.Flag,System.Boolean)">
            <summary>
            <para>Sets the flags f on this node if enabled is true; otherwise clears the flags.</para>
            <para>See also flags().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGNode.Preprocess">
            <summary>
            <para>Override this function to do processing on the node before it is rendered.</para>
            <para>Preprocessing needs to be explicitly enabled by setting the flag QSGNode::UsePreprocess. The flag needs to be set before the node is added to the scene graph and will cause the preprocess() function to be called for every frame the node is rendered.</para>
            <para>The preprocess function is called before the update pass that propegates opacity and transformations through the scene graph. That means that functions like QSGOpacityNode::combinedOpacity() and QSGTransformNode::combinedMatrix() will not contain up-to-date values. If such values are changed during the preprocess, these changes will be propegated through the scene graph before it is rendered.</para>
            <para>Warning: Beware of deleting nodes while they are being preprocessed. It is possible, with a small performance hit, to delete a single node during its own preprocess call. Deleting a subtree which has nodes that also use preprocessing may result in a segmentation fault. This is done for performance reasons.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.Flags">
            <summary>
            <para>Returns the set of flags for this node.</para>
            <para>See also setFlags().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.Parent">
            <summary>
            <para>Returns the parent node of this node.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.ChildCount">
            <summary>
            <para>Returns the number of child nodes.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.FirstChild">
            <summary>
            <para>Returns the first child of this node.</para>
            <para>The children are stored in a linked list.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.LastChild">
            <summary>
            <para>Returns the last child of this node.</para>
            <para>The children are stored as a linked list.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.NextSibling">
            <summary>
            <para>Returns the node after this in the parent's list of children.</para>
            <para>The children are stored as a linked list.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.PreviousSibling">
            <summary>
            <para>Returns the node before this in the parent's list of children.</para>
            <para>The children are stored as a linked list.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.Type">
            <summary>
            <para>Returns the type of this node. The node type must be one of the predefined types defined in QSGNode::NodeType and can safely be used to cast to the corresponding class.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGNode.IsSubtreeBlocked">
            <summary>
            <para>Returns whether this node and its subtree is available for use.</para>
            <para>Blocked subtrees will not get their dirty states updated and they will not be rendered.</para>
            <para>The QSGOpacityNode will return a blocked subtree when accumulated opacity is 0, for instance.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGNode.NodeType">
            <summary>
            <para>Can be used to figure out the type of node.</para>
            <para>See also type().</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGNode.NodeType.BasicNodeType">
            <summary>The type of QSGNode</summary>
        </member>
        <member name="F:QtQuick.QSGNode.NodeType.GeometryNodeType">
            <summary>The type of QSGGeometryNode</summary>
        </member>
        <member name="F:QtQuick.QSGNode.NodeType.TransformNodeType">
            <summary>The type of QSGTransformNode</summary>
        </member>
        <member name="F:QtQuick.QSGNode.NodeType.ClipNodeType">
            <summary>The type of QSGClipNode</summary>
        </member>
        <member name="F:QtQuick.QSGNode.NodeType.OpacityNodeType">
            <summary>The type of QSGOpacityNode</summary>
        </member>
        <member name="T:QtQuick.QSGNode.Flag">
            <summary>
            <para>The QSGNode::Flag enum describes flags on the QSGNode</para>
            <para>The Flags type is a typedef for QFlags&lt;Flag&gt;. It stores an OR combination of Flag values.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGNode.Flag.OwnedByParent">
            <summary>The node is owned by its parent and will be deleted when the parent is deleted.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.Flag.UsePreprocess">
            <summary>The node's virtual preprocess() function will be called before rendering starts.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.Flag.OwnsGeometry">
            <summary>Only valid for QSGGeometryNode and QSGClipNode. The node has ownership over the QSGGeometry instance and will delete it when the node is destroyed or a geometry is assigned.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.Flag.OwnsMaterial">
            <summary>Only valid for QSGGeometryNode. The node has ownership over the material and will delete it when the node is destroyed or a material is assigned.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.Flag.OwnsOpaqueMaterial">
            <summary>Only valid for QSGGeometryNode. The node has ownership over the opaque material and will delete it when the node is destroyed or a material is assigned.</summary>
        </member>
        <member name="T:QtQuick.QSGNode.DirtyStateBit">
            <summary>
            <para>Used in QSGNode::markDirty() to indicate how the scene graph has changed.</para>
            <para>The DirtyState type is a typedef for QFlags&lt;DirtyStateBit&gt;. It stores an OR combination of DirtyStateBit values.</para>
            <para>See also QSGNode::markDirty().</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGNode.DirtyStateBit.DirtyMatrix">
            <summary>The matrix in a QSGTransformNode has changed.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.DirtyStateBit.DirtyNodeAdded">
            <summary>A node was added.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.DirtyStateBit.DirtyNodeRemoved">
            <summary>A node was removed.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.DirtyStateBit.DirtyGeometry">
            <summary>The geometry of a QSGGeometryNode has changed.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.DirtyStateBit.DirtyMaterial">
            <summary>The material of a QSGGeometryNode has changed.</summary>
        </member>
        <member name="F:QtQuick.QSGNode.DirtyStateBit.DirtyOpacity">
            <summary>The opacity of a QSGOpacityNode has changed.</summary>
        </member>
        <member name="T:QtQuick.QSGBasicGeometryNode">
            <summary>
            <para>The QSGBasicGeometryNode class serves as a baseclass for geometry based nodes.</para>
            </summary>
            <remarks>
            <para>The QSGBasicGeometryNode class should not be used by itself. It is only encapsulates shared functionality between the QSGGeometryNode and QSGClipNode classes.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="P:QtQuick.QSGBasicGeometryNode.Geometry">
            <summary>
            <para>Returns this node's geometry.</para>
            <para>The geometry is null by default.</para>
            <para></para>
            <para>Sets the geometry of this node to geometry.</para>
            <para>If the node has the flag QSGNode::OwnsGeometry set, it will also delete the geometry object it is pointing to. This flag is not set by default.</para>
            <para>If the geometry is changed whitout calling setGeometry() again, the user must also mark the geometry as dirty using QSGNode::markDirty().</para>
            <para>See also geometry() and markDirty().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGGeometryNode">
            <summary>
            <para>The QSGGeometryNode class is used for all rendered content in the scene graph.</para>
            </summary>
            <remarks>
            <para>The QSGGeometryNode consists of geometry and material. The geometry defines the mesh, the vertices and their structure, to be drawn. The Material defines how the shape is filled.</para>
            <para>The following is a code snippet illustrating how to create a red line using a QSGGeometryNode:</para>
            <para></para>
            <para></para>
            <para>  QSGGeometry *geometry = new QSGGeometry(QSGGeometry::defaultAttributes_Point2D(), 2);</para>
            <para>  geometry-&gt;setDrawingMode(GL_LINES);</para>
            <para>  geometry-&gt;setLineWidth(3);</para>
            <para>  geometry-&gt;vertexDataAsPoint2D()[0].set(0, 0);</para>
            <para>  geometry-&gt;vertexDataAsPoint2D()[1].set(width(), height());</para>
            <para></para>
            <para>  QSGFlatColorMaterial *material = new QSGFlatColorMaterial;</para>
            <para>  material-&gt;setColor(QColor(255, 0, 0));</para>
            <para></para>
            <para>  QSGGeometryNode *node = new QSGGeometryNode;</para>
            <para>  node-&gt;setGeometry(geometry);</para>
            <para>  node-&gt;setFlag(QSGNode::OwnsGeometry);</para>
            <para>  node-&gt;setMaterial(material);</para>
            <para>  node-&gt;setFlag(QSGNode::OwnsMaterial);</para>
            <para></para>
            <para></para>
            <para>A geometry node must have both geometry and a normal material before it is added to the scene graph. When the geometry and materials are changed after the node has been added to the scene graph, the user should also mark them as dirty using QSGNode::markDirty().</para>
            <para>The geometry node supports two types of materials, the opaqueMaterial and the normal material. The opaqueMaterial is used when the accumulated scene graph opacity at the time of rendering is 1. The primary usecase is to special case opaque rendering to avoid an extra operation in the fragment shader can have significant performance impact on embedded graphics chips. The opaque material is optional.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            <para></para>
            <para>See also QSGGeometry, QSGMaterial, and QSGSimpleMaterial.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGGeometryNode.#ctor">
            <summary>
            <para>Creates a new geometry node without geometry and material.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometryNode.Material">
            <summary>
            <para>Returns the material of the QSGGeometryNode.</para>
            <para>See also setMaterial().</para>
            <para></para>
            <para>Sets the material of this geometry node to material.</para>
            <para>Geometry nodes must have a material before they can be added to the scene graph.</para>
            <para>If the material is changed whitout calling setMaterial() again, the user must also mark the material as dirty using QSGNode::markDirty().</para>
            <para>See also material().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGGeometryNode.OpaqueMaterial">
            <summary>
            <para>Returns the opaque material of the QSGGeometryNode.</para>
            <para>See also setOpaqueMaterial().</para>
            <para></para>
            <para>Sets the opaque material of this geometry to material.</para>
            <para>The opaque material will be preferred by the renderer over the default material, as returned by the material() function, if it is not null and the geometry item has an inherited opacity of 1.</para>
            <para>The opaqueness refers to scene graph opacity, the material is still allowed to set QSGMaterial::Blending to true and draw transparent pixels.</para>
            <para>If the material is changed whitout calling setOpaqueMaterial() again, the user must also mark the opaque material as dirty using QSGNode::markDirty().</para>
            <para>See also opaqueMaterial().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGClipNode">
            <summary>
            <para>The QSGClipNode class implements the clipping functionality in the scene graph.</para>
            </summary>
            <remarks>
            <para>Clipping applies to the node's subtree and can be nested. Multiple clip nodes will be accumulated by intersecting all their geometries. The accumulation happens as part of the rendering.</para>
            <para>Clip nodes must have a geometry before they can be added to the scene graph.</para>
            <para>Clipping is usually implemented by using the stencil buffer.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGClipNode.#ctor">
            <summary>
            <para>Creates a new QSGClipNode without a geometry.</para>
            <para>The clip node must have a geometry before it can be added to the scene graph.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGClipNode.IsRectangular">
            <summary>
            <para>Returns if this clip node has a rectangular clip.</para>
            <para>See also setIsRectangular().</para>
            <para></para>
            <para>Sets whether this clip node has a rectangular clip to rectHint.</para>
            <para>This is an optimization hint which means that the renderer can use scissoring instead of stencil, which is significantly faster.</para>
            <para>When this hint is set and it is applicable, the clip region will be generated from clipRect() rather than geometry().</para>
            <para>See also isRectangular().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGClipNode.ClipRect">
            <summary>
            <para>Returns the clip rect of this node.</para>
            <para>See also setClipRect().</para>
            <para></para>
            <para>Sets the clip rect of this clip node to rect.</para>
            <para>When a rectangular clip is set in combination with setIsRectangular the renderer may in some cases use a more optimal clip method.</para>
            <para>See also clipRect().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGTransformNode">
            <summary>
            <para>The QSGTransformNode class implements transformations in the scene graph</para>
            </summary>
            <remarks>
            <para>Transformations apply the node's subtree and can be nested. Multiple transform nodes will be accumulated by intersecting all their matrices. The accumulation happens as part of the rendering.</para>
            <para>The transform nodes implement a 4x4 matrix which in theory supports full 3D transformations. However, because the renderer optimizes for 2D use-cases rather than 3D use-cases, rendering a scene with full 3D transformations needs to be done with some care.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGTransformNode.#ctor">
            <summary>
            <para>Create a new QSGTransformNode with its matrix set to the identity matrix.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTransformNode.Matrix">
            <summary>
            <para>Returns this transform node's matrix.</para>
            <para>See also setMatrix().</para>
            <para></para>
            <para>Sets this transform node's matrix to matrix.</para>
            <para>See also matrix().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGOpacityNode">
            <summary>
            <para>The QSGOpacityNode class is used to change opacity of nodes.</para>
            </summary>
            <remarks>
            <para>Opacity applies to its subtree and can be nested. Multiple opacity nodes will be accumulated by multiplying their opacity. The accumulation happens as part of the rendering.</para>
            <para>When nested opacity gets below a certain threshold, the subtree might be marked as blocked, causing isSubtreeBlocked() to return true. This is done for performance reasons.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGOpacityNode.#ctor">
            <summary>
            <para>Constructs an opacity node with a default opacity of 1.</para>
            <para>Opacity accumulates downwards in the scene graph so a node with two QSGOpacityNode instances above it, both with opacity of 0.5, will have effective opacity of 0.25.</para>
            <para>The default opacity of nodes is 1.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGOpacityNode.Opacity">
            <summary>
            <para>Returns this opacity node's opacity.</para>
            <para>See also setOpacity().</para>
            <para></para>
            <para>Sets the opacity of this node to opacity.</para>
            <para>Before rendering the graph, the renderer will do an update pass over the subtree to propegate the opacity to its children.</para>
            <para>The value will be bounded to the range 0 to 1.</para>
            <para>See also opacity().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGAbstractRenderer">
            <summary>
            <para>QSGAbstractRenderer gives access to the scene graph nodes and rendering of a QSGEngine.</para>
            </summary>
            <remarks>
            <para>A QSGAbstractRenderer created by a QSGEngine allows you to set your QSGNode tree through setRootNode() and control the rendering viewport through setDeviceRect(), setViewportRect() and setProjectionMatrixToRect(). You can finally trigger the rendering to the desired framebuffer through renderScene().</para>
            <para>The QSGAbstractRenderer is only available when used with a QSGEngine and isn't exposed when used internally by QQuickWindow.</para>
            <para></para>
            <para>See also QSGEngine and QSGNode.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGAbstractRenderer.SetDeviceRect(QtCore.QSize)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the size of the surface being rendered to.</para>
            <para>See also deviceRect().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGAbstractRenderer.SetViewportRect(QtCore.QSize)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the size of the viewport to render on the surface.</para>
            <para>See also viewportRect().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGAbstractRenderer.SetProjectionMatrixToRect(QtCore.QRectF)">
            <summary>
            <para>Convenience method that calls setProjectionMatrix() with an orthographic matrix generated from rect.</para>
            <para>See also setProjectionMatrix() and projectionMatrix().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGAbstractRenderer.RenderScene(System.UInt32)">
            <summary>
            <para>Render the scene to the specified fboId</para>
            <para>If fboId isn't specified, the scene graph will be rendered to the default framebuffer. You will have to call QOpenGLContext::swapBuffers() yourself afterward.</para>
            <para>The framebuffer specified by fboId will be bound automatically.</para>
            <para>See also QOpenGLContext::swapBuffers() and QOpenGLFramebufferObject::handle().</para>
            </summary>
        </member>
        <member name="E:QtQuick.QSGAbstractRenderer.SceneGraphChanged">
            <summary>
            <para>This signal is emitted on the first modification of a node in the tree after the last scene render.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGAbstractRenderer.RootNode">
            <summary>
            <para>Returns the root of the QSGNode scene.</para>
            <para>See also setRootNode().</para>
            <para></para>
            <para>Sets the node as the root of the QSGNode scene that you want to render. You need to provide a node before trying to render the scene.</para>
            <para>Note: This doesn't take ownership of node.</para>
            <para>See also rootNode().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGAbstractRenderer.DeviceRect">
            <summary>
            <para>Returns the device rect of the surface being rendered to.</para>
            <para>See also setDeviceRect().</para>
            <para></para>
            <para>Sets rect as the geometry of the surface being rendered to.</para>
            <para>See also deviceRect().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGAbstractRenderer.ViewportRect">
            <summary>
            <para>Returns the rect of the viewport to render.</para>
            <para>See also setViewportRect().</para>
            <para></para>
            <para>Sets rect as the geometry of the viewport to render on the surface.</para>
            <para>See also viewportRect().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGAbstractRenderer.ProjectionMatrix">
            <summary>
            <para>Returns the projection matrix</para>
            <para>See also setProjectionMatrix() and setProjectionMatrixToRect().</para>
            <para></para>
            <para>Use matrix to project the QSGNode coordinates onto surface pixels.</para>
            <para>See also projectionMatrix() and setProjectionMatrixToRect().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGAbstractRenderer.ClearColor">
            <summary>
            <para>Returns the color that clears the framebuffer at the beginning of the rendering.</para>
            <para>See also setClearColor() and clearMode().</para>
            <para></para>
            <para>Use color to clear the framebuffer when clearMode() is set to QSGAbstractRenderer::ClearColorBuffer.</para>
            <para>See also clearColor() and setClearMode().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGAbstractRenderer.ClearMode">
            <summary>
            <para>Flags defining which attachment of the framebuffer will be cleared before each scene render.</para>
            <para>See also setClearMode() and clearColor().</para>
            <para></para>
            <para>Defines which attachment of the framebuffer should be cleared before each scene render with the mode flag.</para>
            <para>See also clearMode() and setClearColor().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGAbstractRenderer.ClearModeBit">
            <summary>
            <para>Used with setClearMode() to indicate which buffer should be cleared before the scene render.</para>
            <para>The ClearMode type is a typedef for QFlags&lt;ClearModeBit&gt;. It stores an OR combination of ClearModeBit values.</para>
            <para>See also setClearMode() and setClearColor().</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGAbstractRenderer.ClearModeBit.ClearColorBuffer">
            <summary>Clear the color buffer using clearColor().</summary>
        </member>
        <member name="F:QtQuick.QSGAbstractRenderer.ClearModeBit.ClearDepthBuffer">
            <summary>Clear the depth buffer.</summary>
        </member>
        <member name="F:QtQuick.QSGAbstractRenderer.ClearModeBit.ClearStencilBuffer">
            <summary>Clear the stencil buffer.</summary>
        </member>
        <member name="T:QtQuick.QSGMaterialShader">
            <summary>
            <para>The QSGMaterialShader class represents an OpenGL shader program in the renderer.</para>
            </summary>
            <remarks>
            <para>The QSGMaterialShader API is very low-level. A more convenient API, which provides almost all the same features, is available through QSGSimpleMaterialShader.</para>
            <para>The QSGMaterial and QSGMaterialShader form a tight relationship. For one scene graph (including nested graphs), there is one unique QSGMaterialShader instance which encapsulates the QOpenGLShaderProgram the scene graph uses to render that material, such as a shader to flat coloring of geometry. Each QSGGeometryNode can have a unique QSGMaterial containing the how the shader should be configured when drawing that node, such as the actual color used to render the geometry.</para>
            <para>An instance of QSGMaterialShader is never created explicitly by the user, it will be created on demand by the scene graph through QSGMaterial::createShader(). The scene graph will make sure that there is only one instance of each shader implementation through a scene graph.</para>
            <para>The source code returned from vertexShader() is used to control what the material does with the vertiex data that comes in from the geometry. The source code returned from the fragmentShader() is used to control what how the material should fill each individual pixel in the geometry. The vertex and fragment source code is queried once during initialization, changing what is returned from these functions later will not have any effect.</para>
            <para>The activate() function is called by the scene graph when a shader is is starting to be used. The deactivate function is called by the scene graph when the shader is no longer going to be used. While active, the scene graph may make one or more calls to updateState() which will update the state of the shader for each individual geometry to render.</para>
            <para>The attributeNames() returns the name of the attributes used in the vertexShader(). These are used in the default implementation of activate() and deactivate() to decide whice vertex registers are enabled.</para>
            <para>The initialize() function is called during program creation to allow subclasses to prepare for use, such as resolve uniform names in the vertexShader() and fragmentShader().</para>
            <para>A minimal example:</para>
            <para></para>
            <para></para>
            <para>  class Shader : public QSGMaterialShader</para>
            <para>  {</para>
            <para>  public:</para>
            <para>      const char *vertexShader() const {</para>
            <para>          return</para>
            <para>          &quot;attribute highp vec4 vertex;          \n&quot;</para>
            <para>          &quot;uniform highp mat4 matrix;            \n&quot;</para>
            <para>          &quot;void main() {                         \n&quot;</para>
            <para>          &quot;    gl_Position = matrix * vertex;    \n&quot;</para>
            <para>          &quot;}&quot;;</para>
            <para>      }</para>
            <para></para>
            <para>      const char *fragmentShader() const {</para>
            <para>          return</para>
            <para>          &quot;uniform lowp float opacity;                            \n&quot;</para>
            <para>          &quot;void main() {                                          \n&quot;</para>
            <para>                  &quot;    gl_FragColor = vec4(1, 0, 0, 1) * opacity; \n&quot;</para>
            <para>          &quot;}&quot;;</para>
            <para>      }</para>
            <para></para>
            <para>      char const *const *attributeNames() const</para>
            <para>      {</para>
            <para>          static char const *const names[] = { &quot;vertex&quot;, 0 };</para>
            <para>          return names;</para>
            <para>      }</para>
            <para></para>
            <para>      void initialize()</para>
            <para>      {</para>
            <para>          QSGMaterialShader::initialize();</para>
            <para>          m_id_matrix = program()-&gt;uniformLocation(&quot;matrix&quot;);</para>
            <para>          m_id_opacity = program()-&gt;uniformLocation(&quot;opacity&quot;);</para>
            <para>      }</para>
            <para></para>
            <para>      void updateState(const RenderState &amp;state, QSGMaterial *newMaterial, QSGMaterial *oldMaterial)</para>
            <para>      {</para>
            <para>          Q_ASSERT(program()-&gt;isLinked());</para>
            <para>          if (state.isMatrixDirty())</para>
            <para>              program()-&gt;setUniformValue(m_id_matrix, state.combinedMatrix());</para>
            <para>          if (state.isOpacityDirty())</para>
            <para>              program()-&gt;setUniformValue(m_id_opacity, state.opacity());</para>
            <para>      }</para>
            <para></para>
            <para>  private:</para>
            <para>      int m_id_matrix;</para>
            <para>      int m_id_opacity;</para>
            <para>  };</para>
            <para></para>
            <para></para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.#ctor">
            <summary>
            <para>Creates a new QSGMaterialShader.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.Activate">
            <summary>
            <para>This function is called by the scene graph to indicate that geometry is about to be rendered using this shader.</para>
            <para>State that is global for all uses of the shader, independent of the geometry that is being drawn, can be setup in this function.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.Deactivate">
            <summary>
            <para>This function is called by the scene graph to indicate that geometry will no longer to be rendered using this shader.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.UpdateState(QtQuick.QSGMaterialShader.RenderState,QtQuick.QSGMaterial,QtQuick.QSGMaterial)">
            <summary>
            <para>This function is called by the scene graph before geometry is rendered to make sure the shader is in the right state.</para>
            <para>The current rendering state is passed from the scene graph. If the state indicates that any state is dirty, the updateState implementation must update accordingly for the geometry to render correctly.</para>
            <para>The subclass specific state, such as the color of a flat color material, should be extracted from newMaterial to update the color uniforms accordingly.</para>
            <para>The oldMaterial can be used to minimze state changes when updating material states. The oldMaterial is 0 if this shader was just activated.</para>
            <para>See also activate() and deactivate().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.SetShaderSourceFile(QtGui.QOpenGLShader.ShaderTypeBit,System.String)">
            <summary>
            <para>Sets the GLSL source file for the shader stage type to sourceFile. The default implementation of the vertexShader() and fragmentShader() functions will load the source files set by this function.</para>
            <para>This function is useful when you have a single source file for a given shader stage. If your shader consists of multiple source files then use setShaderSourceFiles()</para>
            <para>See also setShaderSourceFiles(), vertexShader(), and fragmentShader().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.SetShaderSourceFiles(QtGui.QOpenGLShader.ShaderTypeBit,QtCore.QStringList)">
            <summary>
            <para>Sets the GLSL source files for the shader stage type to sourceFiles. The default implementation of the vertexShader() and fragmentShader() functions will load the source files set by this function in the order given.</para>
            <para>See also setShaderSourceFile(), vertexShader(), and fragmentShader().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.Compile">
            <summary>
            <para>This function is called when the shader is initialized to compile the actual QOpenGLShaderProgram. Do not call it explicitly.</para>
            <para>The default implementation will extract the vertexShader() and fragmentShader() and bind the names returned from attributeNames() to consecutive vertex attribute registers starting at 0.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.Initialize">
            <summary>
            <para>Reimplement this function to do one-time initialization when the shader program is compiled. The OpenGL shader program is compiled and linked, but not bound, when this function is called.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.AttributeNames">
            <summary>
            <para>Returns a zero-terminated array describing the names of the attributes used in the vertex shader.</para>
            <para>This function is called when the shader is compiled to specify which attributes exist. The order of the attribute names defines the attribute register position in the vertex shader.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.Program">
            <summary>
            <para>Returns the shader program used by this QSGMaterialShader.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.VertexShader">
            <summary>
            <para>Called when the shader is being initialized to get the vertex shader source code.</para>
            <para>The contents returned from this function should never change.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.FragmentShader">
            <summary>
            <para>Called when the shader is being initialized to get the fragment shader source code.</para>
            <para>The contents returned from this function should never change.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGMaterialShader.RenderState">
            <summary>
            <para>The QSGMaterialShader::RenderState encapsulates the current rendering state during a call to QSGMaterialShader::updateState().</para>
            </summary>
            <remarks>
            <para>The render state contains a number of accessors that the shader needs to respect in order to conform to the current state of the scene graph.</para>
            <para>The instance is only valid inside a call to QSGMaterialShader::updateState() and should not be used outisde this function.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGMaterialShader.RenderState.DirtyStates">
            <summary>
            <para>Returns which rendering states that have changed and needs to be updated for geometry rendered with this material to conform to the current rendering state.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.IsMatrixDirty">
            <summary>
            <para>Returns true if the dirtyStates() contain the dirty matrix state, otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.IsOpacityDirty">
            <summary>
            <para>Returns true if the dirtyStates() contains the dirty opacity state, otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.Opacity">
            <summary>
            <para>Returns the accumulated opacity to be used for rendering.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.CombinedMatrix">
            <summary>
            <para>Returns the matrix combined of modelview matrix and project matrix.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.ModelViewMatrix">
            <summary>
            <para>Returns the model view matrix.</para>
            <para>If the material has the RequiresFullMatrix flag set, this is guaranteed to be the complete transform matrix calculated from the scenegraph.</para>
            <para>However, if this flag is not set, the renderer may choose to alter this matrix. For example, it may pre-transform vertices on the CPU and set this matrix to identity.</para>
            <para>In a situation such as the above, it is still possible to retrieve the actual matrix determinant by setting the RequiresDeterminant flag in the material and calling the determinant() accessor.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.ProjectionMatrix">
            <summary>
            <para>Returns the projection matrix.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.ViewportRect">
            <summary>
            <para>Returns the viewport rect of the surface being rendered to.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.DeviceRect">
            <summary>
            <para>Returns the device rect of the surface being rendered to</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.Determinant">
            <summary>
            <para>Returns the modelview determinant to be used for rendering.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.DevicePixelRatio">
            <summary>
            <para>Returns the ratio between physical pixels and device-independent pixels to be used for rendering.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterialShader.RenderState.Context">
            <summary>
            <para>Returns the QOpenGLContext that is being used for rendering</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGMaterialShader.RenderState.DirtyState">
            <summary>
            <para>The DirtyStates type is a typedef for QFlags&lt;DirtyState&gt;. It stores an OR combination of DirtyState values.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGMaterialType">
            <summary>
            <para>The QSGMaterialType class is used as a unique type token in combination with QSGMaterial.</para>
            </summary>
            <remarks>
            <para>It serves no purpose outside the QSGMaterial::type() function.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="T:QtQuick.QSGMaterial">
            <summary>
            <para>The QSGMaterial class encapsulates rendering state for a shader program.</para>
            </summary>
            <remarks>
            <para>The QSGMaterial API is very low-level. A more convenient API, which provides almost all the same features, is available through QSGSimpleMaterialShader.</para>
            <para>The QSGMaterial and QSGMaterialShader subclasses form a tight relationship. For one scene graph (including nested graphs), there is one unique QSGMaterialShader instance which encapsulates the QOpenGLShaderProgram the scene graph uses to render that material, such as a shader to flat coloring of geometry. Each QSGGeometryNode can have a unique QSGMaterial containing the how the shader should be configured when drawing that node, such as the actual color to used to render the geometry.</para>
            <para>The QSGMaterial has two virtual functions that both need to be implemented. The function type() should return a unique instance for all instances of a specific subclass. The createShader() function should return a new instance of QSGMaterialShader, specific to the subclass of QSGMaterial.</para>
            <para>A minimal QSGMaterial implementation could look like this:</para>
            <para></para>
            <para></para>
            <para>  class Material : public QSGMaterial</para>
            <para>  {</para>
            <para>  public:</para>
            <para>      QSGMaterialType *type() const { static QSGMaterialType type; return &amp;type; }</para>
            <para>      QSGMaterialShader *createShader() const { return new Shader; }</para>
            <para>  };</para>
            <para></para>
            <para></para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGMaterial.CreateShader">
            <summary>
            <para>This function returns a new instance of a the QSGMaterialShader implementatation used to render geometry for a specific implementation of QSGMaterial.</para>
            <para>The function will be called only once for each material type that exists in the scene graph and will be cached internally.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterial.Compare(QtQuick.QSGMaterial)">
            <summary>
            <para>Compares this material to other and returns 0 if they are equal; -1 if this material should sort before other and 1 if other should sort before.</para>
            <para>The scene graph can reorder geometry nodes to minimize state changes. The compare function is called during the sorting process so that the materials can be sorted to minimize state changes in each call to QSGMaterialShader::updateState().</para>
            <para>The this pointer and other is guaranteed to have the same type().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGMaterial.SetFlag(QtQuick.QSGMaterial.Flag,System.Boolean)">
            <summary>
            <para>Sets the flags flags on this material if on is true; otherwise clears the attribute.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterial.Type">
            <summary>
            <para>This function is called by the scene graph to return a unique instance per subclass.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGMaterial.Flags">
            <summary>
            <para>Returns the material's flags.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGMaterial.Flag">
            <summary>
            <para>QSGMaterialShader::compile() when its shader program is compiled and linked. Set this flag to enforce that the function is called.</para>
            <para>The Flags type is a typedef for QFlags&lt;Flag&gt;. It stores an OR combination of Flag values.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGMaterial.Flag.Blending">
            <summary>Set this flag to true if the material requires GL_BLEND to be enabled during rendering.</summary>
        </member>
        <member name="F:QtQuick.QSGMaterial.Flag.RequiresDeterminant">
            <summary>Set this flag to true if the material relies on the determinant of the matrix of the geometry nodes for rendering.</summary>
        </member>
        <member name="F:QtQuick.QSGMaterial.Flag.RequiresFullMatrixExceptTranslate">
            <summary>Set this flag to true if the material relies on the full matrix of the geometry nodes for rendering, except the translation part.</summary>
        </member>
        <member name="F:QtQuick.QSGMaterial.Flag.RequiresFullMatrix">
            <summary>Set this flag to true if the material relies on the full matrix of the geometry nodes for rendering.</summary>
        </member>
        <member name="F:QtQuick.QSGMaterial.Flag.CustomCompileStep">
            <summary>Starting with Qt 5.2, the scene graph will not always call</summary>
        </member>
        <member name="T:QtQuick.QSGEngine">
            <summary>
            <para>The QSGEngine class allows low level rendering of a scene graph.</para>
            </summary>
            <remarks>
            <para>A QSGEngine can be used to render a tree of QSGNode directly on a QWindow or QOpenGLFramebufferObject without any integration with QML, QQuickWindow or QQuickItem and the convenience that they provide.</para>
            <para>This means that you must handle event propagation, animation timing, and node lifetime yourself.</para>
            <para>Note: This class is for very low level access to an independent scene graph. Most of the time you will instead want to subclass QQuickItem and insert your QSGNode in a normal QtQuick scene by overriding QQuickItem::updatePaintNode().</para>
            <para></para>
            <para>See also QSGAbstractRenderer.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGEngine.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a new QSGEngine with its parent</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGEngine.Initialize(QtGui.QOpenGLContext)">
            <summary>
            <para>Initialize the engine with context.</para>
            <para>Warning: You have to make sure that you call QOpenGLContext::makeCurrent() on context before calling this.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGEngine.Invalidate">
            <summary>
            <para>Invalidate the engine releasing its resources</para>
            <para>You will have to call initialize() and createRenderer() if you want to use it again.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGEngine.CreateRenderer">
            <summary>
            <para>Returns a renderer that can be used to render a QSGNode tree</para>
            <para>You call initialize() first with the QOpenGLContext that you want to use with this renderer. This will return a null renderer otherwise.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGEngine.CreateTextureFromImage(QtGui.QImage,QtQuick.QSGEngine.CreateTextureOption)">
            <summary>
            <para>Creates a texture using the data of image</para>
            <para>Valid options are TextureCanUseAtlas and TextureIsOpaque.</para>
            <para>The caller takes ownership of the texture and the texture should only be used with this engine.</para>
            <para>See also createTextureFromId(), QSGSimpleTextureNode::setOwnsTexture(), and QQuickWindow::createTextureFromImage().</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGEngine.CreateTextureFromId(System.UInt32,QtCore.QSize,QtQuick.QSGEngine.CreateTextureOption)">
            <summary>
            <para>Creates a texture object that wraps the GL texture id uploaded with size</para>
            <para>Valid options are TextureHasAlphaChannel and TextureOwnsGLTexture</para>
            <para>The caller takes ownership of the texture object and the texture should only be used with this engine.</para>
            <para>See also createTextureFromImage(), QSGSimpleTextureNode::setOwnsTexture(), and QQuickWindow::createTextureFromId().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGEngine.CreateTextureOption">
            <summary>
            <para>The CreateTextureOption enums are used to customize how a texture is wrapped.</para>
            <para>The CreateTextureOptions type is a typedef for QFlags&lt;CreateTextureOption&gt;. It stores an OR combination of CreateTextureOption values.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGEngine.CreateTextureOption.TextureHasAlphaChannel">
            <summary>The texture has an alpha channel and should be drawn using blending.</summary>
        </member>
        <member name="F:QtQuick.QSGEngine.CreateTextureOption.TextureOwnsGLTexture">
            <summary>The texture object owns the texture id and will delete the GL texture when the texture object is deleted.</summary>
        </member>
        <member name="F:QtQuick.QSGEngine.CreateTextureOption.TextureCanUseAtlas">
            <summary>The image can be uploaded into a texture atlas.</summary>
        </member>
        <member name="T:QtQuick.QSGFlatColorMaterial">
            <summary>
            <para>The QSGFlatColorMaterial class provides a convenient way of rendering solid colored geometry in the scene graph.</para>
            </summary>
            <remarks>
            <para>The flat color material will fill every pixel in a geometry using a solid color. The color can contain transparency.</para>
            <para>The geometry to be rendered with a flat color material requires vertices in attribute location 0 in the QSGGeometry object to render correctly. The QSGGeometry::defaultAttributes_Point2D() returns an attribute set compatible with this material.</para>
            <para>The flat color material respects both current opacity and current matrix when updating its rendering state.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGFlatColorMaterial.#ctor">
            <summary>
            <para>Constructs a new flat color material.</para>
            <para>The default color is white.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGFlatColorMaterial.Color">
            <summary>
            <para>Returns this flat color material's color.</para>
            <para>The default color is white.</para>
            <para>See also setColor().</para>
            <para></para>
            <para>Sets this flat color material's color to color.</para>
            <para>See also color().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGSimpleRectNode">
            <summary>
            <para>The QSGSimpleRectNode class is a convenience class for drawing solid filled rectangles using scenegraph.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGSimpleRectNode.#ctor(QtCore.QRectF,QtGui.QColor)">
            <summary>
            <para>Constructs a QSGSimpleRectNode instance which is spanning rect with the color color.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGSimpleRectNode.#ctor">
            <summary>
            <para>Constructs a QSGSimpleRectNode instance with an empty rectangle and white color.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGSimpleRectNode.SetRect(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the rectangle of this rect node to begin at (x, y) and have width w and height h.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleRectNode.Rect">
            <summary>
            <para>Returns the rectangle that this rect node covers.</para>
            <para>See also setRect().</para>
            <para></para>
            <para>Sets the rectangle of this rect node to rect.</para>
            <para>See also rect().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleRectNode.Color">
            <summary>
            <para>Returns the color of this rectangle.</para>
            <para>See also setColor().</para>
            <para></para>
            <para>Sets the color of this rectangle to color. The default color will be white.</para>
            <para>See also color().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGTexture">
            <summary>
            <para>The QSGTexture class is a baseclass for textures used in the scene graph.</para>
            </summary>
            <remarks>
            <para>Users can freely implement their own texture classes to support arbitrary input textures, such as YUV video frames or 8 bit alpha masks. The scene graph backend provides a default implementation of normal color textures. As the implementation of these may be hardware specific, they are constructed via the factory function QQuickWindow::createTextureFromImage().</para>
            <para>The texture is a wrapper around an OpenGL texture, which texture id is given by textureId() and which size in pixels is given by textureSize(). hasAlphaChannel() reports if the texture contains opacity values and hasMipmaps() reports if the texture contains mipmap levels.</para>
            <para>To use a texture, call the bind() function. The texture parameters specifying how the texture is bound, can be specified with setMipmapFiltering(), setFiltering(), setHorizontalWrapMode() and setVerticalWrapMode(). The texture will internally try to store these values to minimize the OpenGL state changes when the texture is bound.</para>
            <para></para>
            <para>Texture Atlasses</para>
            <para>Some scene graph backends use texture atlasses, grouping multiple small textures into one large texture. If this is the case, the function isAtlasTexture() will return true. Atlasses are used to aid the rendering algorithm to do better sorting which increases performance. The location of the texture inside the atlas is given with the normalizedTextureSubRect() function.</para>
            <para>If the texture is used in such a way that atlas is not preferable, the function removedFromAtlas() can be used to extract a non-atlassed copy.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            <para></para>
            <para>See also Scene Graph - Rendering FBOs and Scene Graph - Rendering FBOs in a thread.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGTexture.#ctor">
            <summary>
            <para>Constructs the QSGTexture base class.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGTexture.Bind">
            <summary>
            <para>Call this function to bind this texture to the current texture target.</para>
            <para>Binding a texture may also include uploading the texture data from a previously set QImage.</para>
            <para>Warning: This function can only be called from the rendering thread.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGTexture.UpdateBindOptions(System.Boolean)">
            <summary>
            <para>Update the texture state to match the filtering, mipmap and wrap options currently set.</para>
            <para>If force is true, all properties will be updated regardless of weither they have changed or not.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGTexture.ConvertToNormalizedSourceRect(QtCore.QRectF)">
            <summary>
            <para>Returns rect converted to normalized coordinates.</para>
            <para>See also normalizedTextureSubRect().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.MipmapFiltering">
            <summary>
            <para>Returns whether mipmapping should be used when sampling from this texture.</para>
            <para>See also setMipmapFiltering().</para>
            <para></para>
            <para>Sets the mipmap sampling mode to be used for the upcoming bind() call to filter.</para>
            <para>Setting the mipmap filtering has no effect it the texture does not have mipmaps.</para>
            <para>See also mipmapFiltering() and hasMipmaps().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.filtering">
            <summary>
            <para>Returns the sampling mode to be used for this texture.</para>
            <para>See also setFiltering().</para>
            <para></para>
            <para>Sets the sampling mode to be used for the upcoming bind() call to filter.</para>
            <para>See also filtering().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.HorizontalWrapMode">
            <summary>
            <para>Returns the horizontal wrap mode to be used for this texture.</para>
            <para>See also setHorizontalWrapMode().</para>
            <para></para>
            <para>Sets the horizontal wrap mode to be used for the upcoming bind() call to hwrap</para>
            <para>See also horizontalWrapMode().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.VerticalWrapMode">
            <summary>
            <para>Returns the vertical wrap mode to be used for this texture.</para>
            <para>See also setVerticalWrapMode().</para>
            <para></para>
            <para>Sets the vertical wrap mode to be used for the upcoming bind() call to vwrap</para>
            <para>See also verticalWrapMode().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.TextureId">
            <summary>
            <para>Returns the OpenGL texture id for this texture.</para>
            <para>The default value is 0, indicating that it is an invalid texture id.</para>
            <para>The function should at all times return the correct texture id.</para>
            <para>Warning: This function can only be called from the rendering thread.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.TextureSize">
            <summary>
            <para>Returns the size of the texture.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.HasAlphaChannel">
            <summary>
            <para>Returns true if the texture data contains an alpha channel.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.HasMipmaps">
            <summary>
            <para>Returns true if the texture data contains mipmap levels.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.NormalizedTextureSubRect">
            <summary>
            <para>Returns the rectangle inside textureSize() that this texture represents in normalized coordinates.</para>
            <para>The default implementation returns a rect at position (0, 0) with width and height of 1.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.IsAtlasTexture">
            <summary>
            <para>Returns weither this texture is part of an atlas or not.</para>
            <para>The default implementation returns false.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTexture.RemovedFromAtlas">
            <summary>
            <para>This function returns a copy of the current texture which is removed from its atlas.</para>
            <para>The current texture remains unchanged, so texture coordinates do not need to be updated.</para>
            <para>Removing a texture from an atlas is primarily useful when passing it to a shader that operates on the texture coordinates 0-1 instead of the texture subrect inside the atlas.</para>
            <para>If the texture is not part of a texture atlas, this function returns 0.</para>
            <para>Implementations of this function are recommended to return the same instance for multiple calls to limit memory usage.</para>
            <para>Warning: This function can only be called from the rendering thread.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGTexture.WrapMode">
            <summary>
            <para>Specifies how the texture should treat texture coordinates.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGTexture.WrapMode.Repeat">
            <summary>Only the factional part of the texture coordiante is used, causing values above 1 and below 0 to repeat.</summary>
        </member>
        <member name="F:QtQuick.QSGTexture.WrapMode.ClampToEdge">
            <summary>Values above 1 are clamped to 1 and values below 0 are clamped to 0.</summary>
        </member>
        <member name="T:QtQuick.QSGTexture.Filtering">
            <summary>
            <para>Specifies how sampling of texels should filter when texture coordinates are not pixel aligned.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGTexture.Filtering.None">
            <summary>No filtering should occur. This value is only used together with setMipmapFiltering().</summary>
        </member>
        <member name="F:QtQuick.QSGTexture.Filtering.Nearest">
            <summary>Sampling returns the nearest texel.</summary>
        </member>
        <member name="F:QtQuick.QSGTexture.Filtering.Linear">
            <summary>Sampling returns a linear interpolation of the neighboring texels.</summary>
        </member>
        <member name="T:QtQuick.QSGDynamicTexture">
            <summary>
            <para>The QSGDynamicTexture class serves as a baseclass for dynamically changing textures, such as content that is rendered to FBO's.</para>
            </summary>
            <remarks>
            <para>To update the content of the texture, call updateTexture() explicitly. Simply calling bind() will not update the texture.</para>
            <para>Note: All classes with QSG prefix should be used solely on the scene graph's rendering thread. See Scene Graph and Rendering for more information.</para>
            </remarks>
        </member>
        <member name="P:QtQuick.QSGDynamicTexture.UpdateTexture">
            <summary>
            <para>Call this function to explicitly update the dynamic texture. Calling bind() will bind the content that was previously updated.</para>
            <para>The function returns true if the texture was changed as a resul of the update; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGOpaqueTextureMaterial">
            <summary>
            <para>The QSGOpaqueTextureMaterial class provides a convenient way of rendering textured geometry in the scene graph.</para>
            </summary>
            <remarks>
            <para>The opaque textured material will fill every pixel in a geometry with the supplied texture. The material does not respect the opacity of the QSGMaterialShader::RenderState, so opacity nodes in the parent chain of nodes using this material, have no effect.</para>
            <para>The geometry to be rendered with an opaque texture material requires vertices in attribute location 0 and texture coordinates in attribute location 1. The texture coordinate is a 2-dimensional floating-point tuple. The QSGGeometry::defaultAttributes_TexturedPoint2D returns an attribute set compatible with this material.</para>
            <para>The texture to be rendered can be set using setTexture(). How the texture should be rendered can be specified using setMipmapFiltering(), setFiltering(), setHorizontalWrapMode() and setVerticalWrapMode(). The rendering state is set on the texture instance just before it is bound.</para>
            <para>The opaque textured material respects the current matrix and the alpha channel of the texture. It will disregard the accumulated opacity in the scenegraph.</para>
            <para>A texture material must have a texture set before it is used as a material in the scene graph.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGOpaqueTextureMaterial.#ctor">
            <summary>
            <para>Creates a new QSGOpaqueTextureMaterial.</para>
            <para>The default mipmap filtering and filtering mode is set to QSGTexture::Nearest. The default wrap modes is set to QSGTexture::ClampToEdge.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGOpaqueTextureMaterial.Texture">
            <summary>
            <para>Returns this texture material's texture.</para>
            <para>See also setTexture().</para>
            <para></para>
            <para>Sets the texture of this material to texture.</para>
            <para>The material does not take ownership of the texture.</para>
            <para>See also texture().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGOpaqueTextureMaterial.MipmapFiltering">
            <summary>
            <para>Returns this material's mipmap filtering mode.</para>
            <para>The default mipmap mode is QSGTexture::Nearest.</para>
            <para>See also setMipmapFiltering().</para>
            <para></para>
            <para>Sets the mipmap mode to filtering.</para>
            <para>The mipmap filtering mode is set on the texture instance just before the texture is bound for rendering.</para>
            <para>If the texture does not have mipmapping support, enabling mipmapping has no effect.</para>
            <para>See also mipmapFiltering().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGOpaqueTextureMaterial.Filtering">
            <summary>
            <para>Returns this material's filtering mode.</para>
            <para>The default filtering is QSGTexture::Nearest.</para>
            <para>See also setFiltering().</para>
            <para></para>
            <para>Sets the filtering to filtering.</para>
            <para>The filtering mode is set on the texture instance just before the texture is bound for rendering.</para>
            <para>See also filtering().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGOpaqueTextureMaterial.HorizontalWrapMode">
            <summary>
            <para>Returns this material's horizontal wrap mode.</para>
            <para>The default horizontal wrap mode is QSGTexutre::ClampToEdge.</para>
            <para>See also setHorizontalWrapMode().</para>
            <para></para>
            <para>Sets the horizontal wrap mode to mode.</para>
            <para>The horizontal wrap mode is set on the texture instance just before the texture is bound for rendering.</para>
            <para>See also horizontalWrapMode().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGOpaqueTextureMaterial.VerticalWrapMode">
            <summary>
            <para>Returns this material's vertical wrap mode.</para>
            <para>The default vertical wrap mode is QSGTexutre::ClampToEdge.</para>
            <para>See also setVerticalWrapMode().</para>
            <para></para>
            <para>Sets the vertical wrap mode to mode.</para>
            <para>The vertical wrap mode is set on the texture instance just before the texture is bound for rendering.</para>
            <para>See also verticalWrapMode().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGTextureMaterial">
            <summary>
            <para>The QSGTextureMaterial class provides a convenient way of rendering textured geometry in the scene graph.</para>
            </summary>
            <remarks>
            <para>The textured material will fill every pixel in a geometry with the supplied texture.</para>
            <para>The geometry to be rendered with a texture material requires vertices in attribute location 0 and texture coordinates in attribute location 1. The texture coordinate is a 2-dimensional floating-point tuple. The QSGGeometry::defaultAttributes_TexturedPoint2D returns an attribute set compatible with this material.</para>
            <para>The texture to be rendered can be set using setTexture(). How the texture should be rendered can be specified using setMipmapFiltering(), setFiltering(), setHorizontalWrapMode() and setVerticalWrapMode(). The rendering state is set on the texture instance just before it is bound.</para>
            <para>The textured material respects the current matrix and the alpha channel of the texture. It will also respect the accumulated opacity in the scenegraph.</para>
            <para>A texture material must have a texture set before it is used as a material in the scene graph.</para>
            </remarks>
        </member>
        <member name="T:QtQuick.QSGSimpleTextureNode">
            <summary>
            <para>The QSGSimpleTextureNode class is provided for convenience to easily draw textured content using the QML scene graph.</para>
            </summary>
            <remarks>
            <para>Warning: The simple texture node class must have a texture before being added to the scene graph to be rendered.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGSimpleTextureNode.#ctor">
            <summary>
            <para>Constructs a new simple texture node</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGSimpleTextureNode.SetRect(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the rectangle of this texture node to begin at (x, y) and have width w and height h.</para>
            </summary>
        </member>
        <member name="M:QtQuick.QSGSimpleTextureNode.SetSourceRect(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the rectangle of this texture node to show its texture from (x, y) and have width w and height h relatively to the QSGTexture::textureSize.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleTextureNode.Rect">
            <summary>
            <para>Returns the target rect of this texture node.</para>
            <para>See also setRect().</para>
            <para></para>
            <para>Sets the target rect of this texture node to r.</para>
            <para>See also rect().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleTextureNode.SourceRect">
            <summary>
            <para>Returns the source rect of this texture node.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            <para>See also setSourceRect().</para>
            <para></para>
            <para>Sets the source rect of this texture node to r.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            <para>See also sourceRect().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleTextureNode.Texture">
            <summary>
            <para>Returns the texture for this texture node</para>
            <para>See also setTexture().</para>
            <para></para>
            <para>Sets the texture of this texture node to texture.</para>
            <para>Use setOwnsTexture() to set whether the node should take ownership of the texture. By default, the node does not take ownership.</para>
            <para>Warning: A texture node must have a texture before being added to the scenegraph to be rendered.</para>
            <para>See also texture().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleTextureNode.Filtering">
            <summary>
            <para>Returns the filtering currently set on this texture node</para>
            <para>See also setFiltering().</para>
            <para></para>
            <para>Sets the filtering to be used for this texture node to filtering.</para>
            <para>For smooth scaling, use QSGTexture::Linear; for normal scaling, use QSGTexture::Nearest.</para>
            <para>See also filtering().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleTextureNode.TextureCoordinatesTransform">
            <summary>
            <para>Returns the mode used to generate texture coordinates for this node.</para>
            <para>See also setTextureCoordinatesTransform().</para>
            <para></para>
            <para>Sets the method used to generate texture coordinates to mode. This can be used to obtain correct orientation of the texture. This is commonly needed when using a third party OpenGL library to render to texture as OpenGL has an inverted y-axis relative to Qt Quick.</para>
            <para>See also textureCoordinatesTransform().</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGSimpleTextureNode.OwnsTexture">
            <summary>
            <para>Returns true if the node takes ownership of the texture; otherwise returns false.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            <para>See also setOwnsTexture().</para>
            <para></para>
            <para>Sets whether the node takes ownership of the texture to owns.</para>
            <para>By default, the node does not take ownership of the texture.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            <para>See also ownsTexture() and setTexture().</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGSimpleTextureNode.TextureCoordinatesTransformFlag">
            <summary>
            <para>The TextureCoordinatesTransformFlag enum is used to specify the mode used to generate texture coordinates for a textured quad.</para>
            <para>The TextureCoordinatesTransformMode type is a typedef for QFlags&lt;TextureCoordinatesTransformFlag&gt;. It stores an OR combination of TextureCoordinatesTransformFlag values.</para>
            </summary>
        </member>
        <member name="F:QtQuick.QSGSimpleTextureNode.TextureCoordinatesTransformFlag.NoTransform">
            <summary>Texture coordinates are oriented with window coordinates i.e. with origin at top-left.</summary>
        </member>
        <member name="F:QtQuick.QSGSimpleTextureNode.TextureCoordinatesTransformFlag.MirrorHorizontally">
            <summary>Texture coordinates are inverted in the horizontal axis with respect to window coordinates</summary>
        </member>
        <member name="F:QtQuick.QSGSimpleTextureNode.TextureCoordinatesTransformFlag.MirrorVertically">
            <summary>Texture coordinates are inverted in the vertical axis with respect to window coordinates</summary>
        </member>
        <member name="T:QtQuick.QSGTextureProvider">
            <summary>
            <para>The QSGTextureProvider class encapsulates texture based entities in QML.</para>
            </summary>
            <remarks>
            <para>The QSGTextureProvider lives primarily in the scene graph rendering thread.</para>
            <para></para>
            <para>See also Scene Graph - Two Texture Providers.</para>
            </remarks>
        </member>
        <member name="E:QtQuick.QSGTextureProvider.TextureChanged">
            <summary>
            <para>This signal is emitted when the texture changes.</para>
            </summary>
        </member>
        <member name="P:QtQuick.QSGTextureProvider.Texture">
            <summary>
            <para>Returns a pointer to the texture object.</para>
            </summary>
        </member>
        <member name="T:QtQuick.QSGVertexColorMaterial">
            <summary>
            <para>The QSGVertexColorMaterial class provides a convenient way of rendering per-vertex colored geometry in the scene graph.</para>
            </summary>
            <remarks>
            <para>The vertex color material will give each vertex in a geometry a color. Pixels between vertices will be linearly interpolated. The colors can contain transparency.</para>
            <para>The geometry to be rendered with vertex color must have the following layout. Attribute position 0 must contain vertices. Attribute position 1 must contain colors, a tuple of 4 values with RGBA layout. Both floats in the range of 0 to 1 and unsigned bytes in the range 0 to 255 are valid for the color values.</para>
            <para>Note: The rendering pipeline expects pixels with premultiplied alpha.</para>
            <para>QSGGeometry::defaultAttributes_ColoredPoint2D() can be used to construct an attribute set that is compatible with this material.</para>
            <para>The vertex color material respects both current opacity and current matrix when updating it's rendering state.</para>
            </remarks>
        </member>
        <member name="M:QtQuick.QSGVertexColorMaterial.#ctor">
            <summary>
            <para>Creates a new vertex color material.</para>
            </summary>
        </member>
    </members>
</doc>
