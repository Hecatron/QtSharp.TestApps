<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QtNetworkSharp</name>
    </assembly>
    <members>
        <member name="T:QtNetwork.QNetworkRequest">
            <summary>
            <para>The QNetworkRequest class holds a request to be sent with QNetworkAccessManager.</para>
            </summary>
            <remarks>
            <para>QNetworkRequest is part of the Network Access API and is the class holding the information necessary to send a request over the network. It contains a URL and some ancillary information that can be used to modify the request.</para>
            <para></para>
            <para>See also QNetworkReply and QNetworkAccessManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.#ctor(QtCore.QUrl)">
            <summary>
            <para>Constructs a QNetworkRequest object with url as the URL to be requested.</para>
            <para>See also url() and setUrl().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.#ctor(QtNetwork.QNetworkRequest)">
            <summary>
            <para>Creates a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.#ctor">
            <summary>
            <para>Constructs a QNetworkRequest object with url as the URL to be requested.</para>
            <para>See also url() and setUrl().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.Swap(QtNetwork.QNetworkRequest)">
            <summary>
            <para>Swaps this network request with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.op_Equality(QtNetwork.QNetworkRequest,QtNetwork.QNetworkRequest)">
            <summary>
            <para>Returns true if this object is the same as other (i.e., if they have the same URL, same headers and same meta-data settings).</para>
            <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.op_Inequality(QtNetwork.QNetworkRequest,QtNetwork.QNetworkRequest)">
            <summary>
            <para>Returns false if this object is not the same as other.</para>
            <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.Header(QtNetwork.QNetworkRequest.KnownHeaders)">
            <summary>
            <para>Returns the value of the known network header header if it is present in this request. If it is not present, returns QVariant() (i.e., an invalid variant).</para>
            <para>See also KnownHeaders, rawHeader(), and setHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.SetHeader(QtNetwork.QNetworkRequest.KnownHeaders,QtCore.QVariant)">
            <summary>
            <para>Sets the value of the known header header to be value, overriding any previously set headers. This operation also sets the equivalent raw HTTP header.</para>
            <para>See also KnownHeaders, setRawHeader(), and header().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.HasRawHeader(QtCore.QByteArray)">
            <summary>
            <para>Returns true if the raw header headerName is present in this network request.</para>
            <para>See also rawHeader() and setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.RawHeader(QtCore.QByteArray)">
            <summary>
            <para>Returns the raw form of header headerName. If no such header is present, an empty QByteArray is returned, which may be indistinguishable from a header that is present but has no content (use hasRawHeader() to find out if the header exists or not).</para>
            <para>Raw headers can be set with setRawHeader() or with setHeader().</para>
            <para>See also header() and setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.SetRawHeader(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
            <para>Sets the header headerName to be of value headerValue. If headerName corresponds to a known header (see QNetworkRequest::KnownHeaders), the raw format will be parsed and the corresponding &quot;cooked&quot; header will be set as well.</para>
            <para>For example:</para>
            <para>request.setRawHeader(QByteArray(&quot;Last-Modified&quot;), QByteArray(&quot;Sun, 06 Nov 1994 08:49:37 GMT&quot;));</para>
            <para>will also set the known header LastModifiedHeader to be the QDateTime object of the parsed date.</para>
            <para>Note: Setting the same header twice overrides the previous setting. To accomplish the behaviour of multiple HTTP headers of the same name, you should concatenate the two values, separating them with a comma (&quot;,&quot;) and set one single raw header.</para>
            <para>See also KnownHeaders, setHeader(), hasRawHeader(), and rawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.attribute(QtNetwork.QNetworkRequest.Attribute,QtCore.QVariant)">
            <summary>
            <para>Returns the attribute associated with the code code. If the attribute has not been set, it returns defaultValue.</para>
            <para>Note: This function does not apply the defaults listed in QNetworkRequest::Attribute.</para>
            <para>See also setAttribute() and QNetworkRequest::Attribute.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkRequest.SetAttribute(QtNetwork.QNetworkRequest.Attribute,QtCore.QVariant)">
            <summary>
            <para>Sets the attribute associated with code code to be value value. If the attribute is already set, the previous value is discarded. In special, if value is an invalid QVariant, the attribute is unset.</para>
            <para>See also attribute() and QNetworkRequest::Attribute.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.Url">
            <summary>
            <para>Returns the URL this network request is referring to.</para>
            <para>See also setUrl().</para>
            <para></para>
            <para>Sets the URL this network request is referring to be url.</para>
            <para>See also url().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.SslConfiguration">
            <summary>
            <para>Returns this network request's SSL configuration. By default, no SSL settings are specified.</para>
            <para>See also setSslConfiguration().</para>
            <para></para>
            <para>Sets this network request's SSL configuration to be config. The settings that apply are the private key, the local certificate, the SSL protocol (SSLv2, SSLv3, TLSv1.0 where applicable), the CA certificates and the ciphers that the SSL backend is allowed to use.</para>
            <para>By default, no SSL configuration is set, which allows the backends to choose freely what configuration is best for them.</para>
            <para>See also sslConfiguration() and QSslConfiguration::defaultConfiguration().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.OriginatingObject">
            <summary>
            <para>Returns a reference to the object that initiated this network request; returns 0 if not set or the object has been destroyed.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also setOriginatingObject().</para>
            <para></para>
            <para>Allows setting a reference to the object initiating the request.</para>
            <para>For example Qt WebKit sets the originating object to the QWebFrame that initiated the request.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also originatingObject().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkRequest.priority">
            <summary>
            <para>Return the priority of this request.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setPriority().</para>
            <para></para>
            <para>Set the priority of this request to priority.</para>
            <para>Note: The priority is only a hint to the network access manager. It can use it or not. Currently it is used for HTTP to decide which request should be sent first to a server.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also priority().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.KnownHeaders">
            <summary>
            <para>List of known header types that QNetworkRequest parses. Each known header is also represented in raw form with its full HTTP name.</para>
            <para>See also header(), setHeader(), rawHeader(), and setRawHeader().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.ContentTypeHeader">
            <summary>Corresponds to the HTTP Content-Type header and contains a string containing the media (MIME) type and any auxiliary data (for instance, charset).</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.ContentLengthHeader">
            <summary>Corresponds to the HTTP Content-Length header and contains the length in bytes of the data transmitted.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.LocationHeader">
            <summary>Corresponds to the HTTP Location header and contains a URL representing the actual location of the data, including the destination URL in case of redirections.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.LastModifiedHeader">
            <summary>Corresponds to the HTTP Last-Modified header and contains a QDateTime representing the last modification date of the contents.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:QtNetwork.QNetworkRequest.KnownHeaders.CookieHeader" -->
        <!-- Badly formed XML comment ignored for member "F:QtNetwork.QNetworkRequest.KnownHeaders.SetCookieHeader" -->
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.ContentDispositionHeader">
            <summary>Corresponds to the HTTP Content-Disposition header and contains a string containing the disposition type (for instance, attachment) and a parameter (for instance, filename).</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.UserAgentHeader">
            <summary>The User-Agent header sent by HTTP clients.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.KnownHeaders.ServerHeader">
            <summary>The Server header received by HTTP clients.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.Attribute">
            <summary>
            <para>Attribute codes for the QNetworkRequest and QNetworkReply.</para>
            <para>Attributes are extra meta-data that are used to control the behavior of the request and to pass further information from the reply back to the application. Attributes are also extensible, allowing custom implementations to pass custom values.</para>
            <para>The following table explains what the default attribute codes are, the QVariant types associated, the default value if said attribute is missing and whether it's used in requests or replies.</para>
            <para>This enum was introduced or modified in  Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpStatusCodeAttribute">
            <summary>Replies only, type: QMetaType::Int (no default) Indicates the HTTP status code received from the HTTP server (like 200, 304, 404, 401, etc.). If the connection was not HTTP-based, this attribute will not be present.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpReasonPhraseAttribute">
            <summary>Replies only, type: QMetaType::QByteArray (no default) Indicates the HTTP reason phrase as received from the HTTP server (like "Ok", "Found", "Not Found", "Access Denied", etc.) This is the human-readable representation of the status code (see above). If the connection was not HTTP-based, this attribute will not be present.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.RedirectionTargetAttribute">
            <summary>Replies only, type: QMetaType::QUrl (no default) If present, it indicates that the server is redirecting the request to a different URL. The Network Access API does not by default follow redirections: it's up to the application to determine if the requested redirection should be allowed, according to its security policies. The returned URL might be relative. Use QUrl::resolved() to create an absolute URL out of it.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.ConnectionEncryptedAttribute">
            <summary>Replies only, type: QMetaType::Bool (default: false) Indicates whether the data was obtained through an encrypted (secure) connection.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CacheLoadControlAttribute">
            <summary>Requests only, type: QMetaType::Int (default: QNetworkRequest::PreferNetwork) Controls how the cache should be accessed. The possible values are those of QNetworkRequest::CacheLoadControl. Note that the default QNetworkAccessManager implementation does not support caching. However, this attribute may be used by certain backends to modify their requests (for example, for caching proxies).</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CacheSaveControlAttribute">
            <summary>Requests only, type: QMetaType::Bool (default: true) Controls if the data obtained should be saved to cache for future uses. If the value is false, the data obtained will not be automatically cached. If true, data may be cached, provided it is cacheable (what is cacheable depends on the protocol being used).</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.SourceIsFromCacheAttribute">
            <summary>Replies only, type: QMetaType::Bool (default: false) Indicates whether the data was obtained from cache or not.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.DoNotBufferUploadDataAttribute">
            <summary>Requests only, type: QMetaType::Bool (default: false) Indicates whether the QNetworkAccessManager code is allowed to buffer the upload data, e.g. when doing a HTTP POST. When using this flag with sequential upload data, the ContentLengthHeader header must be set.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpPipeliningAllowedAttribute">
            <summary>Requests only, type: QMetaType::Bool (default: false) Indicates whether the QNetworkAccessManager code is allowed to use HTTP pipelining with this request.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.HttpPipeliningWasUsedAttribute">
            <summary>Replies only, type: QMetaType::Bool Indicates whether the HTTP pipelining was used for receiving this reply.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CustomVerbAttribute">
            <summary>Requests only, type: QMetaType::QByteArray Holds the value for the custom HTTP verb to send (destined for usage of other verbs than GET, POST, PUT and DELETE). This verb is set when calling QNetworkAccessManager::sendCustomRequest().</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CookieLoadControlAttribute">
            <summary>Requests only, type: QMetaType::Int (default: QNetworkRequest::Automatic) Indicates whether to send 'Cookie' headers in the request. This attribute is set to false by Qt WebKit when creating a cross-origin XMLHttpRequest where withCredentials has not been set explicitly to true by the Javascript that created the request. See here for more information. (This value was introduced in 4.7.)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.AuthenticationReuseAttribute">
            <summary>Requests only, type: QMetaType::Int (default: QNetworkRequest::Automatic) Indicates whether to use cached authorization credentials in the request, if available. If this is set to QNetworkRequest::Manual and the authentication mechanism is 'Basic' or 'Digest', Qt will not send an an 'Authorization' HTTP header with any cached credentials it may have for the request's URL. This attribute is set to QNetworkRequest::Manual by Qt WebKit when creating a cross-origin XMLHttpRequest where withCredentials has not been set explicitly to true by the Javascript that created the request. See here for more information. (This value was introduced in 4.7.)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.CookieSaveControlAttribute">
            <summary>Requests only, type: QMetaType::Int (default: QNetworkRequest::Automatic) Indicates whether to save 'Cookie' headers received from the server in reply to the request. This attribute is set to false by Qt WebKit when creating a cross-origin XMLHttpRequest where withCredentials has not been set explicitly to true by the Javascript that created the request. See here for more information. (This value was introduced in 4.7.)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.BackgroundRequestAttribute">
            <summary>Type: QMetaType::Bool (default: false) Indicates that this is a background transfer, rather than a user initiated transfer. Depending on the platform, background transfers may be subject to different policies. The QNetworkSession ConnectInBackground property will be set according to this attribute.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.SpdyAllowedAttribute">
            <summary>Requests only, type: QMetaType::Bool (default: false) Indicates whether the QNetworkAccessManager code is allowed to use SPDY with this request. This applies only to SSL requests, and depends on the server supporting SPDY.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.SpdyWasUsedAttribute">
            <summary>Replies only, type: QMetaType::Bool Indicates whether SPDY was used for receiving this reply.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.EmitAllUploadProgressSignalsAttribute">
            <summary>Requests only, type: QMetaType::Bool (default: false) Indicates whether all upload signals should be emitted. By default, the uploadProgress signal is emitted only in 100 millisecond intervals. (This value was introduced in 5.5.)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.User">
            <summary>Special type. Additional information can be passed in QVariants with types ranging from User to UserMax. The default implementation of Network Access will ignore any request attributes in this range and it will not produce any attributes in this range in replies. The range is reserved for extensions of QNetworkAccessManager.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Attribute.UserMax">
            <summary>Special type. See User.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.CacheLoadControl">
            <summary>
            <para>Controls the caching mechanism of QNetworkAccessManager.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.AlwaysNetwork">
            <summary>always load from network and do not check if the cache has a valid entry (similar to the "Reload" feature in browsers); in addition, force intermediate caches to re-validate.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.PreferNetwork">
            <summary>default value; load from the network if the cached entry is older than the network entry. This will never return stale data from the cache, but revalidate resources that have become stale.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.PreferCache">
            <summary>load from cache if available, otherwise load from network. Note that this can return possibly stale (but not expired) items from cache.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.CacheLoadControl.AlwaysCache">
            <summary>only load from cache, indicating error if the item was not cached (i.e., off-line mode)</summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.LoadControl">
            <summary>
            <para>Indicates if an aspect of the request's loading mechanism has been manually overridden, e.g. by Qt WebKit.</para>
            <para>This enum was introduced or modified in  Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.LoadControl.Automatic">
            <summary>default value: indicates default behaviour.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.LoadControl.Manual">
            <summary>indicates behaviour has been manually overridden.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkRequest.Priority">
            <summary>
            <para>This enum lists the possible network request priorities.</para>
            <para>This enum was introduced or modified in  Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Priority.HighPriority">
            <summary>High priority</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Priority.NormalPriority">
            <summary>Normal priority</summary>
        </member>
        <member name="F:QtNetwork.QNetworkRequest.Priority.LowPriority">
            <summary>Low priority</summary>
        </member>
        <member name="T:QtNetwork.QNetworkCacheMetaData">
            <summary>
            <para>The QNetworkCacheMetaData class provides cache information.</para>
            </summary>
            <remarks>
            <para>QNetworkCacheMetaData provides information about a cache file including the url, when it was last modified, when the cache file was created, headers for file and if the file should be saved onto a disk.</para>
            <para></para>
            <para>See also QAbstractNetworkCache.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.#ctor">
            <summary>
            <para>Constructs an invalid network cache meta data.</para>
            <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.#ctor(QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Constructs a copy of the other QNetworkCacheMetaData.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.Swap(QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Swaps this metadata instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.op_Equality(QtNetwork.QNetworkCacheMetaData,QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Returns true if this meta data is equal to the other meta data; otherwise returns false.</para>
            <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCacheMetaData.op_Inequality(QtNetwork.QNetworkCacheMetaData,QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Returns true if this meta data is not equal to the other meta data; otherwise returns false.</para>
            <para>See also operator==().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.Url">
            <summary>
            <para>Returns the URL this network cache meta data is referring to.</para>
            <para>See also setUrl().</para>
            <para></para>
            <para>Sets the URL this network cache meta data to be url.</para>
            <para>The password and fragment are removed from the url.</para>
            <para>See also url().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.LastModified">
            <summary>
            <para>Returns the date and time when the meta data was last modified.</para>
            <para>See also setLastModified().</para>
            <para></para>
            <para>Sets the date and time when the meta data was last modified to dateTime.</para>
            <para>See also lastModified().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.ExpirationDate">
            <summary>
            <para>Returns the date and time when the meta data expires.</para>
            <para>See also setExpirationDate().</para>
            <para></para>
            <para>Sets the date and time when the meta data expires to dateTime.</para>
            <para>See also expirationDate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.SaveToDisk">
            <summary>
            <para>Returns is this cache should be allowed to be stored on disk.</para>
            <para>Some cache implementations can keep these cache items in memory for performance reasons, but for security reasons they should not be written to disk.</para>
            <para>Specifically with http, documents marked with Pragma: no-cache, or have a Cache-control set to no-store or no-cache or any https document that doesn't have &quot;Cache-control: public&quot; set will set the saveToDisk to false.</para>
            <para>See also setSaveToDisk().</para>
            <para></para>
            <para>Sets whether this network cache meta data and associated content should be allowed to be stored on disk to allow.</para>
            <para>See also saveToDisk().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCacheMetaData.IsValid">
            <summary>
            <para>Returns true if this network cache meta data has attributes that have been set otherwise false.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractNetworkCache">
            <summary>
            <para>The QAbstractNetworkCache class provides the interface for cache implementations.</para>
            </summary>
            <remarks>
            <para>QAbstractNetworkCache is the base class for every standard cache that is used by QNetworkAccessManager. QAbstractNetworkCache is an abstract class and cannot be instantiated.</para>
            <para></para>
            <para>See also QNetworkDiskCache.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs an abstract network cache with the given parent.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.MetaData(QtCore.QUrl)">
            <summary>
            <para>Returns the meta data for the url url.</para>
            <para>If the url is valid and the cache contains the data for url, a valid QNetworkCacheMetaData is returned.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also updateMetaData() and data().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.UpdateMetaData(QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Updates the cache meta date for the metaData's url to metaData</para>
            <para>If the cache does not contains a cache item for the url then no action is taken.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also metaData() and prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Data(QtCore.QUrl)">
            <summary>
            <para>Returns the data associated with url.</para>
            <para>It is up to the application that requests the data to delete the QIODevice when done with it.</para>
            <para>If there is no cache for url, the url is invalid, or if there is an internal cache error 0 is returned.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also metaData() and prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Remove(QtCore.QUrl)">
            <summary>
            <para>Removes the cache entry for url, returning true if success otherwise false.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also clear() and prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Prepare(QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Returns the device that should be populated with the data for the cache item metaData. When all of the data has been written insert() should be called. If metaData is invalid or the url in the metadata is invalid 0 is returned.</para>
            <para>The cache owns the device and will take care of deleting it when it is inserted or removed.</para>
            <para>To cancel a prepared inserted call remove() on the metadata's url.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also remove(), updateMetaData(), and insert().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Insert(QtCore.QIODevice)">
            <summary>
            <para>Inserts the data in device and the prepared meta data into the cache. After this function is called the data and meta data should be retrievable using data() and metaData().</para>
            <para>To cancel a prepared inserted call remove() on the metadata's url.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also prepare() and remove().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractNetworkCache.Clear">
            <summary>
            <para>Removes all items from the cache. Unless there was failures clearing the cache cacheSize() should return 0 after a call to clear.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also cacheSize() and remove().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractNetworkCache.CacheSize">
            <summary>
            <para>Returns the current size taken up by the cache. Depending upon the cache implementation this might be disk or memory size.</para>
            <para>In the base class this is a pure virtual function.</para>
            <para>See also clear().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpPart">
            <summary>
            <para>The QHttpPart class holds a body part to be used inside a HTTP multipart MIME message.</para>
            </summary>
            <remarks>
            <para>The QHttpPart class holds a body part to be used inside a HTTP multipart MIME message (which is represented by the QHttpMultiPart class). A QHttpPart consists of a header block and a data block, which are separated by each other by two consecutive new lines. An example for one part would be:</para>
            <para>Content-Type: text/plain</para>
            <para>Content-Disposition: form-data; name=&quot;text&quot;</para>
            <para></para>
            <para>here goes the body</para>
            <para>For setting headers, use setHeader() and setRawHeader(), which behave exactly like QNetworkRequest::setHeader() and QNetworkRequest::setRawHeader().</para>
            <para>For reading small pieces of data, use setBody(); for larger data blocks like e.g. images, use setBodyDevice(). The latter method saves memory by not copying the data internally, but reading directly from the device. This means that the device must be opened and readable at the moment when the multipart message containing the body part is sent on the network via QNetworkAccessManager::post().</para>
            <para>To construct a QHttpPart with a small body, consider the following snippet (this produces the data shown in the example above):</para>
            <para>QHttpPart textPart;</para>
            <para>textPart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant(&quot;text/plain&quot;));</para>
            <para>textPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant(&quot;form-data; name=\&quot;text\&quot;&quot;));</para>
            <para>textPart.setBody(&quot;here goes the body&quot;);</para>
            <para>To construct a QHttpPart reading from a device (e.g. a file), the following can be applied:</para>
            <para>QHttpPart imagePart;</para>
            <para>imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant(&quot;image/jpeg&quot;));</para>
            <para>imagePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant(&quot;form-data; name=\&quot;image\&quot;&quot;));</para>
            <para>imagePart.setRawHeader(&quot;Content-ID&quot;, &quot;my@content.id&quot;); // add any headers you like via setRawHeader()</para>
            <para>QFile *file = new QFile(&quot;image.jpg&quot;);</para>
            <para>file-&gt;open(QIODevice::ReadOnly);</para>
            <para>imagePart.setBodyDevice(file);</para>
            <para>Be aware that QHttpPart does not take ownership of the device when set, so it is the developer's responsibility to destroy it when it is not needed anymore. A good idea might be to set the multipart message as parent object for the device, as documented at the documentation for QHttpMultiPart.</para>
            <para></para>
            <para>See also QHttpMultiPart and QNetworkAccessManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttpPart.#ctor">
            <summary>
            <para>Constructs an empty QHttpPart object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.#ctor(QtNetwork.QHttpPart)">
            <summary>
            <para>Creates a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.Swap(QtNetwork.QHttpPart)">
            <summary>
            <para>Swaps this HTTP part with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.op_Equality(QtNetwork.QHttpPart,QtNetwork.QHttpPart)">
            <summary>
            <para>Returns true if this object is the same as other (i.e., if they have the same headers and body).</para>
            <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.op_Inequality(QtNetwork.QHttpPart,QtNetwork.QHttpPart)">
            <summary>
            <para>Returns true if this object is not the same as other.</para>
            <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetHeader(QtNetwork.QNetworkRequest.KnownHeaders,QtCore.QVariant)">
            <summary>
            <para>Sets the value of the known header header to be value, overriding any previously set headers.</para>
            <para>See also QNetworkRequest::KnownHeaders, setRawHeader(), and QNetworkRequest::setHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetRawHeader(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
            <para>Sets the header headerName to be of value headerValue. If headerName corresponds to a known header (see QNetworkRequest::KnownHeaders), the raw format will be parsed and the corresponding &quot;cooked&quot; header will be set as well.</para>
            <para>Note: Setting the same header twice overrides the previous setting. To accomplish the behaviour of multiple HTTP headers of the same name, you should concatenate the two values, separating them with a comma (&quot;,&quot;) and set one single raw header.</para>
            <para>See also QNetworkRequest::KnownHeaders, setHeader(), and QNetworkRequest::setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetBody(QtCore.QByteArray)">
            <summary>
            <para>Sets the body of this MIME part to body. The body set with this method will be used unless the device is set via setBodyDevice(). For a large amount of data (e.g. an image), use setBodyDevice(), which will not copy the data internally.</para>
            <para>See also setBodyDevice().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpPart.SetBodyDevice(QtCore.QIODevice)">
            <summary>
            <para>Sets the device to read the content from to device. For large amounts of data this method should be preferred over setBody(), because the content is not copied when using this method, but read directly from the device. device must be open and readable. QHttpPart does not take ownership of device, i.e. the device must be closed and destroyed if necessary. if device is sequential (e.g. sockets, but not files), QNetworkAccessManager::post() should be called after device has emitted finished(). For unsetting the device and using data set via setBody(), use &quot;setBodyDevice(0)&quot;.</para>
            <para>See also setBody() and QNetworkAccessManager::post().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpMultiPart">
            <summary>
            <para>The QHttpMultiPart class resembles a MIME multipart message to be sent over HTTP.</para>
            </summary>
            <remarks>
            <para>The QHttpMultiPart resembles a MIME multipart message, as described in RFC 2046, which is to be sent over HTTP. A multipart message consists of an arbitrary number of body parts (see QHttpPart), which are separated by a unique boundary. The boundary of the QHttpMultiPart is constructed with the string &quot;boundary_.oOo._&quot; followed by random characters, and provides enough uniqueness to make sure it does not occur inside the parts itself. If desired, the boundary can still be set via setBoundary().</para>
            <para>As an example, consider the following code snippet, which constructs a multipart message containing a text part followed by an image part:</para>
            <para>QHttpMultiPart *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);</para>
            <para></para>
            <para>QHttpPart textPart;</para>
            <para>textPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant(&quot;form-data; name=\&quot;text\&quot;&quot;));</para>
            <para>textPart.setBody(&quot;my text&quot;);</para>
            <para></para>
            <para>QHttpPart imagePart;</para>
            <para>imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant(&quot;image/jpeg&quot;));</para>
            <para>imagePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant(&quot;form-data; name=\&quot;image\&quot;&quot;));</para>
            <para>QFile *file = new QFile(&quot;image.jpg&quot;);</para>
            <para>file-&gt;open(QIODevice::ReadOnly);</para>
            <para>imagePart.setBodyDevice(file);</para>
            <para>file-&gt;setParent(multiPart); // we cannot delete the file now, so delete it with the multiPart</para>
            <para></para>
            <para>multiPart-&gt;append(textPart);</para>
            <para>multiPart-&gt;append(imagePart);</para>
            <para></para>
            <para>QUrl url(&quot;http://my.server.tld&quot;);</para>
            <para>QNetworkRequest request(url);</para>
            <para></para>
            <para>QNetworkAccessManager manager;</para>
            <para>QNetworkReply *reply = manager.post(request, multiPart);</para>
            <para>multiPart-&gt;setParent(reply); // delete the multiPart with the reply</para>
            <para>// here connect signals etc.</para>
            <para></para>
            <para>See also QHttpPart and QNetworkAccessManager::post().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QHttpMultiPart with content type MixedType and sets parent as the parent object.</para>
            <para>See also QHttpMultiPart::ContentType.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.#ctor(QtNetwork.QHttpMultiPart.ContentType,QtCore.QObject)">
            <summary>
            <para>Constructs a QHttpMultiPart with content type contentType and sets parent as the parent object.</para>
            <para>See also QHttpMultiPart::ContentType.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.Append(QtNetwork.QHttpPart)">
            <summary>
            <para>Appends httpPart to this multipart.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHttpMultiPart.SetContentType(QtNetwork.QHttpMultiPart.ContentType)">
            <summary>
            <para>Sets the content type to contentType. The content type will be used in the HTTP header section when sending the multipart message via QNetworkAccessManager::post(). In case you want to use a multipart subtype not contained in QHttpMultiPart::ContentType, you can add the &quot;Content-Type&quot; header field to the QNetworkRequest by hand, and then use this request together with the multipart message for posting.</para>
            <para>See also QHttpMultiPart::ContentType and QNetworkAccessManager::post().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHttpMultiPart.Boundary">
            <summary>
            <para>returns the boundary.</para>
            <para>See also setBoundary().</para>
            <para></para>
            <para>Sets the boundary to boundary.</para>
            <para>Usually, you do not need to generate a boundary yourself; upon construction the boundary is initiated with the string &quot;boundary_.oOo._&quot; followed by random characters, and provides enough uniqueness to make sure it does not occur inside the parts itself.</para>
            <para>See also boundary().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHttpMultiPart.ContentType">
            <summary>
            <para>List of known content types for a multipart subtype as described in RFC 2046 and others.</para>
            <para>See also setContentType().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.MixedType">
            <summary>corresponds to the "multipart/mixed" subtype, meaning the body parts are independent of each other, as described in RFC 2046.</summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.RelatedType">
            <summary>corresponds to the "multipart/related" subtype, meaning the body parts are related to each other, as described in RFC 2387.</summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.FormDataType">
            <summary>corresponds to the "multipart/form-data" subtype, meaning the body parts contain form elements, as described in RFC 2388.</summary>
        </member>
        <member name="F:QtNetwork.QHttpMultiPart.ContentType.AlternativeType">
            <summary>corresponds to the "multipart/alternative" subtype, meaning the body parts are alternative representations of the same information, as described in RFC 2046.</summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket">
            <summary>
            <para>The QAbstractSocket class provides the base functionality common to all socket types.</para>
            </summary>
            <remarks>
            <para>QAbstractSocket is the base class for QTcpSocket and QUdpSocket and contains all common functionality of these two classes. If you need a socket, you have two options:</para>
            <para></para>
            <para>Instantiate QTcpSocket or QUdpSocket.</para>
            <para>Create a native socket descriptor, instantiate QAbstractSocket, and call setSocketDescriptor() to wrap the native socket.</para>
            <para></para>
            <para>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. UDP (User Datagram Protocol) is an unreliable, datagram-oriented, connectionless protocol. In practice, this means that TCP is better suited for continuous transmission of data, whereas the more lightweight UDP can be used when reliability isn't important.</para>
            <para>QAbstractSocket's API unifies most of the differences between the two protocols. For example, although UDP is connectionless, connectToHost() establishes a virtual connection for UDP sockets, enabling you to use QAbstractSocket in more or less the same way regardless of the underlying protocol. Internally, QAbstractSocket remembers the address and port passed to connectToHost(), and functions like read() and write() use these values.</para>
            <para>At any time, QAbstractSocket has a state (returned by state()). The initial state is UnconnectedState. After calling connectToHost(), the socket first enters HostLookupState. If the host is found, QAbstractSocket enters ConnectingState and emits the hostFound() signal. When the connection has been established, it enters ConnectedState and emits connected(). If an error occurs at any stage, error() is emitted. Whenever the state changes, stateChanged() is emitted. For convenience, isValid() returns true if the socket is ready for reading and writing, but note that the socket's state must be ConnectedState before reading and writing can occur.</para>
            <para>Read or write data by calling read() or write(), or use the convenience functions readLine() and readAll(). QAbstractSocket also inherits getChar(), putChar(), and ungetChar() from QIODevice, which work on single bytes. The bytesWritten() signal is emitted when data has been written to the socket. Note that Qt does not limit the write buffer size. You can monitor its size by listening to this signal.</para>
            <para>The readyRead() signal is emitted every time a new chunk of data has arrived. bytesAvailable() then returns the number of bytes that are available for reading. Typically, you would connect the readyRead() signal to a slot and read all available data there. If you don't read all the data at once, the remaining data will still be available later, and any new incoming data will be appended to QAbstractSocket's internal read buffer. To limit the size of the read buffer, call setReadBufferSize().</para>
            <para>To close the socket, call disconnectFromHost(). QAbstractSocket enters QAbstractSocket::ClosingState. After all pending data has been written to the socket, QAbstractSocket actually closes the socket, enters QAbstractSocket::ClosedState, and emits disconnected(). If you want to abort a connection immediately, discarding all pending data, call abort() instead. If the remote host closes the connection, QAbstractSocket will emit error(QAbstractSocket::RemoteHostClosedError), during which the socket state will still be ConnectedState, and then the disconnected() signal will be emitted.</para>
            <para>The port and address of the connected peer is fetched by calling peerPort() and peerAddress(). peerName() returns the host name of the peer, as passed to connectToHost(). localPort() and localAddress() return the port and address of the local socket.</para>
            <para>QAbstractSocket provides a set of functions that suspend the calling thread until certain signals are emitted. These functions can be used to implement blocking sockets:</para>
            <para></para>
            <para>waitForConnected() blocks until a connection has been established.</para>
            <para>waitForReadyRead() blocks until new data is available for reading.</para>
            <para>waitForBytesWritten() blocks until one payload of data has been written to the socket.</para>
            <para>waitForDisconnected() blocks until the connection has closed.</para>
            <para></para>
            <para>We show an example:</para>
            <para>    int numRead = 0, numReadTotal = 0;</para>
            <para>    char buffer[50];</para>
            <para></para>
            <para>    forever {</para>
            <para>        numRead  = socket.read(buffer, 50);</para>
            <para></para>
            <para>        // do whatever with array</para>
            <para></para>
            <para>        numReadTotal += numRead;</para>
            <para>        if (numRead == 0 &amp;&amp; !socket.waitForReadyRead())</para>
            <para>            break;</para>
            <para>    }</para>
            <para>If waitForReadyRead() returns false, the connection has been closed or an error has occurred.</para>
            <para>Programming with a blocking socket is radically different from programming with a non-blocking socket. A blocking socket doesn't require an event loop and typically leads to simpler code. However, in a GUI application, blocking sockets should only be used in non-GUI threads, to avoid freezing the user interface. See the fortuneclient and blockingfortuneclient examples for an overview of both approaches.</para>
            <para>Note: We discourage the use of the blocking functions together with signals. One of the two possibilities should be used.</para>
            <para>QAbstractSocket can be used with QTextStream and QDataStream's stream operators (operator&lt;&lt;() and operator&gt;&gt;()). There is one issue to be aware of, though: You must make sure that enough data is available before attempting to read it using operator&gt;&gt;().</para>
            <para></para>
            <para>See also QNetworkAccessManager and QTcpServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.#ctor(QtNetwork.QAbstractSocket.SocketType,QtCore.QObject)">
            <summary>
            <para>Creates a new abstract socket of type socketType. The parent argument is passed to QObject's constructor.</para>
            <para>See also socketType(), QTcpSocket, and QUdpSocket.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Resume">
            <summary>
            <para>Continues data transfer on the socket. This method should only be used after the socket has been set to pause upon notifications and a notification has been received. The only notification currently supported is QSslSocket::sslErrors(). Calling this method if the socket is not paused results in undefined behavior.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also pauseMode() and setPauseMode().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Bind(QtNetwork.QHostAddress,System.UInt16,QtNetwork.QAbstractSocket.BindFlag)">
            <summary>
            <para>Binds to address on port port, using the BindMode mode.</para>
            <para>Binds this socket to the address address and the port port.</para>
            <para>For UDP sockets, after binding, the signal QUdpSocket::readyRead() is emitted whenever a UDP datagram arrives on the specified address and port. Thus, This function is useful to write UDP servers.</para>
            <para>For TCP sockets, this function may be used to specify which interface to use for an outgoing connection, which is useful in case of multiple network interfaces.</para>
            <para>By default, the socket is bound using the DefaultForPlatform BindMode. If a port is not specified, a random port is chosen.</para>
            <para>On success, the functions returns true and the socket enters BoundState; otherwise it returns false.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Bind(System.UInt16,QtNetwork.QAbstractSocket.BindFlag)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Binds to QHostAddress:Any on port port, using the BindMode mode.</para>
            <para>By default, the socket is bound using the DefaultForPlatform BindMode. If a port is not specified, a random port is chosen.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ConnectToHost(System.String,System.UInt16,QtCore.QIODevice.OpenModeFlag,QtNetwork.QAbstractSocket.NetworkLayerProtocol)">
            <summary>
            <para>Attempts to make a connection to hostName on the given port. The protocol parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</para>
            <para>The socket is opened in the given openMode and first enters HostLookupState, then performs a host name lookup of hostName. If the lookup succeeds, hostFound() is emitted and QAbstractSocket enters ConnectingState. It then attempts to connect to the address or addresses returned by the lookup. Finally, if a connection is established, QAbstractSocket enters ConnectedState and emits connected().</para>
            <para>At any point, the socket can emit error() to signal that an error occurred.</para>
            <para>hostName may be an IP address in string form (e.g., &quot;43.195.83.32&quot;), or it may be a host name (e.g., &quot;example.com&quot;). QAbstractSocket will do a lookup only if required. port is in native byte order.</para>
            <para>See also state(), peerName(), peerAddress(), peerPort(), and waitForConnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ConnectToHost(QtNetwork.QHostAddress,System.UInt16,QtCore.QIODevice.OpenModeFlag)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Attempts to make a connection to address on port port.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.DisconnectFromHost">
            <summary>
            <para>Attempts to close the socket. If there is pending data waiting to be written, QAbstractSocket will enter ClosingState and wait until all data has been written. Eventually, it will enter UnconnectedState and emit the disconnected() signal.</para>
            <para>See also connectToHost().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.CanReadLine">
            <summary>
            <para>Reimplemented from QIODevice::canReadLine().</para>
            <para>Returns true if a line of data can be read from the socket; otherwise returns false.</para>
            <para>See also readLine().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Abort">
            <summary>
            <para>Aborts the current connection and resets the socket. Unlike disconnectFromHost(), this function immediately closes the socket, discarding any pending data in the write buffer.</para>
            <para>See also disconnectFromHost() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketDescriptor(System.Int32,QtNetwork.QAbstractSocket.SocketState,QtCore.QIODevice.OpenModeFlag)">
            <summary>
            <para>Initializes QAbstractSocket with the native socket descriptor socketDescriptor. Returns true if socketDescriptor is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by openMode, and enters the socket state specified by socketState. Read and write buffers are cleared, discarding any pending data.</para>
            <para>Note: It is not possible to initialize two abstract sockets with the same native socket descriptor.</para>
            <para>See also socketDescriptor().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketOption(QtNetwork.QAbstractSocket.SocketOption,QtCore.QVariant)">
            <summary>
            <para>Sets the given option to the value described by value.</para>
            <para>Note: On Windows Runtime, QAbstractSocket::KeepAliveOption must be set before the socket is connected.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also socketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.socketOption(QtNetwork.QAbstractSocket.SocketOption)">
            <summary>
            <para>Returns the value of the option option.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also setSocketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.Close">
            <summary>
            <para>Reimplemented from QIODevice::close().</para>
            <para>Closes the I/O device for the socket, disconnects the socket's connection with the host, closes the socket, and resets the name, address, port number and underlying socket descriptor.</para>
            <para>See QIODevice::close() for a description of the actions that occur when an I/O device is closed.</para>
            <para>See also abort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForConnected(System.Int32)">
            <summary>
            <para>Waits until the socket is connected, up to msecs milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
            <para>The following example waits up to one second for a connection to be established:</para>
            <para>socket-&gt;connectToHost(&quot;imap&quot;, 143);</para>
            <para>if (socket-&gt;waitForConnected(1000))</para>
            <para>    qDebug(&quot;Connected!&quot;);</para>
            <para>If msecs is -1, this function will not time out.</para>
            <para>Note: This function may wait slightly longer than msecs, depending on the time it takes to complete the host lookup.</para>
            <para>Note: Multiple calls to this functions do not accumulate the time. If the function times out, the connecting process will be aborted.</para>
            <para>Note: This function may fail randomly on Windows. Consider using the event loop and the connected() signal if your software will run on Windows.</para>
            <para>See also connectToHost() and connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForReadyRead(System.Int32)">
            <summary>
            <para>Reimplemented from QIODevice::waitForReadyRead().</para>
            <para>This function blocks until new data is available for reading and the readyRead() signal has been emitted. The function will timeout after msecs milliseconds; the default timeout is 30000 milliseconds.</para>
            <para>The function returns true if the readyRead() signal is emitted and there is new data available for reading; otherwise it returns false (if an error occurred or the operation timed out).</para>
            <para>Note: This function may fail randomly on Windows. Consider using the event loop and the readyRead() signal if your software will run on Windows.</para>
            <para>See also waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForBytesWritten(System.Int32)">
            <summary>
            <para>Reimplemented from QIODevice::waitForBytesWritten().</para>
            <para>This function blocks until at least one byte has been written on the socket and the bytesWritten() signal has been emitted. The function will timeout after msecs milliseconds; the default timeout is 30000 milliseconds.</para>
            <para>The function returns true if the bytesWritten() signal is emitted; otherwise it returns false (if an error occurred or the operation timed out).</para>
            <para>Note: This function may fail randomly on Windows. Consider using the event loop and the bytesWritten() signal if your software will run on Windows.</para>
            <para>See also waitForReadyRead().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WaitForDisconnected(System.Int32)">
            <summary>
            <para>Waits until the socket has disconnected, up to msecs milliseconds. If the connection has been disconnected, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
            <para>The following example waits up to one second for a connection to be closed:</para>
            <para>socket-&gt;disconnectFromHost();</para>
            <para>    if (socket-&gt;state() == QAbstractSocket::UnconnectedState ||</para>
            <para>        socket-&gt;waitForDisconnected(1000))</para>
            <para>        qDebug(&quot;Disconnected!&quot;);</para>
            <para>If msecs is -1, this function will not time out.</para>
            <para>Note: This function may fail randomly on Windows. Consider using the event loop and the disconnected() signal if your software will run on Windows.</para>
            <para>See also disconnectFromHost() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ReadData(System.Char*,System.Int64)">
            <summary>
            <para>Reimplemented from QIODevice::readData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.ReadLineData(System.Char*,System.Int64)">
            <summary>
            <para>Reimplemented from QIODevice::readLineData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.WriteData(System.String,System.Int64)">
            <summary>
            <para>Reimplemented from QIODevice::writeData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketState(QtNetwork.QAbstractSocket.SocketState)">
            <summary>
            <para>Sets the state of the socket to state.</para>
            <para>See also state().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAbstractSocket.SetSocketError(QtNetwork.QAbstractSocket.SocketError)">
            <summary>
            <para>Sets the type of error that last occurred to socketError.</para>
            <para>See also setSocketState() and setErrorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.HostFound">
            <summary>
            <para>This signal is emitted after connectToHost() has been called and the host lookup has succeeded.</para>
            <para>Note: Since Qt 4.6.3 QAbstractSocket may emit hostFound() directly from the connectToHost() call since a DNS result could have been cached.</para>
            <para>See also connected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.Connected">
            <summary>
            <para>This signal is emitted after connectToHost() has been called and a connection has been successfully established.</para>
            <para>Note: On some operating systems the connected() signal may be directly emitted from the connectToHost() call for connections to the localhost.</para>
            <para>See also connectToHost() and disconnected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.Disconnected">
            <summary>
            <para>This signal is emitted when the socket has been disconnected.</para>
            <para>Warning: If you need to delete the sender() of this signal in a slot connected to it, use the deleteLater() function.</para>
            <para>See also connectToHost(), disconnectFromHost(), and abort().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.StateChanged">
            <summary>
            <para>This signal is emitted whenever QAbstractSocket's state changes. The socketState parameter is the new state.</para>
            <para>QAbstractSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
            <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.ErrorSocketError">
            <summary>
            <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
            <para>When this signal is emitted, the socket may not be ready for a reconnect attempt. In that case, attempts to reconnect should be done from the event loop. For example, use a QTimer::singleShot() with 0 as the timeout.</para>
            <para>QAbstractSocket::SocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
            <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QAbstractSocket.ProxyAuthenticationRequired">
            <summary>
            <para>This signal can be emitted when a proxy that requires authentication is used. The authenticator object can then be filled in with the required details to allow authentication and continue the connection.</para>
            <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
            <para>This function was introduced in  Qt 4.3.</para>
            <para>See also QAuthenticator and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.pauseMode">
            <summary>
            <para>Returns the pause mode of this socket.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also setPauseMode() and resume().</para>
            <para></para>
            <para>Controls whether to pause upon receiving a notification. The pauseMode parameter specifies the conditions in which the socket should be paused. The only notification currently supported is QSslSocket::sslErrors(). If set to PauseOnSslErrors, data transfer on the socket will be paused and needs to be enabled explicitly again by calling resume(). By default this option is set to PauseNever. This option must be called before connecting to the server, otherwise it will result in undefined behavior.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also pauseMode() and resume().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.ReadBufferSize">
            <summary>
            <para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call read() or readAll().</para>
            <para>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</para>
            <para>See also setReadBufferSize() and read().</para>
            <para></para>
            <para>Sets the size of QAbstractSocket's internal read buffer to be size bytes.</para>
            <para>If the buffer size is limited to a certain size, QAbstractSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</para>
            <para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</para>
            <para>Only QTcpSocket uses QAbstractSocket's internal buffer; QUdpSocket does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on QUdpSocket has no effect.</para>
            <para>See also readBufferSize() and read().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.Proxy">
            <summary>
            <para>Returns the network proxy for this socket. By default QNetworkProxy::DefaultProxy is used, which means this socket will query the default proxy settings for the application.</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also setProxy(), QNetworkProxy, and QNetworkProxyFactory.</para>
            <para></para>
            <para>Sets the explicit network proxy for this socket to networkProxy.</para>
            <para>To disable the use of a proxy for this socket, use the QNetworkProxy::NoProxy proxy type:</para>
            <para>socket-&gt;setProxy(QNetworkProxy::NoProxy);</para>
            <para>The default value for the proxy is QNetworkProxy::DefaultProxy, which means the socket will use the application settings: if a proxy is set with QNetworkProxy::setApplicationProxy, it will use that; otherwise, if a factory is set with QNetworkProxyFactory::setApplicationProxyFactory, it will query that factory with type QNetworkProxyQuery::TcpSocket.</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also proxy(), QNetworkProxy, and QNetworkProxyFactory::queryProxy().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.LocalPort">
            <summary>
            <para>Returns the host port number (in native byte order) of the local socket if available; otherwise returns 0.</para>
            <para>See also localAddress(), peerPort(), and setLocalPort().</para>
            <para></para>
            <para>Sets the port on the local side of a connection to port.</para>
            <para>You can call this function in a subclass of QAbstractSocket to change the return value of the localPort() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
            <para>Note that this function does not bind the local port of the socket prior to a connection (e.g., QAbstractSocket::bind()).</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also localPort(), localAddress(), setLocalAddress(), and setPeerPort().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.LocalAddress">
            <summary>
            <para>Returns the host address of the local socket if available; otherwise returns QHostAddress::Null.</para>
            <para>This is normally the main IP address of the host, but can be QHostAddress::LocalHost (127.0.0.1) for connections to the local host.</para>
            <para>See also localPort(), peerAddress(), and setLocalAddress().</para>
            <para></para>
            <para>Sets the address on the local side of a connection to address.</para>
            <para>You can call this function in a subclass of QAbstractSocket to change the return value of the localAddress() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
            <para>Note that this function does not bind the local address of the socket prior to a connection (e.g., QAbstractSocket::bind()).</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also localAddress(), setLocalPort(), and setPeerAddress().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.PeerPort">
            <summary>
            <para>Returns the port of the connected peer if the socket is in ConnectedState; otherwise returns 0.</para>
            <para>See also peerAddress(), localPort(), and setPeerPort().</para>
            <para></para>
            <para>Sets the port of the remote side of the connection to port.</para>
            <para>You can call this function in a subclass of QAbstractSocket to change the return value of the peerPort() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also peerPort(), setPeerAddress(), and setLocalPort().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.PeerAddress">
            <summary>
            <para>Returns the address of the connected peer if the socket is in ConnectedState; otherwise returns QHostAddress::Null.</para>
            <para>See also peerName(), peerPort(), localAddress(), and setPeerAddress().</para>
            <para></para>
            <para>Sets the address of the remote side of the connection to address.</para>
            <para>You can call this function in a subclass of QAbstractSocket to change the return value of the peerAddress() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also peerAddress(), setPeerPort(), and setLocalAddress().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.PeerName">
            <summary>
            <para>Returns the name of the peer as specified by connectToHost(), or an empty QString if connectToHost() has not been called.</para>
            <para>See also peerAddress(), peerPort(), and setPeerName().</para>
            <para></para>
            <para>Sets the host name of the remote peer to name.</para>
            <para>You can call this function in a subclass of QAbstractSocket to change the return value of the peerName() function after a connection has been established. This feature is commonly used by proxy connections for virtual connection settings.</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also peerName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.BytesAvailable">
            <summary>
            <para>Reimplemented from QIODevice::bytesAvailable().</para>
            <para>Returns the number of incoming bytes that are waiting to be read.</para>
            <para>See also bytesToWrite() and read().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.BytesToWrite">
            <summary>
            <para>Reimplemented from QIODevice::bytesToWrite().</para>
            <para>Returns the number of bytes that are waiting to be written. The bytes are written when control goes back to the event loop or when flush() is called.</para>
            <para>See also bytesAvailable() and flush().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.IsSequential">
            <summary>
            <para>Reimplemented from QIODevice::isSequential().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.AtEnd">
            <summary>
            <para>Reimplemented from QIODevice::atEnd().</para>
            <para>Returns true if no more data is currently available for reading; otherwise returns false.</para>
            <para>This function is most commonly used when reading data from the socket in a loop. For example:</para>
            <para> // This slot is connected to QAbstractSocket::readyRead()</para>
            <para> void SocketClass::readyReadSlot()</para>
            <para> {</para>
            <para>     while (!socket.atEnd()) {</para>
            <para>         QByteArray data = socket.read(100);</para>
            <para>         ....</para>
            <para>     }</para>
            <para> }</para>
            <para>See also bytesAvailable() and readyRead().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.IsValid">
            <summary>
            <para>Returns true if the socket is valid and ready for use; otherwise returns false.</para>
            <para>Note: The socket's state must be ConnectedState before reading and writing can occur.</para>
            <para>See also state().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.SocketDescriptor">
            <summary>
            <para>Returns the native socket descriptor of the QAbstractSocket object if this is available; otherwise returns -1.</para>
            <para>If the socket is using QNetworkProxy, the returned descriptor may not be usable with native socket functions.</para>
            <para>The socket descriptor is not available when QAbstractSocket is in UnconnectedState.</para>
            <para>See also setSocketDescriptor().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.socketType">
            <summary>
            <para>Returns the socket type (TCP, UDP, or other).</para>
            <para>See also QTcpSocket and QUdpSocket.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.State">
            <summary>
            <para>Returns the state of the socket.</para>
            <para>See also error().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.Error">
            <summary>
            <para>Returns the type of error that last occurred.</para>
            <para>See also state() and errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAbstractSocket.Flush">
            <summary>
            <para>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</para>
            <para>Call this function if you need QAbstractSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QAbstractSocket will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call waitForBytesWritten() instead.</para>
            <para>See also write() and waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketType">
            <summary>
            <para>This enum describes the transport layer protocol.</para>
            <para>See also QAbstractSocket::socketType().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketType.TcpSocket">
            <summary>TCP</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketType.UdpSocket">
            <summary>UDP</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketType.UnknownSocketType">
            <summary>Other than TCP and UDP</summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.NetworkLayerProtocol">
            <summary>
            <para>This enum describes the network layer protocol values used in Qt.</para>
            <para>See also QHostAddress::protocol().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.NetworkLayerProtocol.IPv4Protocol">
            <summary>IPv4</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.NetworkLayerProtocol.IPv6Protocol">
            <summary>IPv6</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.NetworkLayerProtocol.AnyIPProtocol">
            <summary>Either IPv4 or IPv6</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.NetworkLayerProtocol.UnknownNetworkLayerProtocol">
            <summary>Other than IPv4 and IPv6</summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketError">
            <summary>
            <para>This enum describes the socket errors that can occur.</para>
            <para>See also QAbstractSocket::error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ConnectionRefusedError">
            <summary>The connection was refused by the peer (or timed out).</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.RemoteHostClosedError">
            <summary>The remote host closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.HostNotFoundError">
            <summary>The host address was not found.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketAccessError">
            <summary>The socket operation failed because the application lacked the required privileges.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketResourceError">
            <summary>The local system ran out of resources (e.g., too many sockets).</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketTimeoutError">
            <summary>The socket operation timed out.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.DatagramTooLargeError">
            <summary>The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.NetworkError">
            <summary>An error occurred with the network (e.g., the network cable was accidentally plugged out).</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.AddressInUseError">
            <summary>The address specified to QAbstractSocket::bind() is already in use and was set to be exclusive.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SocketAddressNotAvailableError">
            <summary>The address specified to QAbstractSocket::bind() does not belong to the host.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.UnsupportedSocketOperationError">
            <summary>The requested socket operation is not supported by the local operating system (e.g., lack of IPv6 support).</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.UnfinishedSocketOperationError">
            <summary>Used by QAbstractSocketEngine only, The last operation attempted has not finished yet (still in progress in the background).</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyAuthenticationRequiredError">
            <summary>The socket is using a proxy, and the proxy requires authentication.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SslHandshakeFailedError">
            <summary>The SSL/TLS handshake failed, so the connection was closed (only used in QSslSocket)</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyConnectionRefusedError">
            <summary>Could not contact the proxy server because the connection to that server was denied</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyConnectionClosedError">
            <summary>The connection to the proxy server was closed unexpectedly (before the connection to the final peer was established)</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyConnectionTimeoutError">
            <summary>The connection to the proxy server timed out or the proxy server stopped responding in the authentication phase.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyNotFoundError">
            <summary>The proxy address set with setProxy() (or the application proxy) was not found.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.ProxyProtocolError">
            <summary>The connection negotiation with the proxy server failed, because the response from the proxy server could not be understood.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.OperationError">
            <summary>An operation was attempted while the socket was in a state that did not permit it.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SslInternalError">
            <summary>The SSL library being used reported an internal error. This is probably the result of a bad installation or misconfiguration of the library.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.SslInvalidUserDataError">
            <summary>Invalid data (certificate, key, cypher, etc.) was provided and its use resulted in an error in the SSL library.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.TemporaryError">
            <summary>A temporary error occurred (e.g., operation would block and socket is non-blocking).</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketError.UnknownSocketError">
            <summary>An unidentified error occurred.</summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketState">
            <summary>
            <para>This enum describes the different states in which a socket can be.</para>
            <para>See also QAbstractSocket::state().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.UnconnectedState">
            <summary>The socket is not connected.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.HostLookupState">
            <summary>The socket is performing a host name lookup.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ConnectingState">
            <summary>The socket has started establishing a connection.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ConnectedState">
            <summary>A connection is established.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.BoundState">
            <summary>The socket is bound to an address and port.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ListeningState">
            <summary>For internal use only.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketState.ClosingState">
            <summary>The socket is about to close (data may still be waiting to be written).</summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.SocketOption">
            <summary>
            <para>This enum represents the options that can be set on a socket. If desired, they can be set after having received the connected() signal from the socket or after having received a new socket from a QTcpServer.</para>
            <para>Possible values for TypeOfServiceOption are:</para>
            <para></para>
            <para> ValueDescription</para>
            <para>224	Network control</para>
            <para>192	Internetwork control</para>
            <para>160	CRITIC/ECP</para>
            <para>128	Flash override</para>
            <para>96	Flash</para>
            <para>64	Immediate</para>
            <para>32	Priority</para>
            <para>0	Routine</para>
            <para></para>
            <para>This enum was introduced or modified in  Qt 4.6.</para>
            <para>See also QAbstractSocket::setSocketOption() and QAbstractSocket::socketOption().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.LowDelayOption">
            <summary>Try to optimize the socket for low latency. For a QTcpSocket this would set the TCP_NODELAY option and disable Nagle's algorithm. Set this to 1 to enable.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.KeepAliveOption">
            <summary>Set this to 1 to enable the SO_KEEPALIVE socket option</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.MulticastTtlOption">
            <summary>Set this to an integer value to set IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.MulticastLoopbackOption">
            <summary>Set this to 1 to enable the IP_MULTICAST_LOOP (multicast loopback) socket option.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.TypeOfServiceOption">
            <summary>This option is not supported on Windows. This maps to the IP_TOS socket option. For possible values, see table below.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.SendBufferSizeSocketOption">
            <summary>Sets the socket send buffer size in bytes at the OS level. This maps to the SO_SNDBUF socket option. This option does not affect the QIODevice or QAbstractSocket buffers. This enum value has been introduced in Qt 5.3.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.SocketOption.ReceiveBufferSizeSocketOption">
            <summary>Sets the socket receive buffer size in bytes at the OS level. This maps to the SO_RCVBUF socket option. This option does not affect the QIODevice or QAbstractSocket buffers (see setReadBufferSize()). This enum value has been introduced in Qt 5.3.</summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.BindFlag">
            <summary>
            <para>This enum describes the different flags you can pass to modify the behavior of QAbstractSocket::bind().</para>
            <para>This enum was introduced or modified in  Qt 5.0.</para>
            <para>The BindMode type is a typedef for QFlags&lt;BindFlag&gt;. It stores an OR combination of BindFlag values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.BindFlag.DefaultForPlatform">
            <summary>The default option for the current platform. On Unix and OS X, this is equivalent to (DontShareAddress + ReuseAddressHint), and on Windows, its equivalent to ShareAddress.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.BindFlag.ShareAddress">
            <summary>Allow other services to bind to the same address and port. This is useful when multiple processes share the load of a single service by listening to the same address and port (e.g., a web server with several pre-forked listeners can greatly improve response time). However, because any service is allowed to rebind, this option is subject to certain security considerations. Note that by combining this option with ReuseAddressHint, you will also allow your service to rebind an existing shared address. On Unix, this is equivalent to the SO_REUSEADDR socket option. On Windows, this option is ignored.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.BindFlag.DontShareAddress">
            <summary>Bind the address and port exclusively, so that no other services are allowed to rebind. By passing this option to QAbstractSocket::bind(), you are guaranteed that on successs, your service is the only one that listens to the address and port. No services are allowed to rebind, even if they pass ReuseAddressHint. This option provides more security than ShareAddress, but on certain operating systems, it requires you to run the server with administrator privileges. On Unix and OS X, not sharing is the default behavior for binding an address and port, so this option is ignored. On Windows, this option uses the SO_EXCLUSIVEADDRUSE socket option.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.BindFlag.ReuseAddressHint">
            <summary>Provides a hint to QAbstractSocket that it should try to rebind the service even if the address and port are already bound by another socket. On Windows, this is equivalent to the SO_REUSEADDR socket option. On Unix, this option is ignored.</summary>
        </member>
        <member name="T:QtNetwork.QAbstractSocket.PauseMode">
            <summary>
            <para>This enum describes the behavior of when the socket should hold back with continuing data transfer. The only notification currently supported is QSslSocket::sslErrors().</para>
            <para>This enum was introduced or modified in  Qt 5.0.</para>
            <para>The PauseModes type is a typedef for QFlags&lt;PauseMode&gt;. It stores an OR combination of PauseMode values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.PauseMode.PauseNever">
            <summary>Do not pause data transfer on the socket. This is the default and matches the behaviour of Qt 4.</summary>
        </member>
        <member name="F:QtNetwork.QAbstractSocket.PauseMode.PauseOnSslErrors">
            <summary>Pause data transfer on the socket upon receiving an SSL error notification. I.E. QSslSocket::sslErrors().</summary>
        </member>
        <member name="T:QtNetwork.QTcpSocket">
            <summary>
            <para>The QTcpSocket class provides a TCP socket.</para>
            </summary>
            <remarks>
            <para>TCP (Transmission Control Protocol) is a reliable, stream-oriented, connection-oriented transport protocol. It is especially well suited for continuous transmission of data.</para>
            <para>QTcpSocket is a convenience subclass of QAbstractSocket that allows you to establish a TCP connection and transfer streams of data. See the QAbstractSocket documentation for details.</para>
            <para>Note: TCP sockets cannot be opened in QIODevice::Unbuffered mode.</para>
            <para></para>
            <para>See also QTcpServer, QUdpSocket, QNetworkAccessManager, Fortune Server Example, Fortune Client Example, Threaded Fortune Server Example, Blocking Fortune Client Example, Loopback Example, and Torrent Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QTcpSocket.#ctor(QtCore.QObject)">
            <summary>
            <para>Creates a QTcpSocket object in state UnconnectedState.</para>
            <para>parent is passed on to the QObject constructor.</para>
            <para>See also socketType().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSsl.SslProtocol">
            <summary>
            <para>Describes the protocol of the cipher.</para>
            <para>Note: most servers understand both SSL and TLS, but it is recommended to use TLS only for security reasons. However, SSL and TLS are not compatible with each other: if you get unexpected handshake failures, verify that you chose the correct setting for your protocol.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.SslV3">
            <summary>SSLv3</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.SslV2">
            <summary>SSLv2</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.TlsV1_0">
            <summary>TLSv1.0</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.TlsV1_1">
            <summary>TLSv1.1</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.TlsV1_2">
            <summary>TLSv1.2</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.AnyProtocol">
            <summary>The socket understands SSLv2, SSLv3, and TLSv1.0. This value is used by QSslSocket only.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.TlsV1SslV3">
            <summary>On the client side, this will send a TLS 1.0 Client Hello, enabling TLSv1_0 and SSLv3 connections. On the server side, this will enable both SSLv3 and TLSv1_0 connections.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.SecureProtocols">
            <summary>The default option, using protocols known to be secure; currently behaves similar to TlsV1Ssl3 except denying SSLv3 connections that does not upgrade to TLS.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.TlsV1_0OrLater">
            <summary>TLSv1.0 and later versions. This option is not available when using the WinRT backend due to platform limitations.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.TlsV1_1OrLater">
            <summary>TLSv1.1 and later versions. This option is not available when using the WinRT backend due to platform limitations.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.TlsV1_2OrLater">
            <summary>TLSv1.2 and later versions. This option is not available when using the WinRT backend due to platform limitations.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslProtocol.UnknownProtocol">
            <summary>The cipher's protocol cannot be determined.</summary>
        </member>
        <member name="T:QtNetwork.QSsl.EncodingFormat">
            <summary>
            <para>Describes supported encoding formats for certificates and keys.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSsl.EncodingFormat.Pem">
            <summary>The PEM format.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.EncodingFormat.Der">
            <summary>The DER format.</summary>
        </member>
        <member name="T:QtNetwork.QSsl.AlternativeNameEntryType">
            <summary>
            <para>Describes the key types for alternative name entries in QSslCertificate.</para>
            <para>Note: In Qt 4, this enum was called AlternateNameEntryType. That name is deprecated in Qt 5.</para>
            <para>See also QSslCertificate::subjectAlternativeNames().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSsl.AlternativeNameEntryType.EmailEntry">
            <summary>An email entry; the entry contains an email address that the certificate is valid for.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.AlternativeNameEntryType.DnsEntry">
            <summary>A DNS host name entry; the entry contains a host name entry that the certificate is valid for. The entry may contain wildcards.</summary>
        </member>
        <member name="T:QtNetwork.QSsl.KeyAlgorithm">
            <summary>
            <para>Describes the different key algorithms supported by QSslKey.</para>
            <para>The opaque key facility allows applications to add support for facilities such as PKCS#11 that Qt does not currently offer natively.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSsl.KeyAlgorithm.Opaque">
            <summary>A key that should be treated as a 'black box' by QSslKey.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.KeyAlgorithm.Rsa">
            <summary>The RSA algorithm.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.KeyAlgorithm.Dsa">
            <summary>The DSA algorithm.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.KeyAlgorithm.Ec">
            <summary>The Elliptic Curve algorithm</summary>
        </member>
        <member name="T:QtNetwork.QSsl.KeyType">
            <summary>
            <para>Describes the two types of keys QSslKey supports.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSsl.KeyType.PrivateKey">
            <summary>A private key.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.KeyType.PublicKey">
            <summary>A public key.</summary>
        </member>
        <member name="T:QtNetwork.QSsl.SslOption">
            <summary>
            <para>Describes the options that can be used to control the details of SSL behaviour. These options are generally used to turn features off to work around buggy servers.</para>
            <para>By default, SslOptionDisableEmptyFragments is turned on since this causes problems with a large number of servers. SslOptionDisableLegacyRenegotiation is also turned on, since it introduces a security risk. SslOptionDisableCompression is turned on to prevent the attack publicised by CRIME. SslOptionDisableSessionPersistence is turned on to optimize memory usage. The other options are turned off.</para>
            <para>Note: Availability of above options depends on the version of the SSL backend in use.</para>
            <para>The SslOptions type is a typedef for QFlags&lt;SslOption&gt;. It stores an OR combination of SslOption values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslOption.SslOptionDisableEmptyFragments">
            <summary>Disables the insertion of empty fragments into the data when using block ciphers. When enabled, this prevents some attacks (such as the BEAST attack), however it is incompatible with some servers.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslOption.SslOptionDisableSessionTickets">
            <summary>Disables the SSL session ticket extension. This can cause slower connection setup, however some servers are not compatible with the extension.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslOption.SslOptionDisableCompression">
            <summary>Disables the SSL compression extension. When enabled, this allows the data being passed over SSL to be compressed, however some servers are not compatible with this extension.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslOption.SslOptionDisableServerNameIndication">
            <summary>Disables the SSL server name indication extension. When enabled, this tells the server the virtual host being accessed allowing it to respond with the correct certificate.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslOption.SslOptionDisableLegacyRenegotiation">
            <summary>Disables the older insecure mechanism for renegotiating the connection parameters. When enabled, this option can allow connections for legacy servers, but it introduces the possibility that an attacker could inject plaintext into the SSL session.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslOption.SslOptionDisableSessionSharing">
            <summary>Disables SSL session sharing via the session ID handshake attribute.</summary>
        </member>
        <member name="F:QtNetwork.QSsl.SslOption.SslOptionDisableSessionPersistence">
            <summary>Disables storing the SSL session in ASN.1 format as returned by QSslConfiguration::sessionTicket(). Enabling this feature adds memory overhead of approximately 1K per used session ticket.</summary>
        </member>
        <member name="T:QtNetwork.QSslCertificate">
            <summary>
            <para>The QSslCertificate class provides a convenient API for an X509 certificate.</para>
            </summary>
            <remarks>
            <para>QSslCertificate stores an X509 certificate, and is commonly used to verify the identity and store information about the local host, a remotely connected peer, or a trusted third party Certificate Authority.</para>
            <para>There are many ways to construct a QSslCertificate. The most common way is to call QSslSocket::peerCertificate(), which returns a QSslCertificate object, or QSslSocket::peerCertificateChain(), which returns a list of them. You can also load certificates from a DER (binary) or PEM (Base64) encoded bundle, typically stored as one or more local files, or in a Qt Resource.</para>
            <para>You can call isNull() to check if your certificate is null. By default, QSslCertificate constructs a null certificate. A null certificate is invalid, but an invalid certificate is not necessarily null. If you want to reset all contents in a certificate, call clear().</para>
            <para>After loading a certificate, you can find information about the certificate, its subject, and its issuer, by calling one of the many accessor functions, including version(), serialNumber(), issuerInfo() and subjectInfo(). You can call effectiveDate() and expiryDate() to check when the certificate starts being effective and when it expires. The publicKey() function returns the certificate subject's public key as a QSslKey. You can call issuerInfo() or subjectInfo() to get detailed information about the certificate issuer and its subject.</para>
            <para>Internally, QSslCertificate is stored as an X509 structure. You can access this handle by calling handle(), but the results are likely to not be portable.</para>
            <para></para>
            <para>See also QSslSocket, QSslKey, QSslCipher, and QSslError.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslCertificate.#ctor(QtCore.QIODevice,QtNetwork.QSsl.EncodingFormat)">
            <summary>
            <para>Constructs a QSslCertificate by reading format encoded data from device and using the first certificate found. You can later call isNull() to see if device contained a certificate, and if this certificate was loaded successfully.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.#ctor(QtCore.QByteArray,QtNetwork.QSsl.EncodingFormat)">
            <summary>
            <para>Constructs a QSslCertificate by parsing the format encoded data and using the first available certificate found. You can later call isNull() to see if data contained a certificate, and if this certificate was loaded successfully.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.#ctor(QtNetwork.QSslCertificate)">
            <summary>
            <para>Constructs an identical copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.Swap(QtNetwork.QSslCertificate)">
            <summary>
            <para>Swaps this certificate instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.op_Equality(QtNetwork.QSslCertificate,QtNetwork.QSslCertificate)">
            <summary>
            <para>Returns true if this certificate is the same as other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.op_Inequality(QtNetwork.QSslCertificate,QtNetwork.QSslCertificate)">
            <summary>
            <para>Returns true if this certificate is not the same as other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.Clear">
            <summary>
            <para>Clears the contents of this certificate, making it a null certificate.</para>
            <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.Digest(QtCore.QCryptographicHash.Algorithm)">
            <summary>
            <para>Returns a cryptographic digest of this certificate. By default, an MD5 digest will be generated, but you can also specify a custom algorithm.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.IssuerInfo(QtNetwork.QSslCertificate.SubjectInfo)">
            <summary>
            <para>Returns the issuer information for the subject from the certificate, or an empty list if there is no information for subject in the certificate. There can be more than one entry of each type.</para>
            <para>See also subjectInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.IssuerInfo(QtCore.QByteArray)">
            <summary>
            <para>Returns the issuer information for attribute from the certificate, or an empty list if there is no information for attribute in the certificate. There can be more than one entry for an attribute.</para>
            <para>See also subjectInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.subjectInfo(QtNetwork.QSslCertificate.SubjectInfo)">
            <summary>
            <para>Returns the information for the subject, or an empty list if there is no information for subject in the certificate. There can be more than one entry of each type.</para>
            <para>See also issuerInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.subjectInfo(QtCore.QByteArray)">
            <summary>
            <para>Returns the subject information for attribute, or an empty list if there is no information for attribute in the certificate. There can be more than one entry for an attribute.</para>
            <para>See also issuerInfo().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.ToPem">
            <summary>
            <para>Returns this certificate converted to a PEM (Base64) encoded representation.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.ToDer">
            <summary>
            <para>Returns this certificate converted to a DER (binary) encoded representation.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificate.ToText">
            <summary>
            <para>Returns this certificate converted to a human-readable text representation.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.IsNull">
            <summary>
            <para>Returns true if this is a null certificate (i.e., a certificate with no contents); otherwise returns false.</para>
            <para>By default, QSslCertificate constructs a null certificate.</para>
            <para>See also clear().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.IsBlacklisted">
            <summary>
            <para>Returns true if this certificate is blacklisted; otherwise returns false.</para>
            <para>See also isNull().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.IsSelfSigned">
            <summary>
            <para>Returns true if this certificate is self signed; otherwise returns false.</para>
            <para>A certificate is considered self-signed its issuer and subject are identical.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.Version">
            <summary>
            <para>Returns the certificate's version string.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.SerialNumber">
            <summary>
            <para>Returns the certificate's serial number string in hexadecimal format.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.EffectiveDate">
            <summary>
            <para>Returns the date-time that the certificate becomes valid, or an empty QDateTime if this is a null certificate.</para>
            <para>See also expiryDate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.ExpiryDate">
            <summary>
            <para>Returns the date-time that the certificate expires, or an empty QDateTime if this is a null certificate.</para>
            <para>See also effectiveDate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.PublicKey">
            <summary>
            <para>Returns the certificate subject's public key.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificate.Handle">
            <summary>
            <para>Returns a pointer to the native certificate handle, if there is one, or a null pointer otherwise.</para>
            <para>You can use this handle, together with the native API, to access extended information about the certificate.</para>
            <para>Warning: Use of this function has a high probability of being non-portable, and its return value may vary from platform to platform or change from minor release to minor release.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslCertificate.SubjectInfo">
            <summary>
            <para>Describes keys that you can pass to QSslCertificate::issuerInfo() or QSslCertificate::subjectInfo() to get information about the certificate issuer or subject.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.Organization">
            <summary>"O" The name of the organization.</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.CommonName">
            <summary>"CN" The common name; most often this is used to store the host name.</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.LocalityName">
            <summary>"L" The locality.</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.OrganizationalUnitName">
            <summary>"OU" The organizational unit name.</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.CountryName">
            <summary>"C" The country.</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.StateOrProvinceName">
            <summary>"ST" The state or province.</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.DistinguishedNameQualifier">
            <summary>The distinguished name qualifier</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.SerialNumber">
            <summary>The certificate's serial number</summary>
        </member>
        <member name="F:QtNetwork.QSslCertificate.SubjectInfo.EmailAddress">
            <summary>The email address associated with the certificate</summary>
        </member>
        <member name="T:QtNetwork.QSslError">
            <summary>
            <para>The QSslError class provides an SSL error.</para>
            </summary>
            <remarks>
            <para>QSslError provides a simple API for managing errors during QSslSocket's SSL handshake.</para>
            <para></para>
            <para>See also QSslSocket, QSslCertificate, and QSslCipher.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor">
            <summary>
            <para>Constructs a QSslError object with no error and default certificate.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor(QtNetwork.QSslError.SslError)">
            <summary>
            <para>Constructs a QSslError object. The argument specifies the error that occurred.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor(QtNetwork.QSslError.SslError,QtNetwork.QSslCertificate)">
            <summary>
            <para>Constructs a QSslError object. The two arguments specify the error that occurred, and which certificate the error relates to.</para>
            <para>See also QSslCertificate.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.#ctor(QtNetwork.QSslError)">
            <summary>
            <para>Constructs an identical copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.Swap(QtNetwork.QSslError)">
            <summary>
            <para>Swaps this error instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.op_Equality(QtNetwork.QSslError,QtNetwork.QSslError)">
            <summary>
            <para>Returns true if this error is equal to other; otherwise returns false.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslError.op_Inequality(QtNetwork.QSslError,QtNetwork.QSslError)">
            <summary>
            <para>Returns true if this error is not equal to other; otherwise returns false.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslError.Error">
            <summary>
            <para>Returns the type of the error.</para>
            <para>See also errorString() and certificate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslError.ErrorString">
            <summary>
            <para>Returns a short localized human-readable description of the error.</para>
            <para>See also error() and certificate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslError.Certificate">
            <summary>
            <para>Returns the certificate associated with this error, or a null certificate if the error does not relate to any certificate.</para>
            <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslError.SslError">
            <summary>
            <para>Describes all recognized errors that can occur during an SSL handshake.</para>
            <para>See also QSslError::errorString().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslSocket">
            <summary>
            <para>The QSslSocket class provides an SSL encrypted socket for both clients and servers.</para>
            </summary>
            <remarks>
            <para>QSslSocket establishes a secure, encrypted TCP connection you can use for transmitting encrypted data. It can operate in both client and server mode, and it supports modern SSL protocols, including SSLv3 and TLSv1_0. By default, QSslSocket uses TLSv1_0, but you can change the SSL protocol by calling setProtocol() as long as you do it before the handshake has started.</para>
            <para>SSL encryption operates on top of the existing TCP stream after the socket enters the ConnectedState. There are two simple ways to establish a secure connection using QSslSocket: With an immediate SSL handshake, or with a delayed SSL handshake occurring after the connection has been established in unencrypted mode.</para>
            <para>The most common way to use QSslSocket is to construct an object and start a secure connection by calling connectToHostEncrypted(). This method starts an immediate SSL handshake once the connection has been established.</para>
            <para>QSslSocket *socket = new QSslSocket(this);</para>
            <para>connect(socket, SIGNAL(encrypted()), this, SLOT(ready()));</para>
            <para></para>
            <para>socket-&gt;connectToHostEncrypted(&quot;imap.example.com&quot;, 993);</para>
            <para>As with a plain QTcpSocket, QSslSocket enters the HostLookupState, ConnectingState, and finally the ConnectedState, if the connection is successful. The handshake then starts automatically, and if it succeeds, the encrypted() signal is emitted to indicate the socket has entered the encrypted state and is ready for use.</para>
            <para>Note that data can be written to the socket immediately after the return from connectToHostEncrypted() (i.e., before the encrypted() signal is emitted). The data is queued in QSslSocket until after the encrypted() signal is emitted.</para>
            <para>An example of using the delayed SSL handshake to secure an existing connection is the case where an SSL server secures an incoming connection. Suppose you create an SSL server class as a subclass of QTcpServer. You would override QTcpServer::incomingConnection() with something like the example below, which first constructs an instance of QSslSocket and then calls setSocketDescriptor() to set the new socket's descriptor to the existing one passed in. It then initiates the SSL handshake by calling startServerEncryption().</para>
            <para>void SslServer::incomingConnection(qintptr socketDescriptor)</para>
            <para>{</para>
            <para>    QSslSocket *serverSocket = new QSslSocket;</para>
            <para>    if (serverSocket-&gt;setSocketDescriptor(socketDescriptor)) {</para>
            <para>        connect(serverSocket, SIGNAL(encrypted()), this, SLOT(ready()));</para>
            <para>        serverSocket-&gt;startServerEncryption();</para>
            <para>    } else {</para>
            <para>        delete serverSocket;</para>
            <para>    }</para>
            <para>}</para>
            <para>If an error occurs, QSslSocket emits the sslErrors() signal. In this case, if no action is taken to ignore the error(s), the connection is dropped. To continue, despite the occurrence of an error, you can call ignoreSslErrors(), either from within this slot after the error occurs, or any time after construction of the QSslSocket and before the connection is attempted. This will allow QSslSocket to ignore the errors it encounters when establishing the identity of the peer. Ignoring errors during an SSL handshake should be used with caution, since a fundamental characteristic of secure connections is that they should be established with a successful handshake.</para>
            <para>Once encrypted, you use QSslSocket as a regular QTcpSocket. When readyRead() is emitted, you can call read(), canReadLine() and readLine(), or getChar() to read decrypted data from QSslSocket's internal buffer, and you can call write() or putChar() to write data back to the peer. QSslSocket will automatically encrypt the written data for you, and emit encryptedBytesWritten() once the data has been written to the peer.</para>
            <para>As a convenience, QSslSocket supports QTcpSocket's blocking functions waitForConnected(), waitForReadyRead(), waitForBytesWritten(), and waitForDisconnected(). It also provides waitForEncrypted(), which will block the calling thread until an encrypted connection has been established.</para>
            <para>QSslSocket socket;</para>
            <para>socket.connectToHostEncrypted(&quot;http.example.com&quot;, 443);</para>
            <para>if (!socket.waitForEncrypted()) {</para>
            <para>    qDebug() &lt;&lt; socket.errorString();</para>
            <para>    return false;</para>
            <para>}</para>
            <para></para>
            <para>socket.write(&quot;GET / HTTP/1.0\r\n\r\n&quot;);</para>
            <para>while (socket.waitForReadyRead())</para>
            <para>    qDebug() &lt;&lt; socket.readAll().data();</para>
            <para>QSslSocket provides an extensive, easy-to-use API for handling cryptographic ciphers, private keys, and local, peer, and Certification Authority (CA) certificates. It also provides an API for handling errors that occur during the handshake phase.</para>
            <para>The following features can also be customized:</para>
            <para></para>
            <para>The socket's cryptographic cipher suite can be customized before the handshake phase with setCiphers() and setDefaultCiphers().</para>
            <para>The socket's local certificate and private key can be customized before the handshake phase with setLocalCertificate() and setPrivateKey().</para>
            <para>The CA certificate database can be extended and customized with addCaCertificate(), addCaCertificates(), setCaCertificates(), addDefaultCaCertificate(), addDefaultCaCertificates(), and setDefaultCaCertificates().</para>
            <para></para>
            <para>Note: If available, root certificates on Unix (excluding OS X) will be loaded on demand from the standard certificate directories. If you do not want to load root certificates on demand, you need to call either the static function setDefaultCaCertificates() before the first SSL handshake is made in your application, (e.g. via &quot;QSslSocket::setDefaultCaCertificates(QSslSocket::systemCaCertificates());&quot;), or call setCaCertificates() on your QSslSocket instance prior to the SSL handshake.</para>
            <para>For more information about ciphers and certificates, refer to QSslCipher and QSslCertificate.</para>
            <para>This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/).</para>
            <para>Note: Be aware of the difference between the bytesWritten() signal and the encryptedBytesWritten() signal. For a QTcpSocket, bytesWritten() will get emitted as soon as data has been written to the TCP socket. For a QSslSocket, bytesWritten() will get emitted when the data is being encrypted and encryptedBytesWritten() will get emitted as soon as data has been written to the TCP socket.</para>
            <para></para>
            <para>See also QSslCertificate, QSslCipher, and QSslError.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslSocket.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QSslSocket object. parent is passed to QObject's constructor. The new socket's cipher suite is set to the one returned by the static method defaultCiphers().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.Resume">
            <summary>
            <para>Reimplemented from QAbstractSocket::resume().</para>
            <para>Continues data transfer on the socket after it has been paused. If &quot;setPauseMode(QAbstractSocket::PauseOnSslErrors);&quot; has been called on this socket and a sslErrors() signal is received, calling this method is necessary for the socket to continue.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also QAbstractSocket::pauseMode() and QAbstractSocket::setPauseMode().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.ConnectToHostEncrypted(System.String,System.UInt16,QtCore.QIODevice.OpenModeFlag,QtNetwork.QAbstractSocket.NetworkLayerProtocol)">
            <summary>
            <para>Starts an encrypted connection to the device hostName on port, using mode as the OpenMode. This is equivalent to calling connectToHost() to establish the connection, followed by a call to startClientEncryption(). The protocol parameter can be used to specify which network protocol to use (eg. IPv4 or IPv6).</para>
            <para>QSslSocket first enters the HostLookupState. Then, after entering either the event loop or one of the waitFor...() functions, it enters the ConnectingState, emits connected(), and then initiates the SSL client handshake. At each state change, QSslSocket emits signal stateChanged().</para>
            <para>After initiating the SSL client handshake, if the identity of the peer can't be established, signal sslErrors() is emitted. If you want to ignore the errors and continue connecting, you must call ignoreSslErrors(), either from inside a slot function connected to the sslErrors() signal, or prior to entering encrypted mode. If ignoreSslErrors() is not called, the connection is dropped, signal disconnected() is emitted, and QSslSocket returns to the UnconnectedState.</para>
            <para>If the SSL handshake is successful, QSslSocket emits encrypted().</para>
            <para>QSslSocket socket;</para>
            <para>connect(&amp;socket, SIGNAL(encrypted()), receiver, SLOT(socketEncrypted()));</para>
            <para></para>
            <para>socket.connectToHostEncrypted(&quot;imap&quot;, 993);</para>
            <para>socket-&gt;write(&quot;1 CAPABILITY\r\n&quot;);</para>
            <para>Note: The example above shows that text can be written to the socket immediately after requesting the encrypted connection, before the encrypted() signal has been emitted. In such cases, the text is queued in the object and written to the socket after the connection is established and the encrypted() signal has been emitted.</para>
            <para>The default for mode is ReadWrite.</para>
            <para>If you want to create a QSslSocket on the server side of a connection, you should instead call startServerEncryption() upon receiving the incoming connection through QTcpServer.</para>
            <para>See also connectToHost(), startClientEncryption(), waitForConnected(), and waitForEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.ConnectToHostEncrypted(System.String,System.UInt16,System.String,QtCore.QIODevice.OpenModeFlag,QtNetwork.QAbstractSocket.NetworkLayerProtocol)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>In addition to the original behaviour of connectToHostEncrypted, this overloaded method enables the usage of a different hostname (sslPeerName) for the certificate validation instead of the one used for the TCP connection (hostName).</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also connectToHostEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetSocketDescriptor(System.Int32,QtNetwork.QAbstractSocket.SocketState,QtCore.QIODevice.OpenModeFlag)">
            <summary>
            <para>Reimplemented from QAbstractSocket::setSocketDescriptor().</para>
            <para>Initializes QSslSocket with the native socket descriptor socketDescriptor. Returns true if socketDescriptor is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by openMode, and enters the socket state specified by state.</para>
            <para>Note: It is not possible to initialize two sockets with the same native socket descriptor.</para>
            <para>See also socketDescriptor().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetSocketOption(QtNetwork.QAbstractSocket.SocketOption,QtCore.QVariant)">
            <summary>
            <para>Reimplemented from QAbstractSocket::setSocketOption().</para>
            <para>Sets the given option to the value described by value.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also socketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.socketOption(QtNetwork.QAbstractSocket.SocketOption)">
            <summary>
            <para>Reimplemented from QAbstractSocket::socketOption().</para>
            <para>Returns the value of the option option.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also setSocketOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.CanReadLine">
            <summary>
            <para>Reimplemented from QIODevice::canReadLine().</para>
            <para>Returns true if you can read one while line (terminated by a single ASCII '\n' character) of decrypted characters; otherwise, false is returned.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.Close">
            <summary>
            <para>Reimplemented from QIODevice::close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.Abort">
            <summary>
            <para>Aborts the current connection and resets the socket. Unlike disconnectFromHost(), this function immediately closes the socket, clearing any pending data in the write buffer.</para>
            <para>See also disconnectFromHost() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetLocalCertificate(System.String,QtNetwork.QSsl.EncodingFormat)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the socket's local certificate to the first one found in file path, which is parsed according to the specified format.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetPrivateKey(System.String,QtNetwork.QSsl.KeyAlgorithm,QtNetwork.QSsl.EncodingFormat,QtCore.QByteArray)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Reads the string in file fileName and decodes it using a specified algorithm and encoding format to construct an SSL key. If the encoded key is encrypted, passPhrase is used to decrypt it.</para>
            <para>The socket's private key is set to the constructed key. The private key and the local certificate are used by clients and servers that must prove their identity to SSL peers.</para>
            <para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</para>
            <para>See also privateKey() and setLocalCertificate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.SetCiphers(System.String)">
            <summary>
            <para>Use QSslConfiguration::setCiphers() instead.</para>
            <para>Sets the cryptographic cipher suite for this socket to ciphers, which is a colon-separated list of cipher suite names. The ciphers are listed in order of preference, starting with the most preferred cipher. For example:</para>
            <para>QSslSocket socket;</para>
            <para>socket.setCiphers(&quot;DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:AES256-SHA&quot;);</para>
            <para>Each cipher name in ciphers must be the name of a cipher in the list returned by supportedCiphers(). Restricting the cipher suite must be done before the handshake phase, where the session cipher is chosen.</para>
            <para>See also ciphers(), setDefaultCiphers(), and supportedCiphers().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddCaCertificates(System.String,QtNetwork.QSsl.EncodingFormat,QtCore.QRegExp.PatternSyntax)">
            <summary>
            <para>Searches all files in the path for certificates encoded in the specified format and adds them to this socket's CA certificate database. path can be explicit, or it can contain wildcards in the format specified by syntax. Returns true if one or more certificates are added to the socket's CA certificate database; otherwise returns false.</para>
            <para>The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</para>
            <para>For more precise control, use addCaCertificate().</para>
            <para>See also addCaCertificate() and QSslCertificate::fromPath().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddCaCertificate(QtNetwork.QSslCertificate)">
            <summary>
            <para>Adds the certificate to this socket's CA certificate database. The CA certificate database is used by the socket during the handshake phase to validate the peer's certificate.</para>
            <para>To add multiple certificates, use addCaCertificates().</para>
            <para>See also caCertificates() and setCaCertificates().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForConnected(System.Int32)">
            <summary>
            <para>Reimplemented from QAbstractSocket::waitForConnected().</para>
            <para>Waits until the socket is connected, or msecs milliseconds, whichever happens first. If the connection has been established, this function returns true; otherwise it returns false.</para>
            <para>See also QAbstractSocket::waitForConnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForEncrypted(System.Int32)">
            <summary>
            <para>Waits until the socket has completed the SSL handshake and has emitted encrypted(), or msecs milliseconds, whichever comes first. If encrypted() has been emitted, this function returns true; otherwise (e.g., the socket is disconnected, or the SSL handshake fails), false is returned.</para>
            <para>The following example waits up to one second for the socket to be encrypted:</para>
            <para>socket-&gt;connectToHostEncrypted(&quot;imap&quot;, 993);</para>
            <para>if (socket-&gt;waitForEncrypted(1000))</para>
            <para>    qDebug(&quot;Encrypted!&quot;);</para>
            <para>If msecs is -1, this function will not time out.</para>
            <para>See also startClientEncryption(), startServerEncryption(), encrypted(), and isEncrypted().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForReadyRead(System.Int32)">
            <summary>
            <para>Reimplemented from QIODevice::waitForReadyRead().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForBytesWritten(System.Int32)">
            <summary>
            <para>Reimplemented from QIODevice::waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WaitForDisconnected(System.Int32)">
            <summary>
            <para>Reimplemented from QAbstractSocket::waitForDisconnected().</para>
            <para>Waits until the socket has disconnected or msecs milliseconds, whichever comes first. If the connection has been disconnected, this function returns true; otherwise it returns false.</para>
            <para>See also QAbstractSocket::waitForDisconnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.StartClientEncryption">
            <summary>
            <para>Starts a delayed SSL handshake for a client connection. This function can be called when the socket is in the ConnectedState but still in the UnencryptedMode. If it is not yet connected, or if it is already encrypted, this function has no effect.</para>
            <para>Clients that implement STARTTLS functionality often make use of delayed SSL handshakes. Most other clients can avoid calling this function directly by using connectToHostEncrypted() instead, which automatically performs the handshake.</para>
            <para>See also connectToHostEncrypted() and startServerEncryption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.StartServerEncryption">
            <summary>
            <para>Starts a delayed SSL handshake for a server connection. This function can be called when the socket is in the ConnectedState but still in UnencryptedMode. If it is not connected or it is already encrypted, the function has no effect.</para>
            <para>For server sockets, calling this function is the only way to initiate the SSL handshake. Most servers will call this function immediately upon receiving a connection, or as a result of having received a protocol-specific command to enter SSL mode (e.g, the server may respond to receiving the string &quot;STARTTLS\r\n&quot; by calling this function).</para>
            <para>The most common way to implement an SSL server is to create a subclass of QTcpServer and reimplement QTcpServer::incomingConnection(). The returned socket descriptor is then passed to QSslSocket::setSocketDescriptor().</para>
            <para>See also connectToHostEncrypted() and startClientEncryption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.IgnoreSslErrors">
            <summary>
            <para>This slot tells QSslSocket to ignore errors during QSslSocket's handshake phase and continue connecting. If you want to continue with the connection even if errors occur during the handshake phase, then you must call this slot, either from a slot connected to sslErrors(), or before the handshake phase. If you don't call this slot, either in response to errors or before the handshake, the connection will be dropped after the sslErrors() signal has been emitted.</para>
            <para>If there are no errors during the SSL handshake phase (i.e., the identity of the peer is established with no problems), QSslSocket will not emit the sslErrors() signal, and it is unnecessary to call this function.</para>
            <para>Warning: Be sure to always let the user inspect the errors reported by the sslErrors() signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the connection should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</para>
            <para>See also sslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.ReadData(System.Char*,System.Int64)">
            <summary>
            <para>Reimplemented from QIODevice::readData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.WriteData(System.String,System.Int64)">
            <summary>
            <para>Reimplemented from QIODevice::writeData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddDefaultCaCertificates(System.String,QtNetwork.QSsl.EncodingFormat,QtCore.QRegExp.PatternSyntax)">
            <summary>
            <para>Searches all files in the path for certificates with the specified encoding and adds them to the default CA certificate database. path can be an explicit file, or it can contain wildcards in the format specified by syntax. Returns true if any CA certificates are added to the default database.</para>
            <para>Each SSL socket's CA certificate database is initialized to the default CA certificate database.</para>
            <para>See also defaultCaCertificates(), addCaCertificates(), and addDefaultCaCertificate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslSocket.AddDefaultCaCertificate(QtNetwork.QSslCertificate)">
            <summary>
            <para>Adds certificate to the default CA certificate database. Each SSL socket's CA certificate database is initialized to the default CA certificate database.</para>
            <para>See also defaultCaCertificates() and addCaCertificates().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.Encrypted">
            <summary>
            <para>This signal is emitted when QSslSocket enters encrypted mode. After this signal has been emitted, QSslSocket::isEncrypted() will return true, and all further transmissions on the socket will be encrypted.</para>
            <para>See also QSslSocket::connectToHostEncrypted() and QSslSocket::isEncrypted().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.PeerVerifyError">
            <summary>
            <para>QSslSocket can emit this signal several times during the SSL handshake, before encryption has been established, to indicate that an error has occurred while establishing the identity of the peer. The error is usually an indication that QSslSocket is unable to securely identify the peer.</para>
            <para>This signal provides you with an early indication when something's wrong. By connecting to this signal, you can manually choose to tear down the connection from inside the connected slot before the handshake has completed. If no action is taken, QSslSocket will proceed to emitting QSslSocket::sslErrors().</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also sslErrors().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.ModeChanged">
            <summary>
            <para>This signal is emitted when QSslSocket changes from QSslSocket::UnencryptedMode to either QSslSocket::SslClientMode or QSslSocket::SslServerMode. mode is the new mode.</para>
            <para>See also QSslSocket::mode().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.EncryptedBytesWritten">
            <summary>
            <para>This signal is emitted when QSslSocket writes its encrypted data to the network. The written parameter contains the number of bytes that were successfully written.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also QIODevice::bytesWritten().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QSslSocket.PreSharedKeyAuthenticationRequired">
            <summary>
            <para>QSslSocket emits this signal when it negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</para>
            <para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs.</para>
            <para>Note: Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</para>
            <para>Note: The authenticator object is owned by the socket and must not be deleted by the application.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            <para>See also QSslPreSharedKeyAuthenticator.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.Protocol">
            <summary>
            <para>Returns the socket's SSL protocol. By default, QSsl::SecureProtocols is used.</para>
            <para>See also setProtocol().</para>
            <para></para>
            <para>Sets the socket's SSL protocol to protocol. This will affect the next initiated handshake; calling this function on an already-encrypted socket will not affect the socket's protocol.</para>
            <para>See also protocol().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.peerVerifyMode">
            <summary>
            <para>Returns the socket's verify mode. This mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
            <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients and QueryPeer for servers.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also setPeerVerifyMode(), peerVerifyDepth(), and mode().</para>
            <para></para>
            <para>Sets the socket's verify mode to mode. This mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
            <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients and QueryPeer for servers.</para>
            <para>Setting this mode after encryption has started has no effect on the current connection.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also peerVerifyMode(), setPeerVerifyDepth(), and mode().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PeerVerifyDepth">
            <summary>
            <para>Returns the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</para>
            <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also setPeerVerifyDepth() and peerVerifyMode().</para>
            <para></para>
            <para>Sets the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, to depth. Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</para>
            <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also peerVerifyDepth() and setPeerVerifyMode().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PeerVerifyName">
            <summary>
            <para>Returns the different hostname for the certificate validation, as set by setPeerVerifyName or by connectToHostEncrypted.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also setPeerVerifyName() and connectToHostEncrypted().</para>
            <para></para>
            <para>Sets a different host name, given by hostName, for the certificate validation instead of the one used for the TCP connection.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also peerVerifyName() and connectToHostEncrypted().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.ReadBufferSize">
            <summary>
            <para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call read() or readAll().</para>
            <para>A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</para>
            <para>See also setReadBufferSize() and read().</para>
            <para></para>
            <para>Sets the size of QAbstractSocket's internal read buffer to be size bytes.</para>
            <para>If the buffer size is limited to a certain size, QAbstractSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</para>
            <para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</para>
            <para>Only QTcpSocket uses QAbstractSocket's internal buffer; QUdpSocket does not use any buffering at all, but rather relies on the implicit buffering provided by the operating system. Because of this, calling this function on QUdpSocket has no effect.</para>
            <para>See also readBufferSize() and read().</para>
            <para></para>
            <para>Reimplemented from QAbstractSocket::setReadBufferSize().</para>
            <para>Sets the size of QSslSocket's internal read buffer to be size bytes.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SslConfiguration">
            <summary>
            <para>Returns the socket's SSL configuration state. The default SSL configuration of a socket is to use the default ciphers, default CA certificates, no local private key or certificate.</para>
            <para>The SSL configuration also contains fields that can change with time without notice.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also setSslConfiguration(), localCertificate(), peerCertificate(), peerCertificateChain(), sessionCipher(), privateKey(), ciphers(), and caCertificates().</para>
            <para></para>
            <para>Sets the socket's SSL configuration to be the contents of configuration. This function sets the local certificate, the ciphers, the private key and the CA certificates to those stored in configuration.</para>
            <para>It is not possible to set the SSL-state related fields.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also sslConfiguration(), setLocalCertificate(), setPrivateKey(), setCaCertificates(), and setCiphers().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.LocalCertificate">
            <summary>
            <para>Returns the socket's local certificate, or an empty certificate if no local certificate has been assigned.</para>
            <para>See also setLocalCertificate() and privateKey().</para>
            <para></para>
            <para>Sets the socket's local certificate to certificate. The local certificate is necessary if you need to confirm your identity to the peer. It is used together with the private key; if you set the local certificate, you must also set the private key.</para>
            <para>The local certificate and private key are always necessary for server sockets, but are also rarely used by client sockets if the server requires the client to authenticate.</para>
            <para>See also localCertificate() and setPrivateKey().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PrivateKey">
            <summary>
            <para>Returns this socket's private key.</para>
            <para>See also setPrivateKey() and localCertificate().</para>
            <para></para>
            <para>Sets the socket's private key to key. The private key and the local certificate are used by clients and servers that must prove their identity to SSL peers.</para>
            <para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</para>
            <para>See also privateKey() and setLocalCertificate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.BytesAvailable">
            <summary>
            <para>Reimplemented from QIODevice::bytesAvailable().</para>
            <para>Returns the number of decrypted bytes that are immediately available for reading.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.BytesToWrite">
            <summary>
            <para>Reimplemented from QIODevice::bytesToWrite().</para>
            <para>Returns the number of unencrypted bytes that are waiting to be encrypted and written to the network.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.AtEnd">
            <summary>
            <para>Reimplemented from QIODevice::atEnd().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.Mode">
            <summary>
            <para>Returns the current mode for the socket; either UnencryptedMode, where QSslSocket behaves identially to QTcpSocket, or one of SslClientMode or SslServerMode, where the client is either negotiating or in encrypted mode.</para>
            <para>When the mode changes, QSslSocket emits modeChanged()</para>
            <para>See also SslMode.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.IsEncrypted">
            <summary>
            <para>Returns true if the socket is encrypted; otherwise, false is returned.</para>
            <para>An encrypted socket encrypts all data that is written by calling write() or putChar() before the data is written to the network, and decrypts all incoming data as the data is received from the network, before you call read(), readLine() or getChar().</para>
            <para>QSslSocket emits encrypted() when it enters encrypted mode.</para>
            <para>You can call sessionCipher() to find which cryptographic cipher is used to encrypt and decrypt your data.</para>
            <para>See also mode().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.Flush">
            <summary>
            <para>This function writes as much as possible from the internal write buffer to the underlying network socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</para>
            <para>Call this function if you need QSslSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QAbstractSocket will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call waitForBytesWritten() instead.</para>
            <para>See also write() and waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.EncryptedBytesAvailable">
            <summary>
            <para>Returns the number of encrypted bytes that are awaiting decryption. Normally, this function will return 0 because QSslSocket decrypts its incoming data as soon as it can.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.EncryptedBytesToWrite">
            <summary>
            <para>Returns the number of encrypted bytes that are waiting to be written to the network.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.PeerCertificate">
            <summary>
            <para>Returns the peer's digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</para>
            <para>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</para>
            <para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the sslErrors() signal or the encrypted() signal.</para>
            <para>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</para>
            <para>If you want to check the peer's complete chain of certificates, use peerCertificateChain() to get them all at once.</para>
            <para>See also peerCertificateChain().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SessionCipher">
            <summary>
            <para>Returns the socket's cryptographic cipher, or a null cipher if the connection isn't encrypted. The socket's cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</para>
            <para>QSslSocket also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</para>
            <para>See also ciphers(), setCiphers(), setDefaultCiphers(), defaultCiphers(), and supportedCiphers().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SessionProtocol">
            <summary>
            <para>Returns the socket's SSL/TLS protocol or UnknownProtocol if the connection isn't encrypted. The socket's protocol for the session is set during the handshake phase.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            <para>See also protocol() and setProtocol().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SupportsSsl">
            <summary>
            <para>Returns true if this platform supports SSL; otherwise, returns false. If the platform doesn't support SSL, the socket will fail in the connection phase.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SslLibraryVersionNumber">
            <summary>
            <para>Returns the version number of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return an undefined value.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SslLibraryVersionString">
            <summary>
            <para>Returns the version string of the SSL library in use. Note that this is the version of the library in use at run-time not compile time. If no SSL support is available then this will return an empty value.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SslLibraryBuildVersionNumber">
            <summary>
            <para>Returns the version number of the SSL library in use at compile time. If no SSL support is available then this will return an undefined value.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            <para>See also sslLibraryVersionNumber().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslSocket.SslLibraryBuildVersionString">
            <summary>
            <para>Returns the version string of the SSL library in use at compile time. If no SSL support is available then this will return an empty value.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            <para>See also sslLibraryVersionString().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslSocket.SslMode">
            <summary>
            <para>Describes the connection modes available for QSslSocket.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.SslMode.UnencryptedMode">
            <summary>The socket is unencrypted. Its behavior is identical to QTcpSocket.</summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.SslMode.SslClientMode">
            <summary>The socket is a client-side SSL socket. It is either alreayd encrypted, or it is in the SSL handshake phase (see QSslSocket::isEncrypted()).</summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.SslMode.SslServerMode">
            <summary>The socket is a server-side SSL socket. It is either already encrypted, or it is in the SSL handshake phase (see QSslSocket::isEncrypted()).</summary>
        </member>
        <member name="T:QtNetwork.QSslSocket.PeerVerifyMode">
            <summary>
            <para>Describes the peer verification modes for QSslSocket. The default mode is AutoVerifyPeer, which selects an appropriate mode depending on the socket's QSocket::SslMode.</para>
            <para>This enum was introduced or modified in  Qt 4.4.</para>
            <para>See also QSslSocket::peerVerifyMode().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.VerifyNone">
            <summary>QSslSocket will not request a certificate from the peer. You can set this mode if you are not interested in the identity of the other side of the connection. The connection will still be encrypted, and your socket will still send its local certificate to the peer if it's requested.</summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.QueryPeer">
            <summary>QSslSocket will request a certificate from the peer, but does not require this certificate to be valid. This is useful when you want to display peer certificate details to the user without affecting the actual SSL handshake. This mode is the default for servers.</summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.VerifyPeer">
            <summary>QSslSocket will request a certificate from the peer during the SSL handshake phase, and requires that this certificate is valid. On failure, QSslSocket will emit the QSslSocket::sslErrors() signal. This mode is the default for clients.</summary>
        </member>
        <member name="F:QtNetwork.QSslSocket.PeerVerifyMode.AutoVerifyPeer">
            <summary>QSslSocket will automatically use QueryPeer for server sockets and VerifyPeer for client sockets.</summary>
        </member>
        <member name="T:QtNetwork.QSslConfiguration">
            <summary>
            <para>The QSslConfiguration class holds the configuration and state of an SSL connection</para>
            </summary>
            <remarks>
            <para>QSslConfiguration is used by Qt networking classes to relay information about an open SSL connection and to allow the application to control certain features of that connection.</para>
            <para>The settings that QSslConfiguration currently supports are:</para>
            <para></para>
            <para>The SSL/TLS protocol to be used</para>
            <para>The certificate to be presented to the peer during connection and its associated private key</para>
            <para>The ciphers allowed to be used for encrypting the connection</para>
            <para>The list of Certificate Authorities certificates that are used to validate the peer's certificate</para>
            <para></para>
            <para>These settings are applied only during the connection handshake. Setting them after the connection has been established has no effect.</para>
            <para>The state that QSslConfiguration supports are:</para>
            <para></para>
            <para>The certificate the peer presented during handshake, along with the chain leading to a CA certificate</para>
            <para>The cipher used to encrypt this session</para>
            <para></para>
            <para>The state can only be obtained once the SSL connection starts, but not necessarily before it's done. Some settings may change during the course of the SSL connection without need to restart it (for instance, the cipher can be changed over time).</para>
            <para>State in QSslConfiguration objects cannot be changed.</para>
            <para>QSslConfiguration can be used with QSslSocket and the Network Access API.</para>
            <para>Note that changing settings in QSslConfiguration is not enough to change the settings in the related SSL connection. You must call setSslConfiguration on a modified QSslConfiguration object to achieve that. The following example illustrates how to change the protocol to TLSv1_0 in a QSslSocket object:</para>
            <para>QSslConfiguration config = sslSocket.sslConfiguration();</para>
            <para>config.setProtocol(QSsl::TlsV1_0);</para>
            <para>sslSocket.setSslConfiguration(config);</para>
            <para></para>
            <para>See also QSsl::SslProtocol, QSslCertificate, QSslCipher, QSslKey, QSslSocket, QNetworkAccessManager, QSslSocket::sslConfiguration(), and QSslSocket::setSslConfiguration().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.#ctor">
            <summary>
            <para>Constructs an empty SSL configuration. This configuration contains no valid settings and the state will be empty. isNull() will return true after this constructor is called.</para>
            <para>Once any setter methods are called, isNull() will return false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.#ctor(QtNetwork.QSslConfiguration)">
            <summary>
            <para>Copies the configuration and state of other. If other is null, this object will be null too.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.Swap(QtNetwork.QSslConfiguration)">
            <summary>
            <para>Swaps this SSL configuration instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.op_Equality(QtNetwork.QSslConfiguration,QtNetwork.QSslConfiguration)">
            <summary>
            <para>Returns true if this QSslConfiguration object is equal to other.</para>
            <para>Two QSslConfiguration objects are considered equal if they have the exact same settings and state.</para>
            <para>See also operator!=().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.op_Inequality(QtNetwork.QSslConfiguration,QtNetwork.QSslConfiguration)">
            <summary>
            <para>Returns true if this QSslConfiguration differs from other. Two QSslConfiguration objects are considered different if any state or setting is different.</para>
            <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.SetSslOption(QtNetwork.QSsl.SslOption,System.Boolean)">
            <summary>
            <para>Enables or disables an SSL compatibility option. If on is true, the option is enabled. If on is false, the option is disabled.</para>
            <para>See also testSslOption().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslConfiguration.TestSslOption(QtNetwork.QSsl.SslOption)">
            <summary>
            <para>Returns true if the specified SSL compatibility option is enabled.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also setSslOption().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.NextProtocolSpdy3_0">
            <summary>
            <para>This variable holds the value used for negotiating SPDY 3.0 during the Next Protocol Negotiation.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.NextProtocolHttp1_1">
            <summary>
            <para>This variable holds the value used for negotiating HTTP 1.1 during the Next Protocol Negotiation.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.Protocol">
            <summary>
            <para>Returns the protocol setting for this SSL configuration.</para>
            <para>See also setProtocol().</para>
            <para></para>
            <para>Sets the protocol setting for this configuration to be protocol.</para>
            <para>Setting the protocol once the connection has already been established has no effect.</para>
            <para>See also protocol().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PeerVerifyMode">
            <summary>
            <para>Returns the verify mode. This mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
            <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients, QueryPeer for servers.</para>
            <para>See also setPeerVerifyMode().</para>
            <para></para>
            <para>Sets the verify mode to mode. This mode decides whether QSslSocket should request a certificate from the peer (i.e., the client requests a certificate from the server, or a server requesting a certificate from the client), and whether it should require that this certificate is valid.</para>
            <para>The default mode is AutoVerifyPeer, which tells QSslSocket to use VerifyPeer for clients, QueryPeer for servers.</para>
            <para>See also peerVerifyMode().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PeerVerifyDepth">
            <summary>
            <para>Returns the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, or 0 (the default) if no maximum depth has been set, indicating that the whole certificate chain should be checked.</para>
            <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
            <para>See also setPeerVerifyDepth() and peerVerifyMode().</para>
            <para></para>
            <para>Sets the maximum number of certificates in the peer's certificate chain to be checked during the SSL handshake phase, to depth. Setting a depth of 0 means that no maximum depth is set, indicating that the whole certificate chain should be checked.</para>
            <para>The certificates are checked in issuing order, starting with the peer's own certificate, then its issuer's certificate, and so on.</para>
            <para>See also peerVerifyDepth() and setPeerVerifyMode().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.LocalCertificate">
            <summary>
            <para>Returns the certificate to be presented to the peer during the SSL handshake process.</para>
            <para>See also setLocalCertificate().</para>
            <para></para>
            <para>Sets the certificate to be presented to the peer during SSL handshake to be certificate.</para>
            <para>Setting the certificate once the connection has been established has no effect.</para>
            <para>A certificate is the means of identification used in the SSL process. The local certificate is used by the remote end to verify the local user's identity against its list of Certification Authorities. In most cases, such as in HTTP web browsing, only servers identify to the clients, so the client does not send a certificate.</para>
            <para>See also localCertificate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PrivateKey">
            <summary>
            <para>Returns the SSL key assigned to this connection or a null key if none has been assigned yet.</para>
            <para>See also setPrivateKey() and localCertificate().</para>
            <para></para>
            <para>Sets the connection's private key to key. The private key and the local certificate are used by clients and servers that must prove their identity to SSL peers.</para>
            <para>Both the key and the local certificate are required if you are creating an SSL server socket. If you are creating an SSL client socket, the key and local certificate are required if your client must identify itself to an SSL server.</para>
            <para>See also privateKey() and setLocalCertificate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.SessionTicket">
            <summary>
            <para>If QSsl::SslOptionDisableSessionPersistence was turned off, this function returns the session ticket used in the SSL handshake in ASN.1 format, suitable to e.g. be persisted to disk. If no session ticket was used or QSsl::SslOptionDisableSessionPersistence was not turned off, this function returns an empty QByteArray.</para>
            <para>Note: When persisting the session ticket to disk or similar, be careful not to expose the session to a potential attacker, as knowledge of the session allows for eavesdropping on data encrypted with the session parameters.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also setSessionTicket(), QSsl::SslOptionDisableSessionPersistence, and setSslOption().</para>
            <para></para>
            <para>Sets the session ticket to be used in an SSL handshake. QSsl::SslOptionDisableSessionPersistence must be turned off for this to work, and sessionTicket must be in ASN.1 format as returned by sessionTicket().</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also sessionTicket(), QSsl::SslOptionDisableSessionPersistence, and setSslOption().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.DefaultConfiguration">
            <summary>
            <para>Returns the default SSL configuration to be used in new SSL connections.</para>
            <para>The default SSL configuration consists of:</para>
            <para></para>
            <para>no local certificate and no private key</para>
            <para>protocol SecureProtocols (meaning either TLS 1.0 or SSL 3 will be used)</para>
            <para>the system's default CA certificate list</para>
            <para>the cipher list equal to the list of the SSL libraries' supported SSL ciphers that are 128 bits or more</para>
            <para></para>
            <para>See also QSslSocket::supportedCiphers() and setDefaultConfiguration().</para>
            <para></para>
            <para>Sets the default SSL configuration to be used in new SSL connections to be configuration. Existing connections are not affected by this call.</para>
            <para>See also QSslSocket::supportedCiphers() and defaultConfiguration().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.IsNull">
            <summary>
            <para>Returns true if this is a null QSslConfiguration object.</para>
            <para>A QSslConfiguration object is null if it has been default-constructed and no setter methods have been called.</para>
            <para>See also setProtocol(), setLocalCertificate(), setPrivateKey(), setCiphers(), and setCaCertificates().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.PeerCertificate">
            <summary>
            <para>Returns the peer's digital certificate (i.e., the immediate certificate of the host you are connected to), or a null certificate, if the peer has not assigned a certificate.</para>
            <para>The peer certificate is checked automatically during the handshake phase, so this function is normally used to fetch the certificate for display or for connection diagnostic purposes. It contains information about the peer, including its host name, the certificate issuer, and the peer's public key.</para>
            <para>Because the peer certificate is set during the handshake phase, it is safe to access the peer certificate from a slot connected to the QSslSocket::sslErrors() signal, QNetworkReply::sslErrors() signal, or the QSslSocket::encrypted() signal.</para>
            <para>If a null certificate is returned, it can mean the SSL handshake failed, or it can mean the host you are connected to doesn't have a certificate, or it can mean there is no connection.</para>
            <para>If you want to check the peer's complete chain of certificates, use peerCertificateChain() to get them all at once.</para>
            <para>See also peerCertificateChain(), QSslSocket::sslErrors(), QSslSocket::ignoreSslErrors(), QNetworkReply::sslErrors(), and QNetworkReply::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.SessionCipher">
            <summary>
            <para>Returns the socket's cryptographic cipher, or a null cipher if the connection isn't encrypted. The socket's cipher for the session is set during the handshake phase. The cipher is used to encrypt and decrypt data transmitted through the socket.</para>
            <para>The SSL infrastructure also provides functions for setting the ordered list of ciphers from which the handshake phase will eventually select the session cipher. This ordered list must be in place before the handshake phase begins.</para>
            <para>See also ciphers(), setCiphers(), and QSslSocket::supportedCiphers().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.SessionProtocol">
            <summary>
            <para>Returns the socket's SSL/TLS protocol or UnknownProtocol if the connection isn't encrypted. The socket's protocol for the session is set during the handshake phase.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            <para>See also protocol() and setProtocol().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.SessionTicketLifeTimeHint">
            <summary>
            <para>If QSsl::SslOptionDisableSessionPersistence was turned off, this function returns the session ticket life time hint sent by the server (which might be 0). If the server did not send a session ticket (e.g. when resuming a session or when the server does not support it) or QSsl::SslOptionDisableSessionPersistence was not turned off, this function returns -1.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also sessionTicket(), QSsl::SslOptionDisableSessionPersistence, and setSslOption().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.NextNegotiatedProtocol">
            <summary>
            <para>This function returns the protocol negotiated with the server if the Next Protocol Negotiation (NPN) TLS extension was enabled. In order for the NPN extension to be enabled, setAllowedNextProtocols() needs to be called explicitly before connecting to the server.</para>
            <para>If no protocol could be negotiated or the extension was not enabled, this function returns a QByteArray which is null.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            <para>See also setAllowedNextProtocols() and nextProtocolNegotiationStatus().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslConfiguration.nextProtocolNegotiationStatus">
            <summary>
            <para>This function returns the status of the Next Protocol Negotiation (NPN). If the feature has not been enabled through setAllowedNextProtocols(), this function returns NextProtocolNegotiationNone. The status will be set before emitting the encrypted() signal.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            <para>See also setAllowedNextProtocols(), allowedNextProtocols(), nextNegotiatedProtocol(), and QSslConfiguration::NextProtocolNegotiationStatus.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslConfiguration.NextProtocolNegotiationStatus">
            <summary>
            <para>Describes the status of the Next Protocol Negotiation (NPN).</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QSslConfiguration.NextProtocolNegotiationStatus.NextProtocolNegotiationNone">
            <summary>No application protocol has been negotiated (yet).</summary>
        </member>
        <member name="F:QtNetwork.QSslConfiguration.NextProtocolNegotiationStatus.NextProtocolNegotiationNegotiated">
            <summary>A next protocol has been negotiated (see nextNegotiatedProtocol()).</summary>
        </member>
        <member name="F:QtNetwork.QSslConfiguration.NextProtocolNegotiationStatus.NextProtocolNegotiationUnsupported">
            <summary>The client and server could not agree on a common next application protocol.</summary>
        </member>
        <member name="T:QtNetwork.QSslPreSharedKeyAuthenticator">
            <summary>
            <para>The QSslPreSharedKeyAuthenticator class provides authentication data for pre shared keys (PSK) ciphersuites.</para>
            </summary>
            <remarks>
            <para>The QSslPreSharedKeyAuthenticator class is used by an SSL socket to provide the required authentication data in a pre shared key (PSK) ciphersuite.</para>
            <para>In a PSK handshake, the client must derive a key, which must match the key set on the server. The exact algorithm of deriving the key depends on the application; however, for this purpose, the server may send an identity hint to the client. This hint, combined with other information (for instance a passphrase), is then used by the client to construct the shared key.</para>
            <para>The QSslPreSharedKeyAuthenticator provides means to client applications for completing the PSK handshake. The client application needs to connect a slot to the QSslSocket::preSharedKeyAuthenticationRequired() signal:</para>
            <para>connect(socket, &amp;QSslSocket::preSharedKeyAuthenticationRequired,</para>
            <para>        this, &amp;AuthManager::handlePreSharedKeyAuthentication);</para>
            <para>The signal carries a QSslPreSharedKeyAuthenticator object containing the identity hint the server sent to the client, and which must be filled with the corresponding client identity and the derived key:</para>
            <para>void AuthManager::handlePreSharedKeyAuthentication(QSslPreSharedKeyAuthenticator *authenticator)</para>
            <para>{</para>
            <para>    authenticator-&gt;setIdentity(&quot;My Qt App&quot;);</para>
            <para></para>
            <para>    const QByteArray key = deriveKey(authenticator-&gt;identityHint(), passphrase);</para>
            <para>    authenticator-&gt;setPreSharedKey(key);</para>
            <para>}</para>
            <para>Note: PSK ciphersuites are supported only when using OpenSSL 1.0.1 (or greater) as the SSL backend.</para>
            <para></para>
            <para>See also QSslSocket.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslPreSharedKeyAuthenticator.#ctor">
            <summary>
            <para>Constructs a default QSslPreSharedKeyAuthenticator object.</para>
            <para>The identity hint, the identity and the key will be initialized to empty byte arrays; the maximum length for both the identity and the key will be initialized to 0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslPreSharedKeyAuthenticator.#ctor(QtNetwork.QSslPreSharedKeyAuthenticator)">
            <summary>
            <para>Constructs a QSslPreSharedKeyAuthenticator object as a copy of authenticator.</para>
            <para>See also operator=().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslPreSharedKeyAuthenticator.Swap(QtNetwork.QSslPreSharedKeyAuthenticator)">
            <summary>
            <para>Swaps the QSslPreSharedKeyAuthenticator object authenticator with this object. This operation is very fast and never fails.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslPreSharedKeyAuthenticator.op_Inequality(QtNetwork.QSslPreSharedKeyAuthenticator,QtNetwork.QSslPreSharedKeyAuthenticator)">
            <summary>
            <para>Returns true if the authenticator object lhs is different than rhs; false otherwise.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslPreSharedKeyAuthenticator.Identity">
            <summary>
            <para>Returns the PSK client identity.</para>
            <para>See also setIdentity().</para>
            <para></para>
            <para>Sets the PSK client identity (to be advised to the server) to identity.</para>
            <para>Note: it is possible to set an identity whose length is greater than maximumIdentityLength(); in this case, only the first maximumIdentityLength() bytes will be actually sent to the server.</para>
            <para>See also identity() and maximumIdentityLength().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslPreSharedKeyAuthenticator.PreSharedKey">
            <summary>
            <para>Returns the pre shared key.</para>
            <para>See also setPreSharedKey().</para>
            <para></para>
            <para>Sets the pre shared key to preSharedKey.</para>
            <para>Note: it is possible to set a key whose length is greater than the maximumPreSharedKeyLength(); in this case, only the first maximumPreSharedKeyLength() bytes will be actually sent to the server.</para>
            <para>See also preSharedKey(), maximumPreSharedKeyLength(), and QByteArray::fromHex().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslPreSharedKeyAuthenticator.IdentityHint">
            <summary>
            <para>Returns the PSK identity hint as provided by the server. The interpretation of this hint is left to the application.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslPreSharedKeyAuthenticator.MaximumIdentityLength">
            <summary>
            <para>Returns the maximum length, in bytes, of the PSK client identity.</para>
            <para>Note: it is possible to set an identity whose length is greater than maximumIdentityLength(); in this case, only the first maximumIdentityLength() bytes will be actually sent to the server.</para>
            <para>See also setIdentity().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslPreSharedKeyAuthenticator.MaximumPreSharedKeyLength">
            <summary>
            <para>Returns the maximum length, in bytes, of the pre shared key.</para>
            <para>Note: it is possible to set a key whose length is greater than the maximumPreSharedKeyLength(); in this case, only the first maximumPreSharedKeyLength() bytes will be actually sent to the server.</para>
            <para>See also setPreSharedKey().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkAccessManager">
            <summary>
            <para>The QNetworkAccessManager class allows the application to send network requests and receive replies</para>
            </summary>
            <remarks>
            <para>The Network Access API is constructed around one QNetworkAccessManager object, which holds the common configuration and settings for the requests it sends. It contains the proxy and cache configuration, as well as the signals related to such issues, and reply signals that can be used to monitor the progress of a network operation. One QNetworkAccessManager should be enough for the whole Qt application.</para>
            <para>Once a QNetworkAccessManager object has been created, the application can use it to send requests over the network. A group of standard functions are supplied that take a request and optional data, and each return a QNetworkReply object. The returned object is used to obtain any data returned in response to the corresponding request.</para>
            <para>A simple download off the network could be accomplished with:</para>
            <para>QNetworkAccessManager *manager = new QNetworkAccessManager(this);</para>
            <para>connect(manager, SIGNAL(finished(QNetworkReply*)),</para>
            <para>        this, SLOT(replyFinished(QNetworkReply*)));</para>
            <para></para>
            <para>manager-&gt;get(QNetworkRequest(QUrl(&quot;http://qt-project.org&quot;)));</para>
            <para>QNetworkAccessManager has an asynchronous API. When the replyFinished slot above is called, the parameter it takes is the QNetworkReply object containing the downloaded data as well as meta-data (headers, etc.).</para>
            <para>Note: After the request has finished, it is the responsibility of the user to delete the QNetworkReply object at an appropriate time. Do not directly delete it inside the slot connected to finished(). You can use the deleteLater() function.</para>
            <para>Note: QNetworkAccessManager queues the requests it receives. The number of requests executed in parallel is dependent on the protocol. Currently, for the HTTP protocol on desktop platforms, 6 requests are executed in parallel for one host/port combination.</para>
            <para>A more involved example, assuming the manager is already existent, can be:</para>
            <para>QNetworkRequest request;</para>
            <para>request.setUrl(QUrl(&quot;http://qt-project.org&quot;));</para>
            <para>request.setRawHeader(&quot;User-Agent&quot;, &quot;MyOwnBrowser 1.0&quot;);</para>
            <para></para>
            <para>QNetworkReply *reply = manager-&gt;get(request);</para>
            <para>connect(reply, SIGNAL(readyRead()), this, SLOT(slotReadyRead()));</para>
            <para>connect(reply, SIGNAL(error(QNetworkReply::NetworkError)),</para>
            <para>        this, SLOT(slotError(QNetworkReply::NetworkError)));</para>
            <para>connect(reply, SIGNAL(sslErrors(QList&lt;QSslError&gt;)),</para>
            <para>        this, SLOT(slotSslErrors(QList&lt;QSslError&gt;)));</para>
            <para></para>
            <para>Network and Roaming Support</para>
            <para>With the addition of the Bearer Management API to Qt 4.7 QNetworkAccessManager gained the ability to manage network connections. QNetworkAccessManager can start the network interface if the device is offline and terminates the interface if the current process is the last one to use the uplink. Note that some platforms utilize grace periods from when the last application stops using a uplink until the system actually terminates the connectivity link. Roaming is equally transparent. Any queued/pending network requests are automatically transferred to the new access point.</para>
            <para>Clients wanting to utilize this feature should not require any changes. In fact it is likely that existing platform specific connection code can simply be removed from the application.</para>
            <para>Note: The network and roaming support in QNetworkAccessManager is conditional upon the platform supporting connection management. The QNetworkConfigurationManager::NetworkSessionRequired can be used to detect whether QNetworkAccessManager utilizes this feature.</para>
            <para></para>
            <para>See also QNetworkRequest, QNetworkReply, and QNetworkProxy.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QNetworkAccessManager object that is the center of the Network Access API and sets parent as the parent object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.ClearAccessCache">
            <summary>
            <para>Flushes the internal cache of authentication data and network connections.</para>
            <para>This function is useful for doing auto tests.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Head(QtNetwork.QNetworkRequest)">
            <summary>
            <para>Posts a request to obtain the network headers for request and returns a new QNetworkReply object which will contain such headers.</para>
            <para>The function is named after the HTTP request associated (HEAD).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Get(QtNetwork.QNetworkRequest)">
            <summary>
            <para>Posts a request to obtain the contents of the target request and returns a new QNetworkReply object opened for reading which emits the readyRead() signal whenever new data arrives.</para>
            <para>The contents as well as associated headers will be downloaded.</para>
            <para>See also post(), put(), deleteResource(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Post(QtNetwork.QNetworkRequest,QtCore.QIODevice)">
            <summary>
            <para>Sends an HTTP POST request to the destination specified by request and returns a new QNetworkReply object opened for reading that will contain the reply sent by the server. The contents of the data device will be uploaded to the server.</para>
            <para>data must be open for reading and must remain valid until the finished() signal is emitted for this reply.</para>
            <para>Note: Sending a POST request on protocols other than HTTP and HTTPS is undefined and will probably fail.</para>
            <para>See also get(), put(), deleteResource(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Post(QtNetwork.QNetworkRequest,QtCore.QByteArray)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sends the contents of the data byte array to the destination specified by request.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Post(QtNetwork.QNetworkRequest,QtNetwork.QHttpMultiPart)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sends the contents of the multiPart message to the destination specified by request.</para>
            <para>This can be used for sending MIME multipart messages over HTTP.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also QHttpMultiPart, QHttpPart, and put().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Put(QtNetwork.QNetworkRequest,QtCore.QIODevice)">
            <summary>
            <para>Uploads the contents of data to the destination request and returnes a new QNetworkReply object that will be open for reply.</para>
            <para>data must be opened for reading when this function is called and must remain valid until the finished() signal is emitted for this reply.</para>
            <para>Whether anything will be available for reading from the returned object is protocol dependent. For HTTP, the server may send a small HTML page indicating the upload was successful (or not). Other protocols will probably have content in their replies.</para>
            <para>Note: For HTTP, this request will send a PUT request, which most servers do not allow. Form upload mechanisms, including that of uploading files through HTML forms, use the POST mechanism.</para>
            <para>See also get(), post(), deleteResource(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Put(QtNetwork.QNetworkRequest,QtCore.QByteArray)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sends the contents of the data byte array to the destination specified by request.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.Put(QtNetwork.QNetworkRequest,QtNetwork.QHttpMultiPart)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sends the contents of the multiPart message to the destination specified by request.</para>
            <para>This can be used for sending MIME multipart messages over HTTP.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also QHttpMultiPart, QHttpPart, and post().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.DeleteResource(QtNetwork.QNetworkRequest)">
            <summary>
            <para>Sends a request to delete the resource identified by the URL of request.</para>
            <para>Note: This feature is currently available for HTTP only, performing an HTTP DELETE request.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also get(), post(), put(), and sendCustomRequest().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.SendCustomRequest(QtNetwork.QNetworkRequest,QtCore.QByteArray,QtCore.QIODevice)">
            <summary>
            <para>Sends a custom request to the server identified by the URL of request.</para>
            <para>It is the user's responsibility to send a verb to the server that is valid according to the HTTP specification.</para>
            <para>This method provides means to send verbs other than the common ones provided via get() or post() etc., for instance sending an HTTP OPTIONS command.</para>
            <para>If data is not empty, the contents of the data device will be uploaded to the server; in that case, data must be open for reading and must remain valid until the finished() signal is emitted for this reply.</para>
            <para>Note: This feature is currently available for HTTP(S) only.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also get(), post(), put(), and deleteResource().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.ConnectToHostEncrypted(System.String,System.UInt16,QtNetwork.QSslConfiguration)">
            <summary>
            <para>Initiates a connection to the host given by hostName at port port, using sslConfiguration. This function is useful to complete the TCP and SSL handshake to a host before the HTTPS request is made, resulting in a lower network latency.</para>
            <para>Note: Preconnecting a SPDY connection can be done by calling setAllowedNextProtocols() on sslConfiguration with QSslConfiguration::NextProtocolSpdy3_0 contained in the list of allowed protocols. When using SPDY, one single connection per host is enough, i.e. calling this method multiple times per host will not result in faster network transactions.</para>
            <para>Note: This function has no possibility to report errors.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also connectToHost(), get(), post(), put(), and deleteResource().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.ConnectToHost(System.String,System.UInt16)">
            <summary>
            <para>Initiates a connection to the host given by hostName at port port. This function is useful to complete the TCP handshake to a host before the HTTP request is made, resulting in a lower network latency.</para>
            <para>Note: This function has no possibility to report errors.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also connectToHostEncrypted(), get(), post(), put(), and deleteResource().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.CreateRequest(QtNetwork.QNetworkAccessManager.Operation,QtNetwork.QNetworkRequest,QtCore.QIODevice)">
            <summary>
            <para>Returns a new QNetworkReply object to handle the operation op and request req. The device outgoingData is always 0 for Get and Head requests, but is the value passed to post() and put() in those operations (the QByteArray variants will pass a QBuffer object).</para>
            <para>The default implementation calls QNetworkCookieJar::cookiesForUrl() on the cookie jar set with setCookieJar() to obtain the cookies to be sent to the remote server.</para>
            <para>The returned object must be in an open state.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAccessManager.ConnectToHostEncrypted(System.String,System.UInt16)">
            <summary>
            <para>Initiates a connection to the host given by hostName at port port, using sslConfiguration. This function is useful to complete the TCP and SSL handshake to a host before the HTTPS request is made, resulting in a lower network latency.</para>
            <para>Note: Preconnecting a SPDY connection can be done by calling setAllowedNextProtocols() on sslConfiguration with QSslConfiguration::NextProtocolSpdy3_0 contained in the list of allowed protocols. When using SPDY, one single connection per host is enough, i.e. calling this method multiple times per host will not result in faster network transactions.</para>
            <para>Note: This function has no possibility to report errors.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also connectToHost(), get(), post(), put(), and deleteResource().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.ProxyAuthenticationRequired">
            <summary>
            <para>This signal is emitted whenever a proxy requests authentication and QNetworkAccessManager cannot find a valid, cached credential. The slot connected to this signal should fill in the credentials for the proxy proxy in the authenticator object.</para>
            <para>QNetworkAccessManager will cache the credentials internally. The next time the proxy requests authentication, QNetworkAccessManager will automatically send the same credential without emitting the proxyAuthenticationRequired signal again.</para>
            <para>If the proxy rejects the credentials, QNetworkAccessManager will emit the signal again.</para>
            <para>See also proxy(), setProxy(), and authenticationRequired().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.AuthenticationRequired">
            <summary>
            <para>This signal is emitted whenever a final server requests authentication before it delivers the requested contents. The slot connected to this signal should fill the credentials for the contents (which can be determined by inspecting the reply object) in the authenticator object.</para>
            <para>QNetworkAccessManager will cache the credentials internally and will send the same values if the server requires authentication again, without emitting the authenticationRequired() signal. If it rejects the credentials, this signal will be emitted again.</para>
            <para>Note: To have the request not send credentials you must not call setUser() or setPassword() on the authenticator object. This will result in the finished() signal being emitted with a QNetworkReply with error AuthenticationRequiredError.</para>
            <para>Note: It is not possible to use a QueuedConnection to connect to this signal, as the connection will fail if the authenticator has not been filled in with new information when the signal returns.</para>
            <para>See also proxyAuthenticationRequired(), QAuthenticator::setUser(), and QAuthenticator::setPassword().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.Finished">
            <summary>
            <para>This signal is emitted whenever a pending network reply is finished. The reply parameter will contain a pointer to the reply that has just finished. This signal is emitted in tandem with the QNetworkReply::finished() signal.</para>
            <para>See QNetworkReply::finished() for information on the status that the object will be in.</para>
            <para>Note: Do not delete the reply object in the slot connected to this signal. Use deleteLater().</para>
            <para>See also QNetworkReply::finished() and QNetworkReply::error().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.Encrypted">
            <summary>
            <para>This signal is emitted when an SSL/TLS session has successfully completed the initial handshake. At this point, no user data has been transmitted. The signal can be used to perform additional checks on the certificate chain, for example to notify users when the certificate for a website has changed. The reply parameter specifies which network reply is responsible. If the reply does not match the expected criteria then it should be aborted by calling QNetworkReply::abort() by a slot connected to this signal. The SSL configuration in use can be inspected using the QNetworkReply::sslConfiguration() method.</para>
            <para>Internally, QNetworkAccessManager may open multiple connections to a server, in order to allow it process requests in parallel. These connections may be reused, which means that the encrypted() signal would not be emitted. This means that you are only guaranteed to receive this signal for the first connection to a site in the lifespan of the QNetworkAccessManager.</para>
            <para>This function was introduced in  Qt 5.1.</para>
            <para>See also QSslSocket::encrypted() and QNetworkReply::encrypted().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.PreSharedKeyAuthenticationRequired">
            <summary>
            <para>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required. The reply object is the QNetworkReply that is negotiating such ciphersuites.</para>
            <para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs.</para>
            <para>Note: Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</para>
            <para>Note: The authenticator object is owned by the reply and must not be deleted by the application.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            <para>See also QSslPreSharedKeyAuthenticator.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkAccessManager.NetworkAccessibleChanged">
            <summary>
            <para>This property holds whether the network is currently accessible via this network access manager.</para>
            <para>If the network is not accessible the network access manager will not process any new network requests, all such requests will fail with an error. Requests with URLs with the file:// scheme will still be processed.</para>
            <para>By default the value of this property reflects the physical state of the device. Applications may override it to disable all network requests via this network access manager by calling</para>
            <para>networkAccessManager-&gt;setNetworkAccessible(QNetworkAccessManager::NotAccessible);</para>
            <para>Network requests can be reenabled again by calling</para>
            <para>networkAccessManager-&gt;setNetworkAccessible(QNetworkAccessManager::Accessible);</para>
            <para>Note: Calling setNetworkAccessible() does not change the network state.</para>
            <para>This property was introduced in  Qt 4.7.</para>
            <para>Access functions:</para>
            <para></para>
            <para> NetworkAccessibility 	networkAccessible() const</para>
            <para> void 	setNetworkAccessible(NetworkAccessibility accessible)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	networkAccessibleChanged(QNetworkAccessManager::NetworkAccessibility accessible)</para>
            <para></para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.Proxy">
            <summary>
            <para>Returns the QNetworkProxy that the requests sent using this QNetworkAccessManager object will use. The default value for the proxy is QNetworkProxy::DefaultProxy.</para>
            <para>See also setProxy(), setProxyFactory(), and proxyAuthenticationRequired().</para>
            <para></para>
            <para>Sets the proxy to be used in future requests to be proxy. This does not affect requests that have already been sent. The proxyAuthenticationRequired() signal will be emitted if the proxy requests authentication.</para>
            <para>A proxy set with this function will be used for all requests issued by QNetworkAccessManager. In some cases, it might be necessary to select different proxies depending on the type of request being sent or the destination host. If that's the case, you should consider using setProxyFactory().</para>
            <para>See also proxy() and proxyAuthenticationRequired().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.ProxyFactory">
            <summary>
            <para>Returns the proxy factory that this QNetworkAccessManager object is using to determine the proxies to be used for requests.</para>
            <para>Note that the pointer returned by this function is managed by QNetworkAccessManager and could be deleted at any time.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also setProxyFactory() and proxy().</para>
            <para></para>
            <para>Sets the proxy factory for this class to be factory. A proxy factory is used to determine a more specific list of proxies to be used for a given request, instead of trying to use the same proxy value for all requests.</para>
            <para>All queries sent by QNetworkAccessManager will have type QNetworkProxyQuery::UrlRequest.</para>
            <para>For example, a proxy factory could apply the following rules:</para>
            <para></para>
            <para>if the target address is in the local network (for example, if the hostname contains no dots or if it's an IP address in the organization's range), return QNetworkProxy::NoProxy</para>
            <para>if the request is FTP, return an FTP proxy</para>
            <para>if the request is HTTP or HTTPS, then return an HTTP proxy</para>
            <para>otherwise, return a SOCKSv5 proxy server</para>
            <para></para>
            <para>The lifetime of the object factory will be managed by QNetworkAccessManager. It will delete the object when necessary.</para>
            <para>Note: If a specific proxy is set with setProxy(), the factory will not be used.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also proxyFactory(), setProxy(), and QNetworkProxyQuery.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.Cache">
            <summary>
            <para>Returns the cache that is used to store data obtained from the network.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also setCache().</para>
            <para></para>
            <para>Sets the manager's network cache to be the cache specified. The cache is used for all requests dispatched by the manager.</para>
            <para>Use this function to set the network cache object to a class that implements additional features, like saving the cookies to permanent storage.</para>
            <para>Note: QNetworkAccessManager takes ownership of the cache object.</para>
            <para>QNetworkAccessManager by default does not have a set cache. Qt provides a simple disk cache, QNetworkDiskCache, which can be used.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also cache() and QNetworkRequest::CacheLoadControl.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.CookieJar">
            <summary>
            <para>Returns the QNetworkCookieJar that is used to store cookies obtained from the network as well as cookies that are about to be sent.</para>
            <para>See also setCookieJar().</para>
            <para></para>
            <para>Sets the manager's cookie jar to be the cookieJar specified. The cookie jar is used by all requests dispatched by the manager.</para>
            <para>Use this function to set the cookie jar object to a class that implements additional features, like saving the cookies to permanent storage.</para>
            <para>Note: QNetworkAccessManager takes ownership of the cookieJar object.</para>
            <para>If cookieJar is in the same thread as this QNetworkAccessManager, it will set the parent of the cookieJar so that the cookie jar is deleted when this object is deleted as well. If you want to share cookie jars between different QNetworkAccessManager objects, you may want to set the cookie jar's parent to 0 after calling this function.</para>
            <para>QNetworkAccessManager by default does not implement any cookie policy of its own: it accepts all cookies sent by the server, as long as they are well formed and meet the minimum security requirements (cookie domain matches the request's and cookie path matches the request's). In order to implement your own security policy, override the QNetworkCookieJar::cookiesForUrl() and QNetworkCookieJar::setCookiesFromUrl() virtual functions. Those functions are called by QNetworkAccessManager when it detects a new cookie.</para>
            <para>See also cookieJar(), QNetworkCookieJar::cookiesForUrl(), and QNetworkCookieJar::setCookiesFromUrl().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.Configuration">
            <summary>
            <para>Returns the network configuration that will be used to create the network session which will be used when processing network requests.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setConfiguration() and activeConfiguration().</para>
            <para></para>
            <para>Sets the network configuration that will be used when creating the network session to config.</para>
            <para>The network configuration is used to create and open a network session before any request that requires network access is process. If no network configuration is explicitly set via this function the network configuration returned by QNetworkConfigurationManager::defaultConfiguration() will be used.</para>
            <para>To restore the default network configuration set the network configuration to the value returned from QNetworkConfigurationManager::defaultConfiguration().</para>
            <para>Setting a network configuration means that the QNetworkAccessManager instance will only be using the specified one. In particular, if the default network configuration changes (upon e.g. Wifi being available), this new configuration needs to be enabled manually if desired.</para>
            <para>QNetworkConfigurationManager manager;</para>
            <para>networkAccessManager-&gt;setConfiguration(manager.defaultConfiguration());</para>
            <para>If an invalid network configuration is set, a network session will not be created. In this case network requests will be processed regardless, but may fail. For example:</para>
            <para>networkAccessManager-&gt;setConfiguration(QNetworkConfiguration());</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also configuration() and QNetworkSession.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.NetworkAccessible">
            <summary>
            <para>This property holds whether the network is currently accessible via this network access manager.</para>
            <para>If the network is not accessible the network access manager will not process any new network requests, all such requests will fail with an error. Requests with URLs with the file:// scheme will still be processed.</para>
            <para>By default the value of this property reflects the physical state of the device. Applications may override it to disable all network requests via this network access manager by calling</para>
            <para>networkAccessManager-&gt;setNetworkAccessible(QNetworkAccessManager::NotAccessible);</para>
            <para>Network requests can be reenabled again by calling</para>
            <para>networkAccessManager-&gt;setNetworkAccessible(QNetworkAccessManager::Accessible);</para>
            <para>Note: Calling setNetworkAccessible() does not change the network state.</para>
            <para>This property was introduced in  Qt 4.7.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.SupportedSchemes">
            <summary>
            <para>Lists all the URL schemes supported by the access manager.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also supportedSchemesImplementation().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.ActiveConfiguration">
            <summary>
            <para>Returns the current active network configuration.</para>
            <para>If the network configuration returned by configuration() is of type QNetworkConfiguration::ServiceNetwork this function will return the current active child network configuration of that configuration. Otherwise returns the same network configuration as configuration().</para>
            <para>Use this function to return the actual network configuration currently in use by the network session.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also configuration().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAccessManager.SupportedSchemesImplementation">
            <summary>
            <para>Lists all the URL schemes supported by the access manager.</para>
            <para>You should not call this function directly; use QNetworkAccessManager::supportedSchemes() instead.</para>
            <para>Reimplement this slot to provide your own supported schemes in a QNetworkAccessManager subclass. It is for instance necessary when your subclass provides support for new protocols.</para>
            <para>Because of binary compatibility constraints, the supportedSchemes() method (introduced in Qt 5.2) is not virtual. Instead, supportedSchemes() will dynamically detect and call this slot.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also supportedSchemes().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkAccessManager.Operation">
            <summary>
            <para>Indicates the operation this reply is processing.</para>
            <para>This enum was introduced or modified in  Qt 4.7.</para>
            <para>See also QNetworkReply::operation().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.HeadOperation">
            <summary>retrieve headers operation (created with head())</summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.GetOperation">
            <summary>retrieve headers and download contents (created with get())</summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.PutOperation">
            <summary>upload contents operation (created with put())</summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.PostOperation">
            <summary>send the contents of an HTML form for processing via HTTP POST (created with post())</summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.DeleteOperation">
            <summary>delete contents operation (created with deleteResource())</summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.Operation.CustomOperation">
            <summary>custom operation (created with sendCustomRequest())</summary>
        </member>
        <member name="T:QtNetwork.QNetworkAccessManager.NetworkAccessibility">
            <summary>
            <para>Indicates whether the network is accessible via this network access manager.</para>
            <para>See also networkAccessible.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.NetworkAccessibility.UnknownAccessibility">
            <summary>The network accessibility cannot be determined.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.NetworkAccessibility.NotAccessible">
            <summary>The network is not currently accessible, either because there is currently no network coverage or network access has been explicitly disabled by a call to setNetworkAccessible().</summary>
        </member>
        <member name="F:QtNetwork.QNetworkAccessManager.NetworkAccessibility.Accessible">
            <summary>The network is accessible.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkCookie">
            <summary>
            <para>The QNetworkCookie class holds one network cookie.</para>
            </summary>
            <remarks>
            <para>Cookies are small bits of information that stateless protocols like HTTP use to maintain some persistent information across requests.</para>
            <para>A cookie is set by a remote server when it replies to a request and it expects the same cookie to be sent back when further requests are sent.</para>
            <para>QNetworkCookie holds one such cookie as received from the network. A cookie has a name and a value, but those are opaque to the application (that is, the information stored in them has no meaning to the application). A cookie has an associated path name and domain, which indicate when the cookie should be sent again to the server.</para>
            <para>A cookie can also have an expiration date, indicating its validity. If the expiration date is not present, the cookie is considered a &quot;session cookie&quot; and should be discarded when the application exits (or when its concept of session is over).</para>
            <para>QNetworkCookie provides a way of parsing a cookie from the HTTP header format using the QNetworkCookie::parseCookies() function. However, when received in a QNetworkReply, the cookie is already parsed.</para>
            <para>This class implements cookies as described by the initial cookie specification by Netscape, which is somewhat similar to the RFC 2109 specification, plus the &quot;HttpOnly&quot; extension. The more recent RFC 2965 specification (which uses the Set-Cookie2 header) is not supported.</para>
            <para></para>
            <para>See also QNetworkCookieJar, QNetworkRequest, and QNetworkReply.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.#ctor(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
            <para>Create a new QNetworkCookie object, initializing the cookie name to name and its value to value.</para>
            <para>A cookie is only valid if it has a name. However, the value is opaque to the application and being empty may have significance to the remote server.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.#ctor(QtNetwork.QNetworkCookie)">
            <summary>
            <para>Creates a new QNetworkCookie object by copying the contents of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.Swap(QtNetwork.QNetworkCookie)">
            <summary>
            <para>Swaps this cookie with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.op_Equality(QtNetwork.QNetworkCookie,QtNetwork.QNetworkCookie)">
            <summary>
            <para>Returns true if this cookie is equal to other. This function only returns true if all fields of the cookie are the same.</para>
            <para>However, in some contexts, two cookies of the same name could be considered equal.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also operator!=() and hasSameIdentifier().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.op_Inequality(QtNetwork.QNetworkCookie,QtNetwork.QNetworkCookie)">
            <summary>
            <para>Returns true if this cookie is not equal to other.</para>
            <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.ToRawForm(QtNetwork.QNetworkCookie.RawForm)">
            <summary>
            <para>Returns the raw form of this QNetworkCookie. The QByteArray returned by this function is suitable for an HTTP header, either in a server response (the Set-Cookie header) or the client request (the Cookie header). You can choose from one of two formats, using form.</para>
            <para>See also parseCookies().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.HasSameIdentifier(QtNetwork.QNetworkCookie)">
            <summary>
            <para>Returns true if this cookie has the same identifier tuple as other. The identifier tuple is composed of the name, domain and path.</para>
            <para>See also operator==().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookie.Normalize(QtCore.QUrl)">
            <summary>
            <para>This functions normalizes the path and domain of the cookie if they were previously empty. The url parameter is used to determine the correct domain and path.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Secure">
            <summary>
            <para>Returns true if the &quot;secure&quot; option was specified in the cookie string, false otherwise.</para>
            <para>Secure cookies may contain private information and should not be resent over unencrypted connections.</para>
            <para>See also setSecure().</para>
            <para></para>
            <para>Sets the secure flag of this cookie to enable.</para>
            <para>Secure cookies may contain private information and should not be resent over unencrypted connections.</para>
            <para>See also isSecure().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.HttpOnly">
            <summary>
            <para>Returns true if the &quot;HttpOnly&quot; flag is enabled for this cookie.</para>
            <para>A cookie that is &quot;HttpOnly&quot; is only set and retrieved by the network requests and replies; i.e., the HTTP protocol. It is not accessible from scripts running on browsers.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also isSecure().</para>
            <para></para>
            <para>Sets this cookie's &quot;HttpOnly&quot; flag to enable.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also isHttpOnly().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.ExpirationDate">
            <summary>
            <para>Returns the expiration date for this cookie. If this cookie is a session cookie, the QDateTime returned will not be valid. If the date is in the past, this cookie has already expired and should not be sent again back to a remote server.</para>
            <para>The expiration date corresponds to the parameters of the &quot;expires&quot; entry in the cookie string.</para>
            <para>See also isSessionCookie() and setExpirationDate().</para>
            <para></para>
            <para>Sets the expiration date of this cookie to date. Setting an invalid expiration date to this cookie will mean it's a session cookie.</para>
            <para>See also isSessionCookie() and expirationDate().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Domain">
            <summary>
            <para>Returns the domain this cookie is associated with. This corresponds to the &quot;domain&quot; field of the cookie string.</para>
            <para>Note that the domain here may start with a dot, which is not a valid hostname. However, it means this cookie matches all hostnames ending with that domain name.</para>
            <para>See also setDomain().</para>
            <para></para>
            <para>Sets the domain associated with this cookie to be domain.</para>
            <para>See also domain().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Path">
            <summary>
            <para>Returns the path associated with this cookie. This corresponds to the &quot;path&quot; field of the cookie string.</para>
            <para>See also setPath().</para>
            <para></para>
            <para>Sets the path associated with this cookie to be path.</para>
            <para>See also path().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Name">
            <summary>
            <para>Returns the name of this cookie. The only mandatory field of a cookie is its name, without which it is not considered valid.</para>
            <para>See also setName() and value().</para>
            <para></para>
            <para>Sets the name of this cookie to be cookieName. Note that setting a cookie name to an empty QByteArray will make this cookie invalid.</para>
            <para>See also name() and value().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.Value">
            <summary>
            <para>Returns this cookies value, as specified in the cookie string. Note that a cookie is still valid if its value is empty.</para>
            <para>Cookie name-value pairs are considered opaque to the application: that is, their values don't mean anything.</para>
            <para>See also setValue() and name().</para>
            <para></para>
            <para>Sets the value of this cookie to be value.</para>
            <para>See also value() and name().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkCookie.IsSessionCookie">
            <summary>
            <para>Returns true if this cookie is a session cookie. A session cookie is a cookie which has no expiration date, which means it should be discarded when the application's concept of session is over (usually, when the application exits).</para>
            <para>See also expirationDate() and setExpirationDate().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkCookie.RawForm">
            <summary>
            <para>This enum is used with the toRawForm() function to declare which form of a cookie shall be returned.</para>
            <para>Note that only the Full form of the cookie can be parsed back into its original contents.</para>
            <para>See also toRawForm() and parseCookies().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkCookie.RawForm.NameAndValueOnly">
            <summary>makes toRawForm() return only the "NAME=VALUE" part of the cookie, as suitable for sending back to a server in a client request's "Cookie:" header. Multiple cookies are separated by a semi-colon in the "Cookie:" header field.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkCookie.RawForm.Full">
            <summary>makes toRawForm() return the full cookie contents, as suitable for sending to a client in a server's "Set-Cookie:" header.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkCookieJar">
            <summary>
            <para>The QNetworkCookieJar class implements a simple jar of QNetworkCookie objects</para>
            </summary>
            <remarks>
            <para>Cookies are small bits of information that stateless protocols like HTTP use to maintain some persistent information across requests.</para>
            <para>A cookie is set by a remote server when it replies to a request and it expects the same cookie to be sent back when further requests are sent.</para>
            <para>The cookie jar is the object that holds all cookies set in previous requests. Web browsers save their cookie jars to disk in order to conserve permanent cookies across invocations of the application.</para>
            <para>QNetworkCookieJar does not implement permanent storage: it only keeps the cookies in memory. Once the QNetworkCookieJar object is deleted, all cookies it held will be discarded as well. If you want to save the cookies, you should derive from this class and implement the saving to disk to your own storage format.</para>
            <para>This class implements only the basic security recommended by the cookie specifications and does not implement any cookie acceptance policy (it accepts all cookies set by any requests). In order to override those rules, you should reimplement the cookiesForUrl() and setCookiesFromUrl() virtual functions. They are called by QNetworkReply and QNetworkAccessManager when they detect new cookies and when they require cookies.</para>
            <para></para>
            <para>See also QNetworkCookie, QNetworkAccessManager, QNetworkReply, QNetworkRequest, and QNetworkAccessManager::setCookieJar().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.#ctor(QtCore.QObject)">
            <summary>
            <para>Creates a QNetworkCookieJar object and sets the parent object to be parent.</para>
            <para>The cookie jar is initialized to empty.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.InsertCookie(QtNetwork.QNetworkCookie)">
            <summary>
            <para>Adds cookie to this cookie jar.</para>
            <para>Returns true if cookie was added, false otherwise.</para>
            <para>If a cookie with the same identifier already exists in the cookie jar, it will be overridden.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.UpdateCookie(QtNetwork.QNetworkCookie)">
            <summary>
            <para>If a cookie with the same identifier as cookie exists in this cookie jar it will be updated. This function uses insertCookie().</para>
            <para>Returns true if cookie was updated, false if no cookie in the jar matches the identifier of cookie.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also QNetworkCookie::hasSameIdentifier().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.DeleteCookie(QtNetwork.QNetworkCookie)">
            <summary>
            <para>Deletes from cookie jar the cookie found to have the same identifier as cookie.</para>
            <para>Returns true if a cookie was deleted, false otherwise.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also QNetworkCookie::hasSameIdentifier().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkCookieJar.ValidateCookie(QtNetwork.QNetworkCookie,QtCore.QUrl)">
            <summary>
            <para>Returns true if the domain and path of cookie are valid, false otherwise. The url parameter is used to determine if the domain specified in the cookie is allowed.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkDiskCache">
            <summary>
            <para>The QNetworkDiskCache class provides a very basic disk cache.</para>
            </summary>
            <remarks>
            <para>QNetworkDiskCache stores each url in its own file inside of the cacheDirectory using QDataStream. Files with a text MimeType are compressed using qCompress. Each cache file starts with &quot;cache_&quot; and ends in &quot;.cache&quot;. Data is written to disk only in insert() and updateMetaData().</para>
            <para>Currently you cannot share the same cache files with more than one disk cache.</para>
            <para>QNetworkDiskCache by default limits the amount of space that the cache will use on the system to 50MB.</para>
            <para>Note you have to set the cache directory before it will work.</para>
            <para>A network disk cache can be enabled by:</para>
            <para>QNetworkAccessManager *manager = new QNetworkAccessManager(this);</para>
            <para>QNetworkDiskCache *diskCache = new QNetworkDiskCache(this);</para>
            <para>diskCache-&gt;setCacheDirectory(&quot;cacheDir&quot;);</para>
            <para>manager-&gt;setCache(diskCache);</para>
            <para>When sending requests, to control the preference of when to use the cache and when to use the network, consider the following:</para>
            <para>// do a normal request (preferred from network, as this is the default)</para>
            <para>QNetworkRequest request(QUrl(QString(&quot;http://qt-project.org&quot;)));</para>
            <para>manager-&gt;get(request);</para>
            <para></para>
            <para>// do a request preferred from cache</para>
            <para>QNetworkRequest request2(QUrl(QString(&quot;http://qt-project.org&quot;)));</para>
            <para>request2.setAttribute(QNetworkRequest::CacheLoadControlAttribute, QNetworkRequest::PreferCache);</para>
            <para>manager-&gt;get(request2);</para>
            <para>To check whether the response came from the cache or from the network, the following can be applied:</para>
            <para>void replyFinished(QNetworkReply *reply) {</para>
            <para>    QVariant fromCache = reply-&gt;attribute(QNetworkRequest::SourceIsFromCacheAttribute);</para>
            <para>    qDebug() &lt;&lt; &quot;page from cache?&quot; &lt;&lt; fromCache.toBool();</para>
            <para>}</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.#ctor(QtCore.QObject)">
            <summary>
            <para>Creates a new disk cache. The parent argument is passed to QAbstractNetworkCache's constructor.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.MetaData(QtCore.QUrl)">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::metaData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.UpdateMetaData(QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::updateMetaData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Data(QtCore.QUrl)">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::data().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Remove(QtCore.QUrl)">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::remove().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Prepare(QtNetwork.QNetworkCacheMetaData)">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::prepare().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Insert(QtCore.QIODevice)">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::insert().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.FileMetaData(System.String)">
            <summary>
            <para>Returns the QNetworkCacheMetaData for the cache file fileName.</para>
            <para>If fileName is not a cache file QNetworkCacheMetaData will be invalid.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Clear">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::clear().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkDiskCache.Expire">
            <summary>
            <para>Cleans the cache so that its size is under the maximum cache size. Returns the current size of the cache.</para>
            <para>When the current size of the cache is greater than the maximumCacheSize() older cache files are removed until the total size is less then 90% of maximumCacheSize() starting with the oldest ones first using the file creation date to determine how old a cache file is.</para>
            <para>Subclasses can reimplement this function to change the order that cache files are removed taking into account information in the application knows about that QNetworkDiskCache does not, for example the number of times a cache is accessed.</para>
            <para>Note: cacheSize() calls expire if the current cache size is unknown.</para>
            <para>See also maximumCacheSize() and fileMetaData().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkDiskCache.CacheDirectory">
            <summary>
            <para>Returns the location where cached files will be stored.</para>
            <para>See also setCacheDirectory().</para>
            <para></para>
            <para>Sets the directory where cached files will be stored to cacheDir</para>
            <para>QNetworkDiskCache will create this directory if it does not exists.</para>
            <para>Prepared cache items will be stored in the new cache directory when they are inserted.</para>
            <para>See also cacheDirectory() and QDesktopServices::CacheLocation.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkDiskCache.MaximumCacheSize">
            <summary>
            <para>Returns the current maximum size for the disk cache.</para>
            <para>See also setMaximumCacheSize().</para>
            <para></para>
            <para>Sets the maximum size of the disk cache to be size.</para>
            <para>If the new size is smaller then the current cache size then the cache will call expire().</para>
            <para>See also maximumCacheSize().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkDiskCache.CacheSize">
            <summary>
            <para>Reimplemented from QAbstractNetworkCache::cacheSize().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkReply">
            <summary>
            <para>The QNetworkReply class contains the data and headers for a request sent with QNetworkAccessManager</para>
            </summary>
            <remarks>
            <para>The QNetworkReply class contains the data and meta data related to a request posted with QNetworkAccessManager. Like QNetworkRequest, it contains a URL and headers (both in parsed and raw form), some information about the reply's state and the contents of the reply itself.</para>
            <para>QNetworkReply is a sequential-access QIODevice, which means that once data is read from the object, it no longer kept by the device. It is therefore the application's responsibility to keep this data if it needs to. Whenever more data is received from the network and processed, the readyRead() signal is emitted.</para>
            <para>The downloadProgress() signal is also emitted when data is received, but the number of bytes contained in it may not represent the actual bytes received, if any transformation is done to the contents (for example, decompressing and removing the protocol overhead).</para>
            <para>Even though QNetworkReply is a QIODevice connected to the contents of the reply, it also emits the uploadProgress() signal, which indicates the progress of the upload for operations that have such content.</para>
            <para>Note: Do not delete the object in the slot connected to the error() or finished() signal. Use deleteLater().</para>
            <para></para>
            <para>See also QNetworkRequest and QNetworkAccessManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkReply.#ctor(QtCore.QObject)">
            <summary>
            <para>Creates a QNetworkReply object with parent parent.</para>
            <para>You cannot directly instantiate QNetworkReply objects. Use QNetworkAccessManager functions to do that.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Close">
            <summary>
            <para>Reimplemented from QIODevice::close().</para>
            <para>Closes this device for reading. Unread data is discarded, but the network resources are not discarded until they are finished. In particular, if any upload is in progress, it will continue until it is done.</para>
            <para>The finished() signal is emitted when all operations are over and the network resources are freed.</para>
            <para>See also abort() and finished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Header(QtNetwork.QNetworkRequest.KnownHeaders)">
            <summary>
            <para>Returns the value of the known header header, if that header was sent by the remote server. If the header was not sent, returns an invalid QVariant.</para>
            <para>See also rawHeader(), setHeader(), and QNetworkRequest::header().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.HasRawHeader(QtCore.QByteArray)">
            <summary>
            <para>Returns true if the raw header of name headerName was sent by the remote server</para>
            <para>See also rawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.RawHeader(QtCore.QByteArray)">
            <summary>
            <para>Returns the raw contents of the header headerName as sent by the remote server. If there is no such header, returns an empty byte array, which may be indistinguishable from an empty header. Use hasRawHeader() to verify if the server sent such header field.</para>
            <para>See also setRawHeader(), hasRawHeader(), and header().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Attribute(QtNetwork.QNetworkRequest.Attribute)">
            <summary>
            <para>Returns the attribute associated with the code code. If the attribute has not been set, it returns an invalid QVariant (type QMetaType::UnknownType).</para>
            <para>You can expect the default values listed in QNetworkRequest::Attribute to be applied to the values returned by this function.</para>
            <para>See also setAttribute() and QNetworkRequest::Attribute.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.Abort">
            <summary>
            <para>Aborts the operation immediately and close down any network connections still open. Uploads still in progress are also aborted.</para>
            <para>The finished() signal will also be emitted.</para>
            <para>See also close() and finished().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.IgnoreSslErrors">
            <summary>
            <para>If this function is called, SSL errors related to network connection will be ignored, including certificate validation errors.</para>
            <para>Warning: Be sure to always let the user inspect the errors reported by the sslErrors() signal, and only call this method upon confirmation from the user that proceeding is ok. If there are unexpected errors, the reply should be aborted. Calling this method without inspecting the actual errors will most likely pose a security risk for your application. Use it with great care!</para>
            <para>This function can be called from the slot connected to the sslErrors() signal, which indicates which errors were found.</para>
            <para>See also sslConfiguration(), sslErrors(), and QSslSocket::ignoreSslErrors().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetError(QtNetwork.QNetworkReply.NetworkError,System.String)">
            <summary>
            <para>Sets the error condition to be errorCode. The human-readable message is set with errorString.</para>
            <para>Calling setError() does not emit the error(QNetworkReply::NetworkError) signal.</para>
            <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetHeader(QtNetwork.QNetworkRequest.KnownHeaders,QtCore.QVariant)">
            <summary>
            <para>Sets the known header header to be of value value. The corresponding raw form of the header will be set as well.</para>
            <para>See also header(), setRawHeader(), and QNetworkRequest::setHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetRawHeader(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
            <para>Sets the raw header headerName to be of value value. If headerName was previously set, it is overridden. Multiple HTTP headers of the same name are functionally equivalent to one single header with the values concatenated, separated by commas.</para>
            <para>If headerName matches a known header, the value value will be parsed and the corresponding parsed form will also be set.</para>
            <para>See also rawHeader(), header(), setHeader(), and QNetworkRequest::setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetAttribute(QtNetwork.QNetworkRequest.Attribute,QtCore.QVariant)">
            <summary>
            <para>Sets the attribute code to have value value. If code was previously set, it will be overridden. If value is an invalid QVariant, the attribute will be unset.</para>
            <para>See also attribute() and QNetworkRequest::setAttribute().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SslConfigurationImplementation(QtNetwork.QSslConfiguration)">
            <summary>
            <para>This virtual method is provided to enable overriding the behavior of sslConfiguration(). sslConfiguration() is a public wrapper for this method. The configuration will be returned in configuration.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also setSslConfigurationImplementation() and sslConfiguration().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkReply.SetSslConfigurationImplementation(QtNetwork.QSslConfiguration)">
            <summary>
            <para>This virtual method is provided to enable overriding the behavior of setSslConfiguration(). setSslConfiguration() is a public wrapper for this method. If you override this method use configuration to set the SSL configuration.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also sslConfigurationImplementation() and setSslConfiguration().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.MetaDataChanged">
            <summary>
            <para>This signal is emitted whenever the metadata in this reply changes. metadata is any information that is not the content (data) itself, including the network headers. In the majority of cases, the metadata will be known fully by the time the first byte of data is received. However, it is possible to receive updates of headers or other metadata during the processing of the data.</para>
            <para>See also header(), rawHeaderList(), rawHeader(), and hasRawHeader().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.OnFinished">
            <summary>
            <para>This signal is emitted when the reply has finished processing. After this signal is emitted, there will be no more updates to the reply's data or metadata.</para>
            <para>Unless close() or abort() have been called, the reply will be still be opened for reading, so the data can be retrieved by calls to read() or readAll(). In particular, if no calls to read() were made as a result of readyRead(), a call to readAll() will retrieve the full contents in a QByteArray.</para>
            <para>This signal is emitted in tandem with QNetworkAccessManager::finished() where that signal's reply parameter is this object.</para>
            <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
            <para>You can also use isFinished() to check if a QNetworkReply has finished even before you receive the finished() signal.</para>
            <para>See also setFinished(), QNetworkAccessManager::finished(), and isFinished().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.OnError">
            <summary>
            <para>This signal is emitted when the reply detects an error in processing. The finished() signal will probably follow, indicating that the connection is over.</para>
            <para>The code parameter contains the code of the error that was detected. Call errorString() to obtain a textual representation of the error condition.</para>
            <para>Note: Do not delete the object in the slot connected to this signal. Use deleteLater().</para>
            <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.Encrypted">
            <summary>
            <para>This signal is emitted when an SSL/TLS session has successfully completed the initial handshake. At this point, no user data has been transmitted. The signal can be used to perform additional checks on the certificate chain, for example to notify users when the certificate for a website has changed. If the reply does not match the expected criteria then it should be aborted by calling QNetworkReply::abort() by a slot connected to this signal. The SSL configuration in use can be inspected using the QNetworkReply::sslConfiguration() method.</para>
            <para>Internally, QNetworkAccessManager may open multiple connections to a server, in order to allow it process requests in parallel. These connections may be reused, which means that the encrypted() signal would not be emitted. This means that you are only guaranteed to receive this signal for the first connection to a site in the lifespan of the QNetworkAccessManager.</para>
            <para>This function was introduced in  Qt 5.1.</para>
            <para>See also QSslSocket::encrypted() and QNetworkAccessManager::encrypted().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.PreSharedKeyAuthenticationRequired">
            <summary>
            <para>This signal is emitted if the SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.</para>
            <para>When using PSK, the client must send to the server a valid identity and a valid pre shared key, in order for the SSL handshake to continue. Applications can provide this information in a slot connected to this signal, by filling in the passed authenticator object according to their needs.</para>
            <para>Note: Ignoring this signal, or failing to provide the required credentials, will cause the handshake to fail, and therefore the connection to be aborted.</para>
            <para>Note: The authenticator object is owned by the reply and must not be deleted by the application.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            <para>See also QSslPreSharedKeyAuthenticator.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.UploadProgress">
            <summary>
            <para>This signal is emitted to indicate the progress of the upload part of this network request, if there's any. If there's no upload associated with this request, this signal will not be emitted.</para>
            <para>The bytesSent parameter indicates the number of bytes uploaded, while bytesTotal indicates the total number of bytes to be uploaded. If the number of bytes to be uploaded could not be determined, bytesTotal will be -1.</para>
            <para>The upload is finished when bytesSent is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
            <para>See also downloadProgress().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkReply.DownloadProgress">
            <summary>
            <para>This signal is emitted to indicate the progress of the download part of this network request, if there's any. If there's no download associated with this request, this signal will be emitted once with 0 as the value of both bytesReceived and bytesTotal.</para>
            <para>The bytesReceived parameter indicates the number of bytes received, while bytesTotal indicates the total number of bytes expected to be downloaded. If the number of bytes to be downloaded is not known, bytesTotal will be -1.</para>
            <para>The download is finished when bytesReceived is equal to bytesTotal. At that time, bytesTotal will not be -1.</para>
            <para>Note that the values of both bytesReceived and bytesTotal may be different from size(), the total number of bytes obtained through read() or readAll(), or the value of the header(ContentLengthHeader). The reason for that is that there may be protocol overhead or the data may be compressed during the download.</para>
            <para>See also uploadProgress() and bytesAvailable().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.ReadBufferSize">
            <summary>
            <para>Returns the size of the read buffer, in bytes.</para>
            <para>See also setReadBufferSize().</para>
            <para></para>
            <para>Sets the size of the read buffer to be size bytes. The read buffer is the buffer that holds data that is being downloaded off the network, before it is read with QIODevice::read(). Setting the buffer size to 0 will make the buffer unlimited in size.</para>
            <para>QNetworkReply will try to stop reading from the network once this buffer is full (i.e., bytesAvailable() returns size or more), thus causing the download to throttle down as well. If the buffer is not limited in size, QNetworkReply will try to download as fast as possible from the network.</para>
            <para>Unlike QAbstractSocket::setReadBufferSize(), QNetworkReply cannot guarantee precision in the read buffer size. That is, bytesAvailable() can return more than size.</para>
            <para>See also readBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.SslConfiguration">
            <summary>
            <para>Returns the SSL configuration and state associated with this reply, if SSL was used. It will contain the remote server's certificate, its certificate chain leading to the Certificate Authority as well as the encryption ciphers in use.</para>
            <para>The peer's certificate and its certificate chain will be known by the time sslErrors() is emitted, if it's emitted.</para>
            <para>See also setSslConfiguration().</para>
            <para></para>
            <para>Sets the SSL configuration for the network connection associated with this request, if possible, to be that of config.</para>
            <para>See also sslConfiguration().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Operation">
            <summary>
            <para>Returns the operation that was posted for this reply.</para>
            <para>See also setOperation().</para>
            <para></para>
            <para>Sets the associated operation for this object to be operation. This value will be returned by operation().</para>
            <para>Note: The operation should be set when this object is created and not changed again.</para>
            <para>See also operation() and setRequest().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Request">
            <summary>
            <para>Returns the request that was posted for this reply. In special, note that the URL for the request may be different than that of the reply.</para>
            <para>See also QNetworkRequest::url(), url(), and setRequest().</para>
            <para></para>
            <para>Sets the associated request for this object to be request. This value will be returned by request().</para>
            <para>Note: The request should be set when this object is created and not changed again.</para>
            <para>See also request() and setOperation().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Finished">
            <summary>
            <para>Returns true when the reply has finished or was aborted.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also isRunning().</para>
            <para></para>
            <para>Sets the reply as finished.</para>
            <para>After having this set the replies data must not change.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also finished() and isFinished().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Url">
            <summary>
            <para>Returns the URL of the content downloaded or uploaded. Note that the URL may be different from that of the original request.</para>
            <para>See also request(), setUrl(), and QNetworkRequest::url().</para>
            <para></para>
            <para>Sets the URL being processed to be url. Normally, the URL matches that of the request that was posted, but for a variety of reasons it can be different (for example, a file path being made absolute or canonical).</para>
            <para>See also url(), request(), and QNetworkRequest::url().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Error">
            <summary>
            <para>Returns the error that was found during the processing of this request. If no error was found, returns NoError.</para>
            <para>See also setError().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.Manager">
            <summary>
            <para>Returns the QNetworkAccessManager that was used to create this QNetworkReply object. Initially, it is also the parent object.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkReply.IsRunning">
            <summary>
            <para>Returns true when the request is still processing and the reply has not finished or was aborted yet.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also isFinished().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkReply.NetworkError">
            <summary>
            <para>Indicates all possible error conditions found during the processing of the request.</para>
            <para>Note: When the HTTP protocol returns a redirect no error will be reported. You can check if there is a redirect with the QNetworkRequest::RedirectionTargetAttribute attribute.</para>
            <para>See also error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.NoError">
            <summary>no error condition.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ConnectionRefusedError">
            <summary>the remote server refused the connection (the server is not accepting requests)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.RemoteHostClosedError">
            <summary>the remote server closed the connection prematurely, before the entire reply was received and processed</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.HostNotFoundError">
            <summary>the remote host name was not found (invalid hostname)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.TimeoutError">
            <summary>the connection to the remote server timed out</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.OperationCanceledError">
            <summary>the operation was canceled via calls to abort() or close() before it was finished.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.SslHandshakeFailedError">
            <summary>the SSL/TLS handshake failed and the encrypted channel could not be established. The sslErrors() signal should have been emitted.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.TemporaryNetworkFailureError">
            <summary>the connection was broken due to disconnection from the network, however the system has initiated roaming to another access point. The request should be resubmitted and will be processed as soon as the connection is re-established.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.NetworkSessionFailedError">
            <summary>the connection was broken due to disconnection from the network or failure to start the network.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.BackgroundRequestNotAllowedError">
            <summary>the background request is not currently allowed due to platform policy.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.UnknownNetworkError">
            <summary>an unknown network-related error was detected</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyConnectionRefusedError">
            <summary>the connection to the proxy server was refused (the proxy server is not accepting requests)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyConnectionClosedError">
            <summary>the proxy server closed the connection prematurely, before the entire reply was received and processed</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyNotFoundError">
            <summary>the proxy host name was not found (invalid proxy hostname)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyTimeoutError">
            <summary>the connection to the proxy timed out or the proxy did not reply in time to the request sent</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProxyAuthenticationRequiredError">
            <summary>the proxy requires authentication in order to honour the request but did not accept any credentials offered (if any)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.UnknownProxyError">
            <summary>an unknown proxy-related error was detected</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentAccessDenied">
            <summary>the access to the remote content was denied (similar to HTTP error 401)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentOperationNotPermittedError">
            <summary>the operation requested on the remote content is not permitted</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentNotFoundError">
            <summary>the remote content was not found at the server (similar to HTTP error 404)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.AuthenticationRequiredError">
            <summary>the remote server requires authentication to serve the content but the credentials provided were not accepted (if any)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentReSendError">
            <summary>the request needed to be sent again, but this failed for example because the upload data could not be read a second time.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentConflictError">
            <summary>the request could not be completed due to a conflict with the current state of the resource.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ContentGoneError">
            <summary>the requested resource is no longer available at the server.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.UnknownContentError">
            <summary>an unknown error related to the remote content was detected</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProtocolUnknownError">
            <summary>the Network Access API cannot honor the request because the protocol is not known</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProtocolInvalidOperationError">
            <summary>the requested operation is invalid for this protocol</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ProtocolFailure">
            <summary>a breakdown in protocol was detected (parsing error, invalid or unexpected responses, etc.)</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.InternalServerError">
            <summary>the server encountered an unexpected condition which prevented it from fulfilling the request.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.OperationNotImplementedError">
            <summary>the server does not support the functionality required to fulfill the request.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.ServiceUnavailableError">
            <summary>the server is unable to handle the request at this time.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkReply.NetworkError.UnknownServerError">
            <summary>an unknown error related to the server response was detected</summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration">
            <summary>
            <para>The QNetworkConfiguration class provides an abstraction of one or more access point configurations.</para>
            </summary>
            <remarks>
            <para>QNetworkConfiguration encapsulates a single access point or service network. In most cases a single access point configuration can be mapped to one network interface. However a single network interface may not always map to only one access point configuration. Multiple configurations for the same network device may enable multiple access points. An example device that could exhibit such a configuration might be a Smartphone which allows the user to manage multiple WLAN configurations while the device itself has only one WLAN network device.</para>
            <para>The QNetworkConfiguration also supports the concept of service networks. This concept allows the grouping of multiple access point configurations into one entity. Such a group is called service network and can be beneficial in cases whereby a network session to a particular destination network is required (e.g. a company network). When using a service network the user doesn't usually care which one of the connectivity options is chosen (e.g. corporate WLAN or VPN via GPRS) as long as he can reach the company's target server. Depending on the current position and time some of the access points that make up the service network may not even be available. Furthermore automated access point roaming can be enabled which enables the device to change the network interface configuration dynamically while maintaining the applications connection to the target network. It allows adaption to the changing environment and may enable optimization with regards to cost, speed or other network parameters.</para>
            <para>Special configurations of type UserChoice provide a placeholder configuration which is resolved to an actual network configuration by the platform when a session is opened. Not all platforms support the concept of a user choice configuration.</para>
            <para></para>
            <para>Configuration States</para>
            <para>The list of available configurations can be obtained via QNetworkConfigurationManager::allConfigurations(). A configuration can have multiple states. The Defined configuration state indicates that the configuration is stored on the device. However the configuration is not yet ready to be activated as e.g. a WLAN may not be available at the current time.</para>
            <para>The Discovered state implies that the configuration is Defined and the outside conditions are such that the configuration can be used immediately to open a new network session. An example of such an outside condition may be that the Ethernet cable is actually connected to the device or that the WLAN with the specified SSID is in range.</para>
            <para>The Active state implies that the configuration is Discovered. A configuration in this state is currently being used by an application. The underlying network interface has a valid IP configuration and can transfer IP packets between the device and the target network.</para>
            <para>The Undefined state indicates that the system has knowledge of possible target networks but cannot actually use that knowledge to connect to it. An example for such a state could be an encrypted WLAN that has been discovered but the user hasn't actually saved a configuration including the required password which would allow the device to connect to it.</para>
            <para>Depending on the type of configuration some states are transient in nature. A GPRS/UMTS connection may almost always be Discovered if the GSM/UMTS network is available. However if the GSM/UMTS network looses the connection the associated configuration may change its state from Discovered to Defined as well. A similar use case might be triggered by WLAN availability. QNetworkConfigurationManager::updateConfigurations() can be used to manually trigger updates of states. Note that some platforms do not require such updates as they implicitly change the state once it has been discovered. If the state of a configuration changes all related QNetworkConfiguration instances change their state automatically.</para>
            <para></para>
            <para>See also QNetworkSession and QNetworkConfigurationManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.#ctor">
            <summary>
            <para>Constructs an invalid configuration object.</para>
            <para>See also isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.#ctor(QtNetwork.QNetworkConfiguration)">
            <summary>
            <para>Creates a copy of the QNetworkConfiguration object contained in other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.Swap(QtNetwork.QNetworkConfiguration)">
            <summary>
            <para>Swaps this network configuration with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.op_Equality(QtNetwork.QNetworkConfiguration,QtNetwork.QNetworkConfiguration)">
            <summary>
            <para>Returns true, if this configuration is the same as the other configuration given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfiguration.op_Inequality(QtNetwork.QNetworkConfiguration,QtNetwork.QNetworkConfiguration)">
            <summary>
            <para>Returns true if this configuration is not the same as the other configuration given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.State">
            <summary>
            <para>Returns the current state of the configuration.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.type">
            <summary>
            <para>Returns the type of the configuration.</para>
            <para>A configuration can represent a single access point configuration or a set of access point configurations. Such a set is called service network. A configuration that is based on a service network can potentially support roaming of network sessions.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.purpose">
            <summary>
            <para>Returns the purpose of this configuration.</para>
            <para>The purpose field may be used to programmatically determine the purpose of a configuration. Such information is usually part of the access point or service network meta data.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.bearerType">
            <summary>
            <para>Returns the type of bearer used by this network configuration.</para>
            <para>If the bearer type is unknown the bearerTypeName() function can be used to retrieve a textural type name for the bearer.</para>
            <para>An invalid network configuration always returns the BearerUnknown value.</para>
            <para>See also bearerTypeName() and bearerTypeFamily().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.BearerTypeFamily">
            <summary>
            <para>Returns the bearer type family used by this network configuration. The following table lists how bearerType() values map to bearerTypeFamily() values:</para>
            <para></para>
            <para> bearer typebearer type family</para>
            <para>BearerUnknown, Bearer2G, BearerEthernet, BearerWLAN, BearerBluetooth	(same type)</para>
            <para>BearerCDMA2000, BearerEVDO, BearerWCDMA, BearerHSPA, Bearer3G	Bearer3G</para>
            <para>BearerWiMAX, BearerLTE, Bearer4G	Bearer4G</para>
            <para></para>
            <para>An invalid network configuration always returns the BearerUnknown value.</para>
            <para>This function was introduced in  Qt 5.2.</para>
            <para>See also bearerType() and bearerTypeName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.BearerTypeName">
            <summary>
            <para>Returns the type of bearer used by this network configuration as a string.</para>
            <para>The string is not translated and therefore can not be shown to the user. The subsequent table shows the fixed mappings between BearerType and the bearer type name for known types. If the BearerType is unknown this function may return additional information if it is available; otherwise an empty string will be returned.</para>
            <para></para>
            <para> BearerTypeValue</para>
            <para>BearerUnknown	The session is based on an unknown or unspecified bearer type. The value of the string returned describes the bearer type.</para>
            <para>BearerEthernet	Ethernet</para>
            <para>BearerWLAN	WLAN</para>
            <para>Bearer2G	2G</para>
            <para>Bearer3G	3G</para>
            <para>Bearer4G	4G</para>
            <para>BearerCDMA2000	CDMA2000</para>
            <para>BearerWCDMA	WCDMA</para>
            <para>BearerHSPA	HSPA</para>
            <para>BearerBluetooth	Bluetooth</para>
            <para>BearerWiMAX	WiMAX</para>
            <para>BearerEVDO	EVDO</para>
            <para>BearerLTE	LTE</para>
            <para></para>
            <para>This function returns an empty string if this is an invalid configuration, a network configuration of type QNetworkConfiguration::ServiceNetwork or QNetworkConfiguration::UserChoice.</para>
            <para>See also bearerType() and bearerTypeFamily().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.Identifier">
            <summary>
            <para>Returns the unique and platform specific identifier for this network configuration; otherwise an empty string.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.IsRoamingAvailable">
            <summary>
            <para>Returns true if this configuration supports roaming; otherwise false.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.Name">
            <summary>
            <para>Returns the user visible name of this configuration.</para>
            <para>The name may either be the name of the underlying access point or the name for service network that this configuration represents.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfiguration.IsValid">
            <summary>
            <para>Returns true if this QNetworkConfiguration object is valid. A configuration may become invalid if the user deletes the configuration or the configuration was default-constructed.</para>
            <para>The addition and removal of configurations can be monitored via the QNetworkConfigurationManager.</para>
            <para>See also QNetworkConfigurationManager.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.Type">
            <summary>
            <para>This enum describes the type of configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.InternetAccessPoint">
            <summary>The configuration specifies the details for a single access point. Note that configurations of type InternetAccessPoint may be part of other QNetworkConfigurations of type ServiceNetwork.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.ServiceNetwork">
            <summary>The configuration is based on a group of QNetworkConfigurations of type InternetAccessPoint. All group members can reach the same target network. This type of configuration is a mandatory requirement for roaming enabled network sessions. On some platforms this form of configuration may also be called Service Network Access Point (SNAP).</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.UserChoice">
            <summary>The configuration is a placeholder which will be resolved to an actual configuration by the platform when a session is opened. Depending on the platform the selection may generate a popup dialog asking the user for his preferred choice.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Type.Invalid">
            <summary>The configuration is invalid.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.Purpose">
            <summary>
            <para>Specifies the purpose of the configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.UnknownPurpose">
            <summary>The configuration doesn't specify any purpose. This is the default value.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.PublicPurpose">
            <summary>The configuration can be used for general purpose internet access.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.PrivatePurpose">
            <summary>The configuration is suitable to access a private network such as an office Intranet.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.Purpose.ServiceSpecificPurpose">
            <summary>The configuration can be used for operator specific services (e.g. receiving MMS messages or content streaming).</summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.StateFlag">
            <summary>
            <para>Specifies the configuration states.</para>
            <para>The StateFlags type is a typedef for QFlags&lt;StateFlag&gt;. It stores an OR combination of StateFlag values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Undefined">
            <summary>This state is used for transient configurations such as newly discovered WLANs for which the user has not actually created a configuration yet.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Defined">
            <summary>Defined configurations are known to the system but are not immediately usable (e.g. a configured WLAN is not within range or the Ethernet cable is currently not plugged into the machine).</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Discovered">
            <summary>A discovered configuration can be immediately used to create a new QNetworkSession. An example of a discovered configuration could be a WLAN which is within in range. If the device moves out of range the discovered flag is dropped. A second example is a GPRS configuration which generally remains discovered for as long as the device has network coverage. A configuration that has this state is also in state QNetworkConfiguration::Defined. If the configuration is a service network this flag is set if at least one of the underlying access points configurations has the Discovered state.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.StateFlag.Active">
            <summary>The configuration is currently used by an open network session (see QNetworkSession::isOpen()). However this does not mean that the current process is the entity that created the open session. It merely indicates that if a new QNetworkSession were to be constructed based on this configuration QNetworkSession::state() would return QNetworkSession::Connected. This state implies the QNetworkConfiguration::Discovered state.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfiguration.BearerType">
            <summary>
            <para>Specifies the type of bearer used by a configuration.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerUnknown">
            <summary>The type of bearer is unknown or unspecified. The bearerTypeName() function may return additional information.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerEthernet">
            <summary>The configuration is for an Ethernet interfaces.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerWLAN">
            <summary>The configuration is for a Wireless LAN interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.Bearer2G">
            <summary>The configuration is for a CSD, GPRS, HSCSD, EDGE or cdmaOne interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerCDMA2000">
            <summary>The configuration is for CDMA interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerWCDMA">
            <summary>The configuration is for W-CDMA/UMTS interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerHSPA">
            <summary>The configuration is for High Speed Packet Access (HSPA) interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerBluetooth">
            <summary>The configuration is for a Bluetooth interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerWiMAX">
            <summary>The configuration is for a WiMAX interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerEVDO">
            <summary>The configuration is for an EVDO (3G) interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.BearerLTE">
            <summary>The configuration is for a LTE (4G) interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.Bearer3G">
            <summary>The configuration is for a 3G interface.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfiguration.BearerType.Bearer4G">
            <summary>The configuration is for a 4G interface.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfigurationManager">
            <summary>
            <para>The QNetworkConfigurationManager class manages the network configurations provided by the system.</para>
            </summary>
            <remarks>
            <para>QNetworkConfigurationManager provides access to the network configurations known to the system and enables applications to detect the system capabilities (with regards to network sessions) at runtime.</para>
            <para>A QNetworkConfiguration abstracts a set of configuration options describing how a network interface has to be configured to connect to a particular target network. QNetworkConfigurationManager maintains and updates the global list of QNetworkConfigurations. Applications can access and filter this list via allConfigurations(). If a new configuration is added or an existing one is removed or changed the configurationAdded(), configurationRemoved() and configurationChanged() signals are emitted respectively.</para>
            <para>The defaultConfiguration() can be used when intending to immediately create a new network session without caring about the particular configuration. It returns a QNetworkConfiguration::Discovered configuration. If there are not any discovered ones an invalid configuration is returned.</para>
            <para>Some configuration updates may require some time to perform updates. A WLAN scan is such an example. Unless the platform performs internal updates it may be required to manually trigger configuration updates via QNetworkConfigurationManager::updateConfigurations(). The completion of the update process is indicated by emitting the updateCompleted() signal. The update process ensures that every existing QNetworkConfiguration instance is updated. There is no need to ask for a renewed configuration list via allConfigurations().</para>
            <para></para>
            <para>See also QNetworkConfiguration.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QNetworkConfigurationManager with the given parent.</para>
            <para>Note that to ensure a valid list of current configurations immediately available, updating is done during construction which causes some delay.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.ConfigurationFromIdentifier(System.String)">
            <summary>
            <para>Returns the QNetworkConfiguration for identifier; otherwise returns an invalid QNetworkConfiguration.</para>
            <para>See also QNetworkConfiguration::identifier().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkConfigurationManager.UpdateConfigurations">
            <summary>
            <para>Initiates an update of all configurations. This may be used to initiate WLAN scans or other time consuming updates which may be required to obtain the correct state for configurations.</para>
            <para>This call is asynchronous. On completion of this update the updateCompleted() signal is emitted. If new configurations are discovered or old ones were removed or changed the update process may trigger the emission of one or multiple configurationAdded(), configurationRemoved() and configurationChanged() signals.</para>
            <para>If a configuration state changes as a result of this update all existing QNetworkConfiguration instances are updated automatically.</para>
            <para>See also allConfigurations().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.ConfigurationAdded">
            <summary>
            <para>This signal is emitted whenever a new network configuration is added to the system. The new configuration is specified by config.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.ConfigurationRemoved">
            <summary>
            <para>This signal is emitted when a configuration is about to be removed from the system. The removed configuration, specified by config, is invalid but retains name and identifier.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.ConfigurationChanged">
            <summary>
            <para>This signal is emitted when the state of config changes.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.OnlineStateChanged">
            <summary>
            <para>This signal is emitted when the device changes from online to offline mode or vice versa. isOnline represents the new state of the device.</para>
            <para>The state is considered to be online for as long as allConfigurations(QNetworkConfiguration::Active) returns a list with at least one entry.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkConfigurationManager.UpdateCompleted">
            <summary>
            <para>This signal is emitted when the configuration update has been completed. Such an update can be initiated via updateConfigurations().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfigurationManager.Capabilities">
            <summary>
            <para>Returns the capabilities supported by the current platform.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfigurationManager.DefaultConfiguration">
            <summary>
            <para>Returns the default configuration to be used. This function always returns a discovered configuration; otherwise an invalid configuration.</para>
            <para>In some cases it may be required to call updateConfigurations() and wait for the updateCompleted() signal before calling this function.</para>
            <para>See also allConfigurations().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkConfigurationManager.IsOnline">
            <summary>
            <para>Returns true if the system is considered to be connected to another device via an active network interface; otherwise returns false.</para>
            <para>This is equivalent to the following code snippet:</para>
            <para>QNetworkConfigurationManager mgr;</para>
            <para>QList&lt;QNetworkConfiguration&gt; activeConfigs = mgr.allConfigurations(QNetworkConfiguration::Active)</para>
            <para>if (activeConfigs.count() &gt; 0)</para>
            <para>    Q_ASSERT(mgr.isOnline())</para>
            <para>else</para>
            <para>    Q_ASSERT(!mgr.isOnline())</para>
            <para>See also onlineStateChanged().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkConfigurationManager.Capability">
            <summary>
            <para>Specifies the system capabilities of the bearer API. The possible values are:</para>
            <para>The Capabilities type is a typedef for QFlags&lt;Capability&gt;. It stores an OR combination of Capability values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.CanStartAndStopInterfaces">
            <summary>Network sessions and their underlying access points can be started and stopped. If this flag is not set QNetworkSession can only monitor but not influence the state of access points. On some platforms this feature may require elevated user permissions. This option is platform specific and may not always be available.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.DirectConnectionRouting">
            <summary>Network sessions and their sockets can be bound to a particular network interface. Any packet that passes through the socket goes to the specified network interface and thus disregards standard routing table entries. This may be useful when two interfaces can reach overlapping IP ranges or an application has specific needs in regards to target networks. This option is platform specific and may not always be available.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.SystemSessionSupport">
            <summary>If this flag is set the underlying platform ensures that a network interface is not shut down until the last network session has been closed(). This works across multiple processes. If the platform session support is missing this API can only ensure the above behavior for network sessions within the same process. In general mobile platforms have such support whereas most desktop platform lack this capability.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.ApplicationLevelRoaming">
            <summary>The system gives applications control over the systems roaming behavior. Applications can initiate roaming (in case the current link is not suitable) and are consulted if the system has identified a more suitable access point.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.ForcedRoaming">
            <summary>The system disconnects an existing access point and reconnects via a more suitable one. The application does not have any control over this process and has to reconnect its active sockets.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.DataStatistics">
            <summary>If this flag is set QNetworkSession can provide statistics about transmitted and received data.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkConfigurationManager.Capability.NetworkSessionRequired">
            <summary>If this flag is set the platform requires that a network session is created before network operations can be performed.</summary>
        </member>
        <member name="T:QtNetwork.QHostAddress">
            <summary>
            <para>The QHostAddress class provides an IP address.</para>
            </summary>
            <remarks>
            <para>This class holds an IPv4 or IPv6 address in a platform- and protocol-independent manner.</para>
            <para>QHostAddress is normally used with the QTcpSocket, QTcpServer, and QUdpSocket to connect to a host or to set up a server.</para>
            <para>A host address is set with setAddress(), and retrieved with toIPv4Address(), toIPv6Address(), or toString(). You can check the type with protocol().</para>
            <para>Note: Please note that QHostAddress does not do DNS lookups. QHostInfo is needed for that.</para>
            <para>The class also supports common predefined addresses: Null, LocalHost, LocalHostIPv6, Broadcast, and Any.</para>
            <para></para>
            <para>See also QHostInfo, QTcpSocket, QTcpServer, and QUdpSocket.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor">
            <summary>
            <para>Constructs a host address object with the IP address 0.0.0.0.</para>
            <para>See also clear().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(System.UInt32)">
            <summary>
            <para>Constructs a host address object with the IPv4 address ip4Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(System.Byte*)">
            <summary>
            <para>Constructs a host address object with the IPv6 address ip6Addr.</para>
            <para>ip6Addr must be a 16-byte array in network byte order (big endian).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(QtNetwork.QIPv6Address)">
            <summary>
            <para>Constructs a host address object with the IPv6 address ip6Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(System.String)">
            <summary>
            <para>Constructs an IPv4 or IPv6 address based on the string address (e.g., &quot;127.0.0.1&quot;).</para>
            <para>See also setAddress().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(QtNetwork.QHostAddress)">
            <summary>
            <para>Constructs a copy of the given address.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.#ctor(QtNetwork.QHostAddress.SpecialAddress)">
            <summary>
            <para>Constructs a QHostAddress object for address.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(System.UInt32)">
            <summary>
            <para>Set the IPv4 address specified by ip4Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(System.Byte*)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Set the IPv6 address specified by ip6Addr.</para>
            <para>ip6Addr must be an array of 16 bytes in network byte order (high-order byte first).</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress1(System.Byte*)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Set the IPv6 address specified by ip6Addr.</para>
            <para>ip6Addr must be an array of 16 bytes in network byte order (high-order byte first).</para>
            <para>This function was introduced in  Qt 5.5.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(QtNetwork.QIPv6Address)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Set the IPv6 address specified by ip6Addr.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.SetAddress(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the IPv4 or IPv6 address specified by the string representation specified by address (e.g. &quot;127.0.0.1&quot;). Returns true and sets the address if the address was successfully parsed; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ToIPv4Address">
            <summary>
            <para>Returns the IPv4 address as a number.</para>
            <para>For example, if the address is 127.0.0.1, the returned value is 2130706433 (i.e. 0x7f000001).</para>
            <para>This value is valid if the protocol() is IPv4Protocol, or if the protocol is IPv6Protocol, and the IPv6 address is an IPv4 mapped address. (RFC4291)</para>
            <para>See also toString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ToIPv4Address(System.Boolean@)">
            <summary>
            <para>Returns the IPv4 address as a number.</para>
            <para>For example, if the address is 127.0.0.1, the returned value is 2130706433 (i.e. 0x7f000001).</para>
            <para>This value is valid if the protocol() is IPv4Protocol, or if the protocol is IPv6Protocol, and the IPv6 address is an IPv4 mapped address. (RFC4291). In those cases, ok will be set to true. Otherwise, it will be set to false.</para>
            <para>See also toString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ToIPv6Address">
            <summary>
            <para>Returns the IPv6 address as a Q_IPV6ADDR structure. The structure consists of 16 unsigned characters.</para>
            <para>Q_IPV6ADDR addr = hostAddr.toIPv6Address();</para>
            <para>// addr contains 16 unsigned characters</para>
            <para></para>
            <para>for (int i = 0; i &lt; 16; ++i) {</para>
            <para>    // process addr[i]</para>
            <para>}</para>
            <para>This value is valid if the protocol() is IPv6Protocol. If the protocol is IPv4Protocol, then the address is returned an an IPv4 mapped IPv6 address. (RFC4291)</para>
            <para>See also toString().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.ToString">
            <summary>
            <para>Returns the address as a string.</para>
            <para>For example, if the address is the IPv4 address 127.0.0.1, the returned string is &quot;127.0.0.1&quot;. For IPv6 the string format will follow the RFC5952 recommendation. For QHostAddress::Any, its IPv4 address will be returned (&quot;0.0.0.0&quot;)</para>
            <para>See also toIPv4Address().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Equality(QtNetwork.QHostAddress,QtNetwork.QHostAddress)">
            <summary>
            <para>Returns true if this host address is the same as the other address given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Equality(QtNetwork.QHostAddress,QtNetwork.QHostAddress.SpecialAddress)">
            <summary>
            <para>Returns true if this host address is the same as the other address given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Inequality(QtNetwork.QHostAddress,QtNetwork.QHostAddress)">
            <summary>
            <para>Returns true if this host address is not the same as the other address given; otherwise returns false.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.op_Inequality(QtNetwork.QHostAddress,QtNetwork.QHostAddress.SpecialAddress)">
            <summary>
            <para>Returns true if this host address is not the same as the other address given; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.Clear">
            <summary>
            <para>Sets the host address to 0.0.0.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostAddress.IsInSubnet(QtNetwork.QHostAddress,System.Int32)">
            <summary>
            <para>Returns true if this IP is in the subnet described by the network prefix subnet and netmask netmask.</para>
            <para>An IP is considered to belong to a subnet if it is contained between the lowest and the highest address in that subnet. In the case of IP version 4, the lowest address is the network address, while the highest address is the broadcast address.</para>
            <para>The subnet argument does not have to be the actual network address (the lowest address in the subnet). It can be any valid IP belonging to that subnet. In particular, if it is equal to the IP address held by this object, this function will always return true (provided the netmask is a valid value).</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also parseSubnet().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostAddress.ScopeId">
            <summary>
            <para>Returns the scope ID of an IPv6 address. For IPv4 addresses, or if the address does not contain a scope ID, an empty QString is returned.</para>
            <para>The IPv6 scope ID specifies the scope of reachability for non-global IPv6 addresses, limiting the area in which the address can be used. All IPv6 addresses are associated with such a reachability scope. The scope ID is used to disambiguate addresses that are not guaranteed to be globally unique.</para>
            <para>IPv6 specifies the following four levels of reachability:</para>
            <para></para>
            <para>Node-local: Addresses that are only used for communicating with services on the same interface (e.g., the loopback interface &quot;::1&quot;).</para>
            <para>Link-local: Addresses that are local to the network interface (link). There is always one link-local address for each IPv6 interface on your host. Link-local addresses (&quot;fe80...&quot;) are generated from the MAC address of the local network adaptor, and are not guaranteed to be unique.</para>
            <para>Site-local: Addresses that are local to the site / private network (e.g., the company intranet). Site-local addresses (&quot;fec0...&quot;) are usually distributed by the site router, and are not guaranteed to be unique outside of the local site.</para>
            <para>Global: For globally routable addresses, such as public servers on the Internet.</para>
            <para></para>
            <para>When using a link-local or site-local address for IPv6 connections, you must specify the scope ID. The scope ID for a link-local address is usually the same as the interface name (e.g., &quot;eth0&quot;, &quot;en1&quot;) or number (e.g., &quot;1&quot;, &quot;2&quot;).</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also setScopeId().</para>
            <para></para>
            <para>Sets the IPv6 scope ID of the address to id. If the address protocol is not IPv6, this function does nothing.</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also scopeId().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostAddress.Protocol">
            <summary>
            <para>Returns the network layer protocol of the host address.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostAddress.IsNull">
            <summary>
            <para>Returns true if this host address is null (INADDR_ANY or in6addr_any). The default constructor creates a null address, and that address is not valid for any host or interface.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostAddress.IsLoopback">
            <summary>
            <para>returns true if the address is the IPv6 loopback address, or any of the IPv4 loopback addresses.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.Null">
            <summary>The null address object. Equivalent to QHostAddress().</summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.Broadcast">
            <summary>The IPv4 broadcast address. Equivalent to QHostAddress("255.255.255.255").</summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.LocalHost">
            <summary>The IPv4 localhost address. Equivalent to QHostAddress("127.0.0.1").</summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.LocalHostIPv6">
            <summary>The IPv6 localhost address. Equivalent to QHostAddress("::1").</summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.Any">
            <summary>The dual stack any-address. A socket bound with this address will listen on both IPv4 and IPv6 interfaces.</summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.AnyIPv6">
            <summary>The IPv6 any-address. Equivalent to QHostAddress("::"). A socket bound with this address will listen only on IPv6 interaces.</summary>
        </member>
        <member name="F:QtNetwork.QHostAddress.SpecialAddress.AnyIPv4">
            <summary>The IPv4 any-address. Equivalent to QHostAddress("0.0.0.0"). A socket bound with this address will listen only on IPv4 interaces.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkAddressEntry">
            <summary>
            <para>The QNetworkAddressEntry class stores one IP address supported by a network interface, along with its associated netmask and broadcast address.</para>
            </summary>
            <remarks>
            <para>Each network interface can contain zero or more IP addresses, which in turn can be associated with a netmask and/or a broadcast address (depending on support from the operating system).</para>
            <para>This class represents one such group.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.#ctor">
            <summary>
            <para>Constructs an empty QNetworkAddressEntry object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.#ctor(QtNetwork.QNetworkAddressEntry)">
            <summary>
            <para>Constructs a QNetworkAddressEntry object that is a copy of the object other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.Swap(QtNetwork.QNetworkAddressEntry)">
            <summary>
            <para>Swaps this network address entry instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.op_Equality(QtNetwork.QNetworkAddressEntry,QtNetwork.QNetworkAddressEntry)">
            <summary>
            <para>Returns true if this network address entry is the same as other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkAddressEntry.op_Inequality(QtNetwork.QNetworkAddressEntry,QtNetwork.QNetworkAddressEntry)">
            <summary>
            <para>Returns true if this network address entry is different from other.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.Ip">
            <summary>
            <para>This function returns one IPv4 or IPv6 address found, that was found in a network interface.</para>
            <para>See also setIp().</para>
            <para></para>
            <para>Sets the IP address the QNetworkAddressEntry object contains to newIp.</para>
            <para>See also ip().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.Netmask">
            <summary>
            <para>Returns the netmask associated with the IP address. The netmask is expressed in the form of an IP address, such as 255.255.0.0.</para>
            <para>For IPv6 addresses, the prefix length is converted to an address where the number of bits set to 1 is equal to the prefix length. For a prefix length of 64 bits (the most common value), the netmask will be expressed as a QHostAddress holding the address FFFF:FFFF:FFFF:FFFF::</para>
            <para>See also setNetmask() and prefixLength().</para>
            <para></para>
            <para>Sets the netmask that this QNetworkAddressEntry object contains to newNetmask. Setting the netmask also sets the prefix length to match the new netmask.</para>
            <para>See also netmask() and setPrefixLength().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.PrefixLength">
            <summary>
            <para>Returns the prefix length of this IP address. The prefix length matches the number of bits set to 1 in the netmask (see netmask()). For IPv4 addresses, the value is between 0 and 32. For IPv6 addresses, it's contained between 0 and 128 and is the preferred form of representing addresses.</para>
            <para>This function returns -1 if the prefix length could not be determined (i.e., netmask() returns a null QHostAddress()).</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also setPrefixLength() and netmask().</para>
            <para></para>
            <para>Sets the prefix length of this IP address to length. The value of length must be valid for this type of IP address: between 0 and 32 for IPv4 addresses, between 0 and 128 for IPv6 addresses. Setting to any invalid value is equivalent to setting to -1, which means &quot;no prefix length&quot;.</para>
            <para>Setting the prefix length also sets the netmask (see netmask()).</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also prefixLength() and setNetmask().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkAddressEntry.Broadcast">
            <summary>
            <para>Returns the broadcast address associated with the IPv4 address and netmask. It can usually be derived from those two by setting to 1 the bits of the IP address where the netmask contains a 0. (In other words, by bitwise-OR'ing the IP address with the inverse of the netmask)</para>
            <para>This member is always empty for IPv6 addresses, since the concept of broadcast has been abandoned in that system in favor of multicast. In particular, the group of hosts corresponding to all the nodes in the local network can be reached by the &quot;all-nodes&quot; special multicast group (address FF02::1).</para>
            <para>See also setBroadcast().</para>
            <para></para>
            <para>Sets the broadcast IP address of this QNetworkAddressEntry object to newBroadcast.</para>
            <para>See also broadcast().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkInterface">
            <summary>
            <para>The QNetworkInterface class provides a listing of the host's IP addresses and network interfaces.</para>
            </summary>
            <remarks>
            <para>QNetworkInterface represents one network interface attached to the host where the program is being run. Each network interface may contain zero or more IP addresses, each of which is optionally associated with a netmask and/or a broadcast address. The list of such trios can be obtained with addressEntries(). Alternatively, when the netmask or the broadcast addresses aren't necessary, use the allAddresses() convenience function to obtain just the IP addresses.</para>
            <para>QNetworkInterface also reports the interface's hardware address with hardwareAddress().</para>
            <para>Not all operating systems support reporting all features. Only the IPv4 addresses are guaranteed to be listed by this class in all platforms. In particular, IPv6 address listing is only supported on Windows, Linux, OS X and the BSDs.</para>
            <para></para>
            <para>See also QNetworkAddressEntry.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.#ctor">
            <summary>
            <para>Constructs an empty network interface object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.#ctor(QtNetwork.QNetworkInterface)">
            <summary>
            <para>Creates a copy of the QNetworkInterface object contained in other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.Swap(QtNetwork.QNetworkInterface)">
            <summary>
            <para>Swaps this network interface instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.InterfaceFromName(System.String)">
            <summary>
            <para>Returns a QNetworkInterface object for the interface named name. If no such interface exists, this function returns an invalid QNetworkInterface object.</para>
            <para>See also name() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkInterface.InterfaceFromIndex(System.Int32)">
            <summary>
            <para>Returns a QNetworkInterface object for the interface whose internal ID is index. Network interfaces have a unique identifier called the &quot;interface index&quot; to distinguish it from other interfaces on the system. Often, this value is assigned progressively and interfaces being removed and then added again get a different value every time.</para>
            <para>This index is also found in the IPv6 address' scope ID field.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.IsValid">
            <summary>
            <para>Returns true if this QNetworkInterface object contains valid information about a network interface.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.Index">
            <summary>
            <para>Returns the interface system index, if known. This is an integer assigned by the operating system to identify this interface and it generally doesn't change. It matches the scope ID field in IPv6 addresses.</para>
            <para>If the index isn't known, this function returns 0.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.Name">
            <summary>
            <para>Returns the name of this network interface. On Unix systems, this is a string containing the type of the interface and optionally a sequence number, such as &quot;eth0&quot;, &quot;lo&quot; or &quot;pcn0&quot;. On Windows, it's an internal ID that cannot be changed by the user.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.HumanReadableName">
            <summary>
            <para>Returns the human-readable name of this network interface on Windows, such as &quot;Local Area Connection&quot;, if the name could be determined. If it couldn't, this function returns the same as name(). The human-readable name is a name that the user can modify in the Windows Control Panel, so it may change during the execution of the program.</para>
            <para>On Unix, this function currently always returns the same as name(), since Unix systems don't store a configuration for human-readable names.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.Flags">
            <summary>
            <para>Returns the flags associated with this network interface.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkInterface.HardwareAddress">
            <summary>
            <para>Returns the low-level hardware address for this interface. On Ethernet interfaces, this will be a MAC address in string representation, separated by colons.</para>
            <para>Other interface types may have other types of hardware addresses. Implementations should not depend on this function returning a valid MAC address.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkInterface.InterfaceFlag">
            <summary>
            <para>Specifies the flags associated with this network interface. The possible values are:</para>
            <para>Note that one network interface cannot be both broadcast-based and point-to-point.</para>
            <para>The InterfaceFlags type is a typedef for QFlags&lt;InterfaceFlag&gt;. It stores an OR combination of InterfaceFlag values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsUp">
            <summary>the network interface is active</summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsRunning">
            <summary>the network interface has resources allocated</summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.CanBroadcast">
            <summary>the network interface works in broadcast mode</summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsLoopBack">
            <summary>the network interface is a loopback interface: that is, it's a virtual interface whose destination is the host computer itself</summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.IsPointToPoint">
            <summary>the network interface is a point-to-point interface: that is, there is one, single other address that can be directly reached by it.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkInterface.InterfaceFlag.CanMulticast">
            <summary>the network interface supports multicasting</summary>
        </member>
        <member name="T:QtNetwork.QNetworkSession">
            <summary>
            <para>The QNetworkSession class provides control over the system's access points and enables session management for cases when multiple clients access the same access point.</para>
            </summary>
            <remarks>
            <para>A QNetworkSession enables control over the system's network interfaces. The session's configuration parameter are determined via the QNetworkConfiguration object to which it is bound. Depending on the type of the session (single access point or service network) a session may be linked to one or more network interfaces. By means of opening and closing of network sessions a developer can start and stop the systems network interfaces. If the configuration represents multiple access points (see QNetworkConfiguration::ServiceNetwork) more advanced features such as roaming may be supported.</para>
            <para>QNetworkSession supports session management within the same process and depending on the platform's capabilities may support out-of-process sessions. If the same network configuration is used by multiple open sessions the underlying network interface is only terminated once the last session has been closed.</para>
            <para></para>
            <para>Roaming</para>
            <para>Applications may connect to the preferredConfigurationChanged() signal in order to receive notifications when a more suitable access point becomes available. In response to this signal the application must either initiate the roaming via migrate() or ignore() the new access point. Once the session has roamed the newConfigurationActivated() signal is emitted. The application may now test the carrier and must either accept() or reject() it. The session will return to the previous access point if the roaming was rejected. The subsequent state diagram depicts the required state transitions.</para>
            <para></para>
            <para>Some platforms may distinguish forced roaming and application level roaming (ALR). ALR implies that the application controls (via migrate(), ignore(), accept() and reject()) whether a network session can roam from one access point to the next. Such control is useful if the application maintains stateful socket connections and wants to control the transition from one interface to the next. Forced roaming implies that the system automatically roams to the next network without consulting the application. This has the advantage that the application can make use of roaming features without actually being aware of it. It is expected that the application detects that the underlying socket is broken and automatically reconnects via the new network link.</para>
            <para>If the platform supports both modes of roaming, an application indicates its preference by connecting to the preferredConfigurationChanged() signal. Connecting to this signal means that the application wants to take control over the roaming behavior and therefore implies application level roaming. If the client does not connect to the preferredConfigurationChanged(), forced roaming is used. If forced roaming is not supported the network session will not roam by default.</para>
            <para>Some applications may want to suppress any form of roaming altogether. Possible use cases may be high priority downloads or remote services which cannot handle a roaming enabled client. Clients can suppress roaming by connecting to the preferredConfigurationChanged() signal and answer each signal emission with ignore().</para>
            <para></para>
            <para>See also QNetworkConfiguration and QNetworkConfigurationManager.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkSession.#ctor(QtNetwork.QNetworkConfiguration,QtCore.QObject)">
            <summary>
            <para>Constructs a session based on connectionConfig with the given parent.</para>
            <para>See also QNetworkConfiguration.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.SessionProperty(System.String)">
            <summary>
            <para>Returns the value for property key.</para>
            <para>A network session can have properties attached which may describe the session in more details. This function can be used to gain access to those properties.</para>
            <para>The following property keys are guaranteed to be specified on all platforms:</para>
            <para></para>
            <para> KeyDescription</para>
            <para>ActiveConfiguration	If the session isOpen() this property returns the identifier of the QNetworkConfiguration that is used by this session; otherwise an empty string.The main purpose of this key is to determine which Internet access point is used if the session is based on a ServiceNetwork. The following code snippet highlights the difference:</para>
            <para>QNetworkConfigurationManager mgr;</para>
            <para>QNetworkConfiguration ap = mgr.defaultConfiguration();</para>
            <para>QNetworkSession *session = new QNetworkSession(ap);</para>
            <para>... //code activates session</para>
            <para></para>
            <para>QString ident = session-&gt;sessionProperty(&quot;ActiveConfiguration&quot;).toString();</para>
            <para>if ( ap.type() == QNetworkConfiguration::ServiceNetwork ) {</para>
            <para>    Q_ASSERT( ap.identifier() != ident );</para>
            <para>    Q_ASSERT( ap.children().contains( mgr.configurationFromIdentifier(ident) ) );</para>
            <para>} else if ( ap.type() == QNetworkConfiguration::InternetAccessPoint ) {</para>
            <para>    Q_ASSERT( ap.identifier() == ident );</para>
            <para>}</para>
            <para></para>
            <para>UserChoiceConfiguration	If the session isOpen() and is bound to a QNetworkConfiguration of type UserChoice, this property returns the identifier of the QNetworkConfiguration that the configuration resolved to when open() was called; otherwise an empty string.The purpose of this key is to determine the real QNetworkConfiguration that the session is using. This key is different from ActiveConfiguration in that this key may return an identifier for either a service network or a Internet access points configurations, whereas ActiveConfiguration always returns identifiers to Internet access points configurations.</para>
            <para></para>
            <para>ConnectInBackground	Setting this property to true before calling open() implies that the connection attempt is made but if no connection can be established, the user is not connsulted and asked to select a suitable connection. This property is not set by default and support for it depends on the platform.</para>
            <para>AutoCloseSessionTimeout	If the session requires polling to keep its state up to date, this property holds the timeout in milliseconds before the session will automatically close. If the value of this property is -1 the session will not automatically close. This property is set to -1 by default.The purpose of this property is to minimize resource use on platforms that use polling to update the state of the session. Applications can set the value of this property to the desired timeout before the session is closed. In response to the closed() signal the network session should be deleted to ensure that all polling is stopped. The session can then be recreated once it is required again. This property has no effect for sessions that do not require polling.</para>
            <para></para>
            <para></para>
            <para>See also setSessionProperty().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.SetSessionProperty(System.String,QtCore.QVariant)">
            <summary>
            <para>Sets the property value on the session. The property is identified using key. Removing an already set property can be achieved by passing an invalid QVariant.</para>
            <para>Note that the UserChoiceConfiguration and ActiveConfiguration properties are read only and cannot be changed using this method.</para>
            <para>See also sessionProperty().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.WaitForOpened(System.Int32)">
            <summary>
            <para>Waits until the session has been opened, up to msecs milliseconds. If the session has been opened, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
            <para>The following example waits up to one second for the session to be opened:</para>
            <para>session-&gt;open();</para>
            <para>if (session-&gt;waitForOpened(1000))</para>
            <para>    qDebug(&quot;Open!&quot;);</para>
            <para>If msecs is -1, this function will not time out.</para>
            <para>See also open() and error().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Open">
            <summary>
            <para>Creates an open session which increases the session counter on the underlying network interface. The system will not terminate a network interface until the session reference counter reaches zero. Therefore an open session allows an application to register its use of the interface.</para>
            <para>As a result of calling open() the interface will be started if it is not connected/up yet. Some platforms may not provide support for out-of-process sessions. On such platforms the session counter ignores any sessions held by another process. The platform capabilities can be detected via QNetworkConfigurationManager::capabilities().</para>
            <para>Note that this call is asynchronous. Depending on the outcome of this call the results can be enquired by connecting to the stateChanged(), opened() or error() signals.</para>
            <para>It is not a requirement to open a session in order to monitor the underlying network interface.</para>
            <para>See also close(), stop(), and isOpen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Close">
            <summary>
            <para>Decreases the session counter on the associated network configuration. If the session counter reaches zero the active network interface is shut down. This also means that state() will only change from Connected to Disconnected if the current session was the last open session.</para>
            <para>If the platform does not support out-of-process sessions calling this function does not stop the interface. In this case stop() has to be used to force a shut down. The platform capabilities can be detected via QNetworkConfigurationManager::capabilities().</para>
            <para>Note that this call is asynchronous. Depending on the outcome of this call the results can be enquired by connecting to the stateChanged(), opened() or error() signals.</para>
            <para>See also open(), stop(), and isOpen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Stop">
            <summary>
            <para>Invalidates all open sessions against the network interface and therefore stops the underlying network interface. This function always changes the session's state() flag to Disconnected.</para>
            <para>See also open() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Migrate">
            <summary>
            <para>Instructs the session to roam to the new access point. The old access point remains active until the application calls accept().</para>
            <para>The newConfigurationActivated() signal is emitted once roaming has been completed.</para>
            <para>See also accept().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Ignore">
            <summary>
            <para>This function indicates that the application does not wish to roam the session.</para>
            <para>See also migrate().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Accept">
            <summary>
            <para>Instructs the session to permanently accept the new access point. Once this function has been called the session may not return to the old access point.</para>
            <para>The old access point may be closed in the process if there are no other network sessions for it. Therefore any open socket that still uses the old access point may become unusable and should be closed before completing the migration.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkSession.Reject">
            <summary>
            <para>The new access point is not suitable for the application. By calling this function the session returns to the previous access point/configuration. This action may invalidate any socket that has been created via the not desired access point.</para>
            <para>See also accept().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.StateChanged">
            <summary>
            <para>This signal is emitted whenever the state of the network session changes. The state parameter is the new state.</para>
            <para>See also state().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.Opened">
            <summary>
            <para>This signal is emitted when the network session has been opened.</para>
            <para>The underlying network interface will not be shut down as long as the session remains open. Note that this feature is dependent on system wide session support.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.Closed">
            <summary>
            <para>This signal is emitted when the network session has been closed.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.ErrorError">
            <summary>
            <para>This signal is emitted after an error occurred. The error parameter describes the error that occurred.</para>
            <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.PreferredConfigurationChanged">
            <summary>
            <para>This signal is emitted when the preferred configuration/access point for the session changes. Only sessions which are based on service network configurations may emit this signal. config can be used to determine access point specific details such as proxy settings and isSeamless indicates whether roaming will break the sessions IP address.</para>
            <para>As a consequence to this signal the application must either start the roaming process by calling migrate() or choose to ignore() the new access point.</para>
            <para>If the roaming process is non-seamless the IP address will change which means that a socket becomes invalid. However seamless mobility can ensure that the local IP address does not change. This is achieved by using a virtual IP address which is bound to the actual link address. During the roaming process the virtual address is attached to the new link address.</para>
            <para>Some platforms may support the concept of Forced Roaming and Application Level Roaming (ALR). Forced roaming implies that the platform may simply roam to a new configuration without consulting applications. It is up to the application to detect the link layer loss and reestablish its sockets. In contrast ALR provides the opportunity to prevent the system from roaming. If this session is based on a configuration that supports roaming the application can choose whether it wants to be consulted (ALR use case) by connecting to this signal. For as long as this signal connection remains the session remains registered as a roaming stakeholder; otherwise roaming will be enforced by the platform.</para>
            <para>See also migrate(), ignore(), and QNetworkConfiguration::isRoamingAvailable().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.NewConfigurationActivated">
            <summary>
            <para>This signal is emitted once the session has roamed to the new access point. The application may reopen its socket and test the suitability of the new network link. Subsequently it must either accept() or reject() the new access point.</para>
            <para>See also accept() and reject().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QNetworkSession.UsagePoliciesChanged">
            <summary>
            <para>This signal is emitted when the usagePolicies in force are changed by the system.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.IsOpen">
            <summary>
            <para>Returns true if this session is open. If the number of all open sessions is greater than zero the underlying network interface will remain connected/up.</para>
            <para>The session can be controlled via open() and close().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.Configuration">
            <summary>
            <para>Returns the QNetworkConfiguration that this network session object is based on.</para>
            <para>See also QNetworkConfiguration.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.Interface">
            <summary>
            <para>Returns the network interface that is used by this session.</para>
            <para>This function only returns a valid QNetworkInterface when this session is Connected.</para>
            <para>The returned interface may change as a result of a roaming process.</para>
            <para>See also state().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.state">
            <summary>
            <para>Returns the state of the session.</para>
            <para>If the session is based on a single access point configuration the state of the session is the same as the state of the associated network interface. Therefore a network session object can be used to monitor network interfaces.</para>
            <para>A QNetworkConfiguration::ServiceNetwork based session summarizes the state of all its children and therefore returns the Connected state if at least one of the service network's children() configurations is active.</para>
            <para>Note that it is not required to hold an open session in order to obtain the network interface state. A connected but closed session may be used to monitor network interfaces whereas an open and connected session object may prevent the network interface from being shut down.</para>
            <para>See also error() and stateChanged().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.Error">
            <summary>
            <para>Returns the type of error that last occurred.</para>
            <para>See also state() and errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.ErrorString">
            <summary>
            <para>Returns a human-readable description of the last device error that occurred.</para>
            <para>See also error().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.BytesWritten">
            <summary>
            <para>Returns the amount of data sent in bytes; otherwise 0.</para>
            <para>This field value includes the usage across all open network sessions which use the same network interface.</para>
            <para>If the session is based on a service network configuration the number of sent bytes across all active member configurations are returned.</para>
            <para>This function may not always be supported on all platforms and returns 0. The platform capability can be detected via QNetworkConfigurationManager::DataStatistics.</para>
            <para>Note: On some platforms this function may run the main event loop.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.BytesReceived">
            <summary>
            <para>Returns the amount of data received in bytes; otherwise 0.</para>
            <para>This field value includes the usage across all open network sessions which use the same network interface.</para>
            <para>If the session is based on a service network configuration the number of sent bytes across all active member configurations are returned.</para>
            <para>This function may not always be supported on all platforms and returns 0. The platform capability can be detected via QNetworkConfigurationManager::DataStatistics.</para>
            <para>Note: On some platforms this function may run the main event loop.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.ActiveTime">
            <summary>
            <para>Returns the number of seconds that the session has been active.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkSession.UsagePolicies">
            <summary>
            <para>Returns the network usage policies currently in force by the system.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkSession.State">
            <summary>
            <para>This enum describes the connectivity state of the session. If the session is based on a single access point configuration the state of the session is the same as the state of the associated network interface.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Invalid">
            <summary>The session is invalid due to an invalid configuration. This may happen due to a removed access point or a configuration that was invalid to begin with.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.NotAvailable">
            <summary>The session is based on a defined but not yet discovered QNetworkConfiguration (see QNetworkConfiguration::StateFlag).</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Connecting">
            <summary>The network session is being established.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Connected">
            <summary>The network session is connected. If the current process wishes to use this session it has to register its interest by calling open(). A network session is considered to be ready for socket operations if it isOpen() and connected.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Closing">
            <summary>The network session is in the process of being shut down.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Disconnected">
            <summary>The network session is not connected. The associated QNetworkConfiguration has the state QNetworkConfiguration::Discovered.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.State.Roaming">
            <summary>The network session is roaming from one access point to another access point.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkSession.SessionError">
            <summary>
            <para>This enum describes the session errors that can occur.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.UnknownSessionError">
            <summary>An unidentified error occurred.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.SessionAbortedError">
            <summary>The session was aborted by the user or system.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.RoamingError">
            <summary>The session cannot roam to a new configuration.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.OperationNotSupportedError">
            <summary>The operation is not supported for current configuration.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.SessionError.InvalidConfigurationError">
            <summary>The operation cannot currently be performed for the current configuration.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkSession.UsagePolicy">
            <summary>
            <para>These flags allow the system to inform the application of network usage restrictions that may be in place.</para>
            <para>This enum was introduced or modified in  Qt 5.0.</para>
            <para>The UsagePolicies type is a typedef for QFlags&lt;UsagePolicy&gt;. It stores an OR combination of UsagePolicy values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.UsagePolicy.NoPolicy">
            <summary>No policy in force, usage is unrestricted.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkSession.UsagePolicy.NoBackgroundTrafficPolicy">
            <summary>Background network traffic (not user initiated) should be avoided for example to save battery or data charges</summary>
        </member>
        <member name="T:QtNetwork.QAuthenticator">
            <summary>
            <para>The QAuthenticator class provides an authentication object.</para>
            </summary>
            <remarks>
            <para>The QAuthenticator class is usually used in the authenticationRequired() and proxyAuthenticationRequired() signals of QNetworkAccessManager and QAbstractSocket. The class provides a way to pass back the required authentication information to the socket when accessing services that require authentication.</para>
            <para>QAuthenticator supports the following authentication methods:</para>
            <para></para>
            <para>Basic</para>
            <para>NTLM version 2</para>
            <para>Digest-MD5</para>
            <para></para>
            <para></para>
            <para></para>
            <para>Options</para>
            <para>In addition to the username and password required for authentication, a QAuthenticator object can also contain additional options. The options() function can be used to query incoming options sent by the server; the setOption() function can be used to set outgoing options, to be processed by the authenticator calculation. The options accepted and provided depend on the authentication type (see method()).</para>
            <para>The following tables list known incoming options as well as accepted outgoing options. The list of incoming options is not exhaustive, since servers may include additional information at any time. The list of outgoing options is exhaustive, however, and no unknown options will be treated or sent back to the server.</para>
            <para></para>
            <para>Basic</para>
            <para></para>
            <para>OptionDirectionTypeDescription</para>
            <para>realm	Incoming	QString	Contains the realm of the authentication, the same as realm()</para>
            <para></para>
            <para>The Basic authentication mechanism supports no outgoing options.</para>
            <para></para>
            <para>NTLM version 2</para>
            <para>The NTLM authentication mechanism currently supports no incoming or outgoing options. On Windows, if no user has been set, domain\user credentials will be searched for on the local system to enable Single-Sign-On functionality.</para>
            <para></para>
            <para>Digest-MD5</para>
            <para></para>
            <para>OptionDirectionTypeDescription</para>
            <para>realm	Incoming	QString	Contains the realm of the authentication, the same as realm()</para>
            <para></para>
            <para>The Digest-MD5 authentication mechanism supports no outgoing options.</para>
            <para></para>
            <para>See also QSslSocket.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QAuthenticator.#ctor">
            <summary>
            <para>Constructs an empty authentication object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.#ctor(QtNetwork.QAuthenticator)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.op_Equality(QtNetwork.QAuthenticator,QtNetwork.QAuthenticator)">
            <summary>
            <para>Returns true if this authenticator is identical to other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.op_Inequality(QtNetwork.QAuthenticator,QtNetwork.QAuthenticator)">
            <summary>
            <para>Returns true if this authenticator is different from other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.Option(System.String)">
            <summary>
            <para>Returns the value related to option opt if it was set by the server. See the Options section for more information on incoming options. If option opt isn't found, an invalid QVariant will be returned.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setOption(), options(), and QAuthenticator options.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QAuthenticator.SetOption(System.String,QtCore.QVariant)">
            <summary>
            <para>Sets the outgoing option opt to value value. See the Options section for more information on outgoing options.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also options(), option(), and QAuthenticator options.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.User">
            <summary>
            <para>Returns the user used for authentication.</para>
            <para>See also setUser().</para>
            <para></para>
            <para>Sets the user used for authentication.</para>
            <para>See also user() and QNetworkAccessManager::authenticationRequired().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.Password">
            <summary>
            <para>Returns the password used for authentication.</para>
            <para>See also setPassword().</para>
            <para></para>
            <para>Sets the password used for authentication.</para>
            <para>See also password() and QNetworkAccessManager::authenticationRequired().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.Realm">
            <summary>
            <para>Returns the realm requiring authentication.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QAuthenticator.IsNull">
            <summary>
            <para>Returns true if the object has not been initialized. Returns false if non-const member functions have been called, or the content was constructed or copied from another initialized QAuthenticator object.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QDnsDomainNameRecord">
            <summary>
            <para>The QDnsDomainNameRecord class stores information about a domain name record.</para>
            </summary>
            <remarks>
            <para>When performing a name server lookup, zero or more records will be returned. Each record is represented by a QDnsDomainNameRecord instance.</para>
            <para></para>
            <para>See also QDnsLookup.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QDnsDomainNameRecord.#ctor">
            <summary>
            <para>Constructs an empty domain name record object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsDomainNameRecord.#ctor(QtNetwork.QDnsDomainNameRecord)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsDomainNameRecord.Swap(QtNetwork.QDnsDomainNameRecord)">
            <summary>
            <para>Swaps this domain-name record instance with other. This function is very fast and never fails.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsDomainNameRecord.Name">
            <summary>
            <para>Returns the name for this record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsDomainNameRecord.TimeToLive">
            <summary>
            <para>Returns the duration in seconds for which this record is valid.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsDomainNameRecord.Value">
            <summary>
            <para>Returns the value for this domain name record.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QDnsHostAddressRecord">
            <summary>
            <para>The QDnsHostAddressRecord class stores information about a host address record.</para>
            </summary>
            <remarks>
            <para>When performing an address lookup, zero or more records will be returned. Each record is represented by a QDnsHostAddressRecord instance.</para>
            <para></para>
            <para>See also QDnsLookup.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QDnsHostAddressRecord.#ctor">
            <summary>
            <para>Constructs an empty host address record object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsHostAddressRecord.#ctor(QtNetwork.QDnsHostAddressRecord)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsHostAddressRecord.Swap(QtNetwork.QDnsHostAddressRecord)">
            <summary>
            <para>Swaps this host address record instance with other. This function is very fast and never fails.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsHostAddressRecord.Name">
            <summary>
            <para>Returns the name for this record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsHostAddressRecord.TimeToLive">
            <summary>
            <para>Returns the duration in seconds for which this record is valid.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsHostAddressRecord.Value">
            <summary>
            <para>Returns the value for this host address record.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QDnsMailExchangeRecord">
            <summary>
            <para>The QDnsMailExchangeRecord class stores information about a DNS MX record.</para>
            </summary>
            <remarks>
            <para>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsMailExchangeRecord instance.</para>
            <para>The meaning of the fields is defined in RFC 1035.</para>
            <para></para>
            <para>See also QDnsLookup.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QDnsMailExchangeRecord.#ctor">
            <summary>
            <para>Constructs an empty mail exchange record object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsMailExchangeRecord.#ctor(QtNetwork.QDnsMailExchangeRecord)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsMailExchangeRecord.Swap(QtNetwork.QDnsMailExchangeRecord)">
            <summary>
            <para>Swaps this mail exchange record with other. This function is very fast and never fails.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsMailExchangeRecord.Exchange">
            <summary>
            <para>Returns the domain name of the mail exchange for this record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsMailExchangeRecord.Name">
            <summary>
            <para>Returns the name for this record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsMailExchangeRecord.Preference">
            <summary>
            <para>Returns the preference for this record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsMailExchangeRecord.TimeToLive">
            <summary>
            <para>Returns the duration in seconds for which this record is valid.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QDnsServiceRecord">
            <summary>
            <para>The QDnsServiceRecord class stores information about a DNS SRV record.</para>
            </summary>
            <remarks>
            <para>When performing a lookup on a service, zero or more records will be returned. Each record is represented by a QDnsServiceRecord instance.</para>
            <para>The meaning of the fields is defined in RFC 2782.</para>
            <para></para>
            <para>See also QDnsLookup.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QDnsServiceRecord.#ctor">
            <summary>
            <para>Constructs an empty service record object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsServiceRecord.#ctor(QtNetwork.QDnsServiceRecord)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsServiceRecord.Swap(QtNetwork.QDnsServiceRecord)">
            <summary>
            <para>Swaps this service record instance with other. This function is very fast and never fails.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsServiceRecord.Name">
            <summary>
            <para>Returns the name for this record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsServiceRecord.Port">
            <summary>
            <para>Returns the port on the target host for this service record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsServiceRecord.Priority">
            <summary>
            <para>Returns the priority for this service record.</para>
            <para>A client must attempt to contact the target host with the lowest-numbered priority.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsServiceRecord.Target">
            <summary>
            <para>Returns the domain name of the target host for this service record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsServiceRecord.TimeToLive">
            <summary>
            <para>Returns the duration in seconds for which this record is valid.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsServiceRecord.Weight">
            <summary>
            <para>Returns the weight for this service record.</para>
            <para>The weight field specifies a relative weight for entries with the same priority. Entries with higher weights should be selected with a higher probability.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QDnsTextRecord">
            <summary>
            <para>The QDnsTextRecord class stores information about a DNS TXT record.</para>
            </summary>
            <remarks>
            <para>When performing a text lookup, zero or more records will be returned. Each record is represented by a QDnsTextRecord instance.</para>
            <para>The meaning of the fields is defined in RFC 1035.</para>
            <para></para>
            <para>See also QDnsLookup.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QDnsTextRecord.#ctor">
            <summary>
            <para>Constructs an empty text record object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsTextRecord.#ctor(QtNetwork.QDnsTextRecord)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsTextRecord.Swap(QtNetwork.QDnsTextRecord)">
            <summary>
            <para>Swaps this text record instance with other. This function is very fast and never fails.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsTextRecord.Name">
            <summary>
            <para>Returns the name for this text record.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsTextRecord.TimeToLive">
            <summary>
            <para>Returns the duration in seconds for which this record is valid.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QDnsLookup">
            <summary>
            <para>The QDnsLookup class represents a DNS lookup.</para>
            </summary>
            <remarks>
            <para>QDnsLookup uses the mechanisms provided by the operating system to perform DNS lookups. To perform a lookup you need to specify a name and type then invoke the lookup() slot. The finished() signal will be emitted upon completion.</para>
            <para>For example, you can determine which servers an XMPP chat client should connect to for a given domain with:</para>
            <para>void MyObject::lookupServers()</para>
            <para>{</para>
            <para>    // Create a DNS lookup.</para>
            <para>    dns = new QDnsLookup(this);</para>
            <para>    connect(dns, SIGNAL(finished()),</para>
            <para>            this, SLOT(handleServers()));</para>
            <para></para>
            <para>    // Find the XMPP servers for gmail.com</para>
            <para>    dns-&gt;setType(QDnsLookup::SRV);</para>
            <para>    dns-&gt;setName(&quot;_xmpp-client._tcp.gmail.com&quot;);</para>
            <para>    dns-&gt;lookup();</para>
            <para>}</para>
            <para>Once the request finishes you can handle the results with:</para>
            <para>void MyObject::handleServers()</para>
            <para>{</para>
            <para>    // Check the lookup succeeded.</para>
            <para>    if (dns-&gt;error() != QDnsLookup::NoError) {</para>
            <para>        qWarning(&quot;DNS lookup failed&quot;);</para>
            <para>        dns-&gt;deleteLater();</para>
            <para>        return;</para>
            <para>    }</para>
            <para></para>
            <para>    // Handle the results.</para>
            <para>    foreach (const QDnsServiceRecord &amp;record, dns-&gt;serviceRecords()) {</para>
            <para>        ...</para>
            <para>    }</para>
            <para>    dns-&gt;deleteLater();</para>
            <para>}</para>
            <para>Note: If you simply want to find the IP address(es) associated with a host name, or the host name associated with an IP address you should use QHostInfo instead.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QDnsLookup.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QDnsLookup object and sets parent as the parent object.</para>
            <para>The type property will default to QDnsLookup::A.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsLookup.#ctor(QtNetwork.QDnsLookup.Type,System.String,QtCore.QObject)">
            <summary>
            <para>Constructs a QDnsLookup object for the given type and name and sets parent as the parent object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsLookup.#ctor(QtNetwork.QDnsLookup.Type,System.String,QtNetwork.QHostAddress,QtCore.QObject)">
            <summary>
            <para>Constructs a QDnsLookup object for the given type, name and nameserver and sets parent as the parent object.</para>
            <para>This function was introduced in  Qt 5.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsLookup.Abort">
            <summary>
            <para>Aborts the DNS lookup operation.</para>
            <para>If the lookup is already finished, does nothing.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QDnsLookup.Lookup">
            <summary>
            <para>Performs the DNS lookup.</para>
            <para>The finished() signal is emitted upon completion.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QDnsLookup.Finished">
            <summary>
            <para>This property holds the type of error that occurred if the DNS lookup failed, or NoError.</para>
            <para>Access functions:</para>
            <para></para>
            <para> Error 	error() const</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	finished()</para>
            <para></para>
            </summary>
        </member>
        <member name="E:QtNetwork.QDnsLookup.NameChanged">
            <summary>
            <para>This property holds the name to lookup.</para>
            <para>Note: The name will be encoded using IDNA, which means it's unsuitable for querying SRV records compatible with the DNS-SD specification.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QString 	name() const</para>
            <para> void 	setName(const QString &amp; name)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	nameChanged(const QString &amp; name)</para>
            <para></para>
            </summary>
        </member>
        <member name="E:QtNetwork.QDnsLookup.TypeChanged">
            <summary>
            <para>This property holds the type of DNS lookup.</para>
            <para>Access functions:</para>
            <para></para>
            <para> Type 	type() const</para>
            <para> void 	setType(QDnsLookup::Type)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	typeChanged(Type type)</para>
            <para></para>
            </summary>
        </member>
        <member name="E:QtNetwork.QDnsLookup.NameserverChanged">
            <summary>
            <para>This property holds the nameserver to use for DNS lookup.</para>
            <para>Access functions:</para>
            <para></para>
            <para> QHostAddress 	nameserver() const</para>
            <para> void 	setNameserver(const QHostAddress &amp; nameserver)</para>
            <para></para>
            <para>Notifier signal:</para>
            <para></para>
            <para> void 	nameserverChanged(const QHostAddress &amp; nameserver)</para>
            <para></para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsLookup.Name">
            <summary>
            <para>This property holds the name to lookup.</para>
            <para>Note: The name will be encoded using IDNA, which means it's unsuitable for querying SRV records compatible with the DNS-SD specification.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsLookup.type">
            <summary>
            <para>This property holds the type of DNS lookup.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsLookup.Nameserver">
            <summary>
            <para>This property holds the nameserver to use for DNS lookup.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsLookup.error">
            <summary>
            <para>This property holds the type of error that occurred if the DNS lookup failed, or NoError.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsLookup.ErrorString">
            <summary>
            <para>This property holds a human-readable description of the error if the DNS lookup failed.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QDnsLookup.IsFinished">
            <summary>
            <para>Returns whether the reply has finished or was aborted.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QDnsLookup.Error">
            <summary>
            <para>Indicates all possible error conditions found during the processing of the DNS lookup.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.NoError">
            <summary>no error condition.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.ResolverError">
            <summary>there was an error initializing the system's DNS resolver.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.OperationCancelledError">
            <summary>the lookup was aborted using the abort() method.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.InvalidRequestError">
            <summary>the requested DNS lookup was invalid.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.InvalidReplyError">
            <summary>the reply returned by the server was invalid.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.ServerFailureError">
            <summary>the server encountered an internal failure while processing the request (SERVFAIL).</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.ServerRefusedError">
            <summary>the server refused to process the request for security or policy reasons (REFUSED).</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Error.NotFoundError">
            <summary>the requested domain name does not exist (NXDOMAIN).</summary>
        </member>
        <member name="T:QtNetwork.QDnsLookup.Type">
            <summary>
            <para>Indicates the type of DNS lookup that was performed.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.A">
            <summary>IPv4 address records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.AAAA">
            <summary>IPv6 address records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.ANY">
            <summary>any records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.CNAME">
            <summary>canonical name records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.MX">
            <summary>mail exchange records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.NS">
            <summary>name server records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.PTR">
            <summary>pointer records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.SRV">
            <summary>service records.</summary>
        </member>
        <member name="F:QtNetwork.QDnsLookup.Type.TXT">
            <summary>text records.</summary>
        </member>
        <member name="T:QtNetwork.QHostInfo">
            <summary>
            <para>The QHostInfo class provides static functions for host name lookups.</para>
            </summary>
            <remarks>
            <para>QHostInfo uses the lookup mechanisms provided by the operating system to find the IP address(es) associated with a host name, or the host name associated with an IP address. The class provides two static convenience functions: one that works asynchronously and emits a signal once the host is found, and one that blocks and returns a QHostInfo object.</para>
            <para>To look up a host's IP addresses asynchronously, call lookupHost(), which takes the host name or IP address, a receiver object, and a slot signature as arguments and returns an ID. You can abort the lookup by calling abortHostLookup() with the lookup ID.</para>
            <para>Example:</para>
            <para>// To find the IP address of qt-project.org</para>
            <para>QHostInfo::lookupHost(&quot;qt-project.org&quot;,</para>
            <para>                      this, SLOT(printResults(QHostInfo)));</para>
            <para></para>
            <para>// To find the host name for 4.2.2.1</para>
            <para>QHostInfo::lookupHost(&quot;4.2.2.1&quot;,</para>
            <para>                      this, SLOT(printResults(QHostInfo)));</para>
            <para>The slot is invoked when the results are ready. The results are stored in a QHostInfo object. Call addresses() to get the list of IP addresses for the host, and hostName() to get the host name that was looked up.</para>
            <para>If the lookup failed, error() returns the type of error that occurred. errorString() gives a human-readable description of the lookup error.</para>
            <para>If you want a blocking lookup, use the QHostInfo::fromName() function:</para>
            <para>QHostInfo info = QHostInfo::fromName(&quot;qt-project.org&quot;);</para>
            <para>QHostInfo supports Internationalized Domain Names (IDNs) through the IDNA and Punycode standards.</para>
            <para>To retrieve the name of the local host, use the static QHostInfo::localHostName() function.</para>
            <para>Note: Since Qt 4.6.1 QHostInfo is using multiple threads for DNS lookup instead of one dedicated DNS thread. This improves performance, but also changes the order of signal emissions when using lookupHost() compared to previous versions of Qt.</para>
            <para>Note: Since Qt 4.6.3 QHostInfo is using a small internal 60 second DNS cache for performance improvements.</para>
            <para></para>
            <para>See also QAbstractSocket and RFC 3492.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QHostInfo.#ctor(System.Int32)">
            <summary>
            <para>Constructs an empty host info object with lookup ID id.</para>
            <para>See also lookupId().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.#ctor(QtNetwork.QHostInfo)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.LookupHost(System.String,QtCore.QObject,System.String)">
            <summary>
            <para>Looks up the IP address(es) associated with host name name, and returns an ID for the lookup. When the result of the lookup is ready, the slot or signal member in receiver is called with a QHostInfo argument. The QHostInfo object can then be inspected to get the results of the lookup.</para>
            <para>The lookup is performed by a single function call, for example:</para>
            <para>QHostInfo::lookupHost(&quot;www.kde.org&quot;,</para>
            <para>                      this, SLOT(lookedUp(QHostInfo)));</para>
            <para>The implementation of the slot prints basic information about the addresses returned by the lookup, or reports an error if it failed:</para>
            <para>void MyWidget::lookedUp(const QHostInfo &amp;host)</para>
            <para>{</para>
            <para>    if (host.error() != QHostInfo::NoError) {</para>
            <para>        qDebug() &lt;&lt; &quot;Lookup failed:&quot; &lt;&lt; host.errorString();</para>
            <para>        return;</para>
            <para>    }</para>
            <para></para>
            <para>    foreach (const QHostAddress &amp;address, host.addresses())</para>
            <para>        qDebug() &lt;&lt; &quot;Found address:&quot; &lt;&lt; address.toString();</para>
            <para>}</para>
            <para>If you pass a literal IP address to name instead of a host name, QHostInfo will search for the domain name for the IP (i.e., QHostInfo will perform a reverse lookup). On success, the resulting QHostInfo will contain both the resolved domain name and IP addresses for the host name. Example:</para>
            <para>QHostInfo::lookupHost(&quot;4.2.2.1&quot;,</para>
            <para>                      this, SLOT(lookedUp(QHostInfo)));</para>
            <para>Note: There is no guarantee on the order the signals will be emitted if you start multiple requests with lookupHost().</para>
            <para>See also abortHostLookup(), addresses(), error(), and fromName().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.AbortHostLookup(System.Int32)">
            <summary>
            <para>Aborts the host lookup with the ID id, as returned by lookupHost().</para>
            <para>See also lookupHost() and lookupId().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QHostInfo.FromName(System.String)">
            <summary>
            <para>Looks up the IP address(es) for the given host name. The function blocks during the lookup which means that execution of the program is suspended until the results of the lookup are ready. Returns the result of the lookup in a QHostInfo object.</para>
            <para>If you pass a literal IP address to name instead of a host name, QHostInfo will search for the domain name for the IP (i.e., QHostInfo will perform a reverse lookup). On success, the returned QHostInfo will contain both the resolved domain name and IP addresses for the host name.</para>
            <para>See also lookupHost().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.HostName">
            <summary>
            <para>Returns the name of the host whose IP addresses were looked up.</para>
            <para>See also setHostName() and localHostName().</para>
            <para></para>
            <para>Sets the host name of this QHostInfo to hostName.</para>
            <para>See also hostName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.Error">
            <summary>
            <para>Returns the type of error that occurred if the host name lookup failed; otherwise returns NoError.</para>
            <para>See also setError() and errorString().</para>
            <para></para>
            <para>Sets the error type of this QHostInfo to error.</para>
            <para>See also error() and errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.ErrorString">
            <summary>
            <para>If the lookup failed, this function returns a human readable description of the error; otherwise &quot;Unknown error&quot; is returned.</para>
            <para>See also setErrorString() and error().</para>
            <para></para>
            <para>Sets the human readable description of the error that occurred to str if the lookup failed.</para>
            <para>See also errorString() and setError().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.LookupId">
            <summary>
            <para>Returns the ID of this lookup.</para>
            <para>See also setLookupId(), abortHostLookup(), and hostName().</para>
            <para></para>
            <para>Sets the ID of this lookup to id.</para>
            <para>See also lookupId() and lookupHost().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.LocalHostName">
            <summary>
            <para>Returns the host name of this machine.</para>
            <para>See also hostName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QHostInfo.LocalDomainName">
            <summary>
            <para>Returns the DNS domain of this machine.</para>
            <para>Note: DNS domains are not related to domain names found in Windows networks.</para>
            <para>See also hostName().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QHostInfo.HostInfoError">
            <summary>
            <para>This enum describes the various errors that can occur when trying to resolve a host name.</para>
            <para>See also error() and setError().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QHostInfo.HostInfoError.NoError">
            <summary>The lookup was successful.</summary>
        </member>
        <member name="F:QtNetwork.QHostInfo.HostInfoError.HostNotFound">
            <summary>No IP addresses were found for the host.</summary>
        </member>
        <member name="F:QtNetwork.QHostInfo.HostInfoError.UnknownError">
            <summary>An unknown error occurred.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxyQuery">
            <summary>
            <para>The QNetworkProxyQuery class is used to query the proxy settings for a socket.</para>
            </summary>
            <remarks>
            <para>QNetworkProxyQuery holds the details of a socket being created or request being made. It is used by QNetworkProxy and QNetworkProxyFactory to allow applications to have a more fine-grained control over which proxy servers are used, depending on the details of the query. This allows an application to apply different settings, according to the protocol or destination hostname, for instance.</para>
            <para>QNetworkProxyQuery supports the following criteria for selecting the proxy:</para>
            <para></para>
            <para>the type of query</para>
            <para>the local port number to use</para>
            <para>the destination host name</para>
            <para>the destination port number</para>
            <para>the protocol name, such as &quot;http&quot; or &quot;ftp&quot;</para>
            <para>the URL being requested</para>
            <para></para>
            <para>The destination host name is the host in the connection in the case of outgoing connection sockets. It is the hostName parameter passed to QTcpSocket::connectToHost() or the host component of a URL requested with QNetworkRequest.</para>
            <para>The destination port number is the requested port to connect to in the case of outgoing sockets, while the local port number is the port the socket wishes to use locally before attempting the external connection. In most cases, the local port number is used by listening sockets only (QTcpSocket) or by datagram sockets (QUdpSocket).</para>
            <para>The protocol name is an arbitrary string that indicates the type of connection being attempted. For example, it can match the scheme of a URL, like &quot;http&quot;, &quot;https&quot; and &quot;ftp&quot;. In most cases, the proxy selection will not change depending on the protocol, but this information is provided in case a better choice can be made, like choosing an caching HTTP proxy for HTTP-based connections, but a more powerful SOCKSv5 proxy for all others.</para>
            <para>The network configuration specifies which configuration to use, when bearer management is used. For example on a mobile phone the proxy settings are likely to be different for the cellular network vs WLAN.</para>
            <para>Some of the criteria may not make sense in all of the types of query. The following table lists the criteria that are most commonly used, according to the type of query.</para>
            <para></para>
            <para>Query typeDescription</para>
            <para>TcpSocket	Normal sockets requesting a connection to a remote server, like QTcpSocket. The peer hostname and peer port match the values passed to QTcpSocket::connectToHost(). The local port is usually -1, indicating the socket has no preference in which port should be used. The URL component is not used.</para>
            <para>UdpSocket	Datagram-based sockets, which can both send and receive. The local port, remote host or remote port fields can all be used or be left unused, depending on the characteristics of the socket. The URL component is not used.</para>
            <para>TcpServer	Passive server sockets that listen on a port and await incoming connections from the network. Normally, only the local port is used, but the remote address could be used in specific circumstances, for example to indicate which remote host a connection is expected from. The URL component is not used.</para>
            <para>UrlRequest	A more high-level request, such as those coming from QNetworkAccessManager. These requests will inevitably use an outgoing TCP socket, but the this query type is provided to indicate that more detailed information is present in the URL component. For ease of implementation, the URL's host and port are set as the destination address.</para>
            <para></para>
            <para>It should be noted that any of the criteria may be missing or unknown (an empty QString for the hostname or protocol name, -1 for the port numbers). If that happens, the functions executing the query should make their best guess or apply some implementation-defined default values.</para>
            <para></para>
            <para>See also QNetworkProxy, QNetworkProxyFactory, QNetworkAccessManager, and QAbstractSocket::setProxy().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor">
            <summary>
            <para>Constructs a default QNetworkProxyQuery object. By default, the query type will be QNetworkProxyQuery::TcpSocket.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtCore.QUrl,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
            <para>Constructs a QNetworkProxyQuery with the URL requestUrl and sets the query type to queryType.</para>
            <para>See also protocolTag(), peerHostName(), and peerPort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(System.String,System.Int32,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
            <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries, because it sets the peer hostname to hostname and the peer's port number to port.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(System.UInt16,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
            <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries because it sets the local port number to bindPort.</para>
            <para>Note that bindPort is of type quint16 to indicate the exact port number that is requested. The value of -1 (unknown) is not allowed in this context.</para>
            <para>See also localPort().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkProxyQuery)">
            <summary>
            <para>Constructs a QNetworkProxyQuery object that is a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkConfiguration,QtCore.QUrl,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
            <para>Constructs a QNetworkProxyQuery with the URL requestUrl and sets the query type to queryType. The specified networkConfiguration is used to resolve the proxy settings.</para>
            <para>See also protocolTag(), peerHostName(), peerPort(), and networkConfiguration().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkConfiguration,System.String,System.Int32,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
            <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries, because it sets the peer hostname to hostname and the peer's port number to port. The specified networkConfiguration is used to resolve the proxy settings.</para>
            <para>See also networkConfiguration().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.#ctor(QtNetwork.QNetworkConfiguration,System.UInt16,System.String,QtNetwork.QNetworkProxyQuery.QueryType)">
            <summary>
            <para>Constructs a QNetworkProxyQuery of type queryType and sets the protocol tag to be protocolTag. This constructor is suitable for QNetworkProxyQuery::TcpSocket queries because it sets the local port number to bindPort. The specified networkConfiguration is used to resolve the proxy settings.</para>
            <para>Note that bindPort is of type quint16 to indicate the exact port number that is requested. The value of -1 (unknown) is not allowed in this context.</para>
            <para>See also localPort() and networkConfiguration().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.Swap(QtNetwork.QNetworkProxyQuery)">
            <summary>
            <para>Swaps this network proxy query instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.op_Equality(QtNetwork.QNetworkProxyQuery,QtNetwork.QNetworkProxyQuery)">
            <summary>
            <para>Returns true if this QNetworkProxyQuery object contains the same data as other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyQuery.op_Inequality(QtNetwork.QNetworkProxyQuery,QtNetwork.QNetworkProxyQuery)">
            <summary>
            <para>Returns true if this QNetworkProxyQuery object does not contain the same data as other.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.queryType">
            <summary>
            <para>Returns the query type.</para>
            <para>See also setQueryType().</para>
            <para></para>
            <para>Sets the query type of this object to be type.</para>
            <para>See also queryType().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.PeerPort">
            <summary>
            <para>Returns the port number for the outgoing request or -1 if the port number is not known.</para>
            <para>If the query type is QNetworkProxyQuery::UrlRequest, this function returns the port number of the URL being requested. In general, frameworks will fill in the port number from their default values.</para>
            <para>See also peerHostName(), localPort(), and setPeerPort().</para>
            <para></para>
            <para>Sets the requested port number for the outgoing connection to be port. Valid values are 1 to 65535, or -1 to indicate that the remote port number is unknown.</para>
            <para>The peer port number can also be used to indicate the expected port number of an incoming connection in the case of QNetworkProxyQuery::UdpSocket or QNetworkProxyQuery::TcpServer query types.</para>
            <para>See also peerPort(), setPeerHostName(), and setLocalPort().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.PeerHostName">
            <summary>
            <para>Returns the host name or IP address being of the outgoing connection being requested, or an empty string if the remote hostname is not known.</para>
            <para>If the query type is QNetworkProxyQuery::UrlRequest, this function returns the host component of the URL being requested.</para>
            <para>See also peerPort(), localPort(), and setPeerHostName().</para>
            <para></para>
            <para>Sets the hostname of the outgoing connection being requested to hostname. An empty hostname can be used to indicate that the remote host is unknown.</para>
            <para>The peer host name can also be used to indicate the expected source address of an incoming connection in the case of QNetworkProxyQuery::UdpSocket or QNetworkProxyQuery::TcpServer query types.</para>
            <para>See also peerHostName(), setPeerPort(), and setLocalPort().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.LocalPort">
            <summary>
            <para>Returns the port number of the socket that will accept incoming packets from remote servers or -1 if the port is not known.</para>
            <para>See also peerPort(), peerHostName(), and setLocalPort().</para>
            <para></para>
            <para>Sets the port number that the socket wishes to use locally to accept incoming packets from remote servers to port. The local port is most often used with the QNetworkProxyQuery::TcpServer and QNetworkProxyQuery::UdpSocket query types.</para>
            <para>Valid values are 0 to 65535 (with 0 indicating that any port number will be acceptable) or -1, which means the local port number is unknown or not applicable.</para>
            <para>In some circumstances, for special protocols, it's the local port number can also be used with a query of type QNetworkProxyQuery::TcpSocket. When that happens, the socket is indicating it wishes to use the port number port when connecting to a remote host.</para>
            <para>See also localPort(), setPeerPort(), and setPeerHostName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.ProtocolTag">
            <summary>
            <para>Returns the protocol tag for this QNetworkProxyQuery object, or an empty QString in case the protocol tag is unknown.</para>
            <para>In the case of queries of type QNetworkProxyQuery::UrlRequest, this function returns the value of the scheme component of the URL.</para>
            <para>See also setProtocolTag() and url().</para>
            <para></para>
            <para>Sets the protocol tag for this QNetworkProxyQuery object to be protocolTag.</para>
            <para>The protocol tag is an arbitrary string that indicates which protocol is being talked over the socket, such as &quot;http&quot;, &quot;xmpp&quot;, &quot;telnet&quot;, etc. The protocol tag is used by the backend to return a request that is more specific to the protocol in question: for example, a HTTP connection could be use a caching HTTP proxy server, while all other connections use a more powerful SOCKSv5 proxy server.</para>
            <para>See also protocolTag().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.Url">
            <summary>
            <para>Returns the URL component of this QNetworkProxyQuery object in case of a query of type QNetworkProxyQuery::UrlRequest.</para>
            <para>See also setUrl().</para>
            <para></para>
            <para>Sets the URL component of this QNetworkProxyQuery object to be url. Setting the URL will also set the protocol tag, the remote host name and port number. This is done so as to facilitate the implementation of the code that determines the proxy server to be used.</para>
            <para>See also url(), peerHostName(), and peerPort().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxyQuery.NetworkConfiguration">
            <summary>
            <para>Returns the network configuration component of the query.</para>
            <para>See also setNetworkConfiguration().</para>
            <para></para>
            <para>Sets the network configuration component of this QNetworkProxyQuery object to be networkConfiguration. The network configuration can be used to return different proxy settings based on the network in use, for example WLAN vs cellular networks on a mobile phone.</para>
            <para>In the case of &quot;user choice&quot; or &quot;service network&quot; configurations, you should first start the QNetworkSession and obtain the active configuration from its properties.</para>
            <para>See also networkConfiguration().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxyQuery.QueryType">
            <summary>
            <para>Describes the type of one QNetworkProxyQuery query.</para>
            <para>See also queryType() and setQueryType().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.TcpSocket">
            <summary>a normal, outgoing TCP socket</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.UdpSocket">
            <summary>a datagram-based UDP socket, which could send to multiple destinations</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.TcpServer">
            <summary>a TCP server that listens for incoming connections from the network</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxyQuery.QueryType.UrlRequest">
            <summary>a more complex request which involves loading of a URL</summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxy">
            <summary>
            <para>The QNetworkProxy class provides a network layer proxy.</para>
            </summary>
            <remarks>
            <para>QNetworkProxy provides the method for configuring network layer proxy support to the Qt network classes. The currently supported classes are QAbstractSocket, QTcpSocket, QUdpSocket, QTcpServer and QNetworkAccessManager. The proxy support is designed to be as transparent as possible. This means that existing network-enabled applications that you have written should automatically support network proxy using the following code.</para>
            <para>QNetworkProxy proxy;</para>
            <para>proxy.setType(QNetworkProxy::Socks5Proxy);</para>
            <para>proxy.setHostName(&quot;proxy.example.com&quot;);</para>
            <para>proxy.setPort(1080);</para>
            <para>proxy.setUser(&quot;username&quot;);</para>
            <para>proxy.setPassword(&quot;password&quot;);</para>
            <para>QNetworkProxy::setApplicationProxy(proxy);</para>
            <para>An alternative to setting an application wide proxy is to specify the proxy for individual sockets using QAbstractSocket::setProxy() and QTcpServer::setProxy(). In this way, it is possible to disable the use of a proxy for specific sockets using the following code:</para>
            <para>serverSocket-&gt;setProxy(QNetworkProxy::NoProxy);</para>
            <para>Network proxy is not used if the address used in connectToHost(), bind() or listen() is equivalent to QHostAddress::LocalHost or QHostAddress::LocalHostIPv6.</para>
            <para>Each type of proxy support has certain restrictions associated with it. You should read the ProxyType documentation carefully before selecting a proxy type to use.</para>
            <para>Note: Changes made to currently connected sockets do not take effect. If you need to change a connected socket, you should reconnect it.</para>
            <para></para>
            <para>SOCKS5</para>
            <para>The SOCKS5 support in Qt 4 is based on RFC 1928 and RFC 1929. The supported authentication methods are no authentication and username/password authentication. Both IPv4 and IPv6 are supported. Domain names are resolved through the SOCKS5 server if the QNetworkProxy::HostNameLookupCapability is enabled, otherwise they are resolved locally and the IP address is sent to the server. There are several things to remember when using SOCKS5 with QUdpSocket and QTcpServer:</para>
            <para>With QUdpSocket, a call to bind() may fail with a timeout error. If a port number other than 0 is passed to bind(), it is not guaranteed that it is the specified port that will be used. Use localPort() and localAddress() to get the actual address and port number in use. Because proxied UDP goes through two UDP connections, it is more likely that packets will be dropped.</para>
            <para>With QTcpServer a call to listen() may fail with a timeout error. If a port number other than 0 is passed to listen(), then it is not guaranteed that it is the specified port that will be used. Use serverPort() and serverAddress() to get the actual address and port used to listen for connections. SOCKS5 only supports one accepted connection per call to listen(), and each call is likely to result in a different serverPort() being used.</para>
            <para></para>
            <para>See also QAbstractSocket and QTcpServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.#ctor">
            <summary>
            <para>Constructs a QNetworkProxy with DefaultProxy type; the proxy type is determined by applicationProxy(), which defaults to NoProxy.</para>
            <para>See also setType() and setApplicationProxy().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.#ctor(QtNetwork.QNetworkProxy.ProxyType,System.String,System.UInt16,System.String,System.String)">
            <summary>
            <para>Constructs a QNetworkProxy with type, hostName, port, user and password.</para>
            <para>The default capabilities for proxy type type are set automatically.</para>
            <para>See also capabilities().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.#ctor(QtNetwork.QNetworkProxy)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.Swap(QtNetwork.QNetworkProxy)">
            <summary>
            <para>Swaps this network proxy instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.op_Equality(QtNetwork.QNetworkProxy,QtNetwork.QNetworkProxy)">
            <summary>
            <para>Compares the value of this network proxy to other and returns true if they are equal (same proxy type, server as well as username and password)</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.op_Inequality(QtNetwork.QNetworkProxy,QtNetwork.QNetworkProxy)">
            <summary>
            <para>Compares the value of this network proxy to other and returns true if they differ.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.Header(QtNetwork.QNetworkRequest.KnownHeaders)">
            <summary>
            <para>Returns the value of the known network header header if it is in use for this proxy. If it is not present, returns QVariant() (i.e., an invalid variant).</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also QNetworkRequest::KnownHeaders, rawHeader(), and setHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.SetHeader(QtNetwork.QNetworkRequest.KnownHeaders,QtCore.QVariant)">
            <summary>
            <para>Sets the value of the known header header to be value, overriding any previously set headers. This operation also sets the equivalent raw HTTP header.</para>
            <para>If the proxy is not of type HttpProxy or HttpCachingProxy this has no effect.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also QNetworkRequest::KnownHeaders, setRawHeader(), and header().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.HasRawHeader(QtCore.QByteArray)">
            <summary>
            <para>Returns true if the raw header headerName is in use for this proxy. Returns false if the proxy is not of type HttpProxy or HttpCachingProxy.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also rawHeader() and setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.RawHeader(QtCore.QByteArray)">
            <summary>
            <para>Returns the raw form of header headerName. If no such header is present or the proxy is not of type HttpProxy or HttpCachingProxy, an empty QByteArray is returned, which may be indistinguishable from a header that is present but has no content (use hasRawHeader() to find out if the header exists or not).</para>
            <para>Raw headers can be set with setRawHeader() or with setHeader().</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also header() and setRawHeader().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxy.SetRawHeader(QtCore.QByteArray,QtCore.QByteArray)">
            <summary>
            <para>Sets the header headerName to be of value headerValue. If headerName corresponds to a known header (see QNetworkRequest::KnownHeaders), the raw format will be parsed and the corresponding &quot;cooked&quot; header will be set as well.</para>
            <para>For example:</para>
            <para>request.setRawHeader(QByteArray(&quot;Last-Modified&quot;), QByteArray(&quot;Sun, 06 Nov 1994 08:49:37 GMT&quot;));</para>
            <para>will also set the known header LastModifiedHeader to be the QDateTime object of the parsed date.</para>
            <para>Note: Setting the same header twice overrides the previous setting. To accomplish the behaviour of multiple HTTP headers of the same name, you should concatenate the two values, separating them with a comma (&quot;,&quot;) and set one single raw header.</para>
            <para>If the proxy is not of type HttpProxy or HttpCachingProxy this has no effect.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also QNetworkRequest::KnownHeaders, setHeader(), hasRawHeader(), and rawHeader().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Type">
            <summary>
            <para>Returns the proxy type for this instance.</para>
            <para>See also setType().</para>
            <para></para>
            <para>Sets the proxy type for this instance to be type.</para>
            <para>Note that changing the type of a proxy does not change the set of capabilities this QNetworkProxy object holds if any capabilities have been set with setCapabilities().</para>
            <para>See also type() and setCapabilities().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Capabilities">
            <summary>
            <para>Returns the capabilities of this proxy server.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also setCapabilities() and type().</para>
            <para></para>
            <para>Sets the capabilities of this proxy to capabilities.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also setType() and capabilities().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.User">
            <summary>
            <para>Returns the user name used for authentication.</para>
            <para>See also setUser(), setPassword(), and password().</para>
            <para></para>
            <para>Sets the user name for proxy authentication to be user.</para>
            <para>See also user(), setPassword(), and password().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Password">
            <summary>
            <para>Returns the password used for authentication.</para>
            <para>See also user(), setPassword(), and setUser().</para>
            <para></para>
            <para>Sets the password for proxy authentication to be password.</para>
            <para>See also user(), setUser(), and password().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.HostName">
            <summary>
            <para>Returns the host name of the proxy host.</para>
            <para>See also setHostName(), setPort(), and port().</para>
            <para></para>
            <para>Sets the host name of the proxy host to be hostName.</para>
            <para>See also hostName(), setPort(), and port().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.Port">
            <summary>
            <para>Returns the port of the proxy host.</para>
            <para>See also setHostName(), setPort(), and hostName().</para>
            <para></para>
            <para>Sets the port of the proxy host to be port.</para>
            <para>See also hostName(), setHostName(), and port().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.ApplicationProxy">
            <summary>
            <para>Returns the application level network proxying.</para>
            <para>If a QAbstractSocket or QTcpSocket has the QNetworkProxy::DefaultProxy type, then the QNetworkProxy returned by this function is used.</para>
            <para>See also QNetworkProxyFactory, setApplicationProxy(), QAbstractSocket::proxy(), and QTcpServer::proxy().</para>
            <para></para>
            <para>Sets the application level network proxying to be networkProxy.</para>
            <para>If a QAbstractSocket or QTcpSocket has the QNetworkProxy::DefaultProxy type, then the QNetworkProxy set with this function is used. If you want more flexibility in determining which proxy is used, use the QNetworkProxyFactory class.</para>
            <para>Setting a default proxy value with this function will override the application proxy factory set with QNetworkProxyFactory::setApplicationProxyFactory.</para>
            <para>See also QNetworkProxyFactory, applicationProxy(), QAbstractSocket::setProxy(), and QTcpServer::setProxy().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.IsCachingProxy">
            <summary>
            <para>Returns true if this proxy supports the QNetworkProxy::CachingCapability capability.</para>
            <para>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling setCapabilities().</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also capabilities(), type(), and isTransparentProxy().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QNetworkProxy.IsTransparentProxy">
            <summary>
            <para>Returns true if this proxy supports transparent tunneling of TCP connections. This matches the QNetworkProxy::TunnelingCapability capability.</para>
            <para>In Qt 4.4, the capability was tied to the proxy type, but since Qt 4.5 it is possible to remove the capability of caching from a proxy by calling setCapabilities().</para>
            <para>This function was introduced in  Qt 4.4.</para>
            <para>See also capabilities(), type(), and isCachingProxy().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxy.ProxyType">
            <summary>
            <para>This enum describes the types of network proxying provided in Qt.</para>
            <para>There are two types of proxies that Qt understands: transparent proxies and caching proxies. The first group consists of proxies that can handle any arbitrary data transfer, while the second can only handle specific requests. The caching proxies only make sense for the specific classes where they can be used.</para>
            <para>The table below lists different proxy types and their capabilities. Since each proxy type has different capabilities, it is important to understand them before choosing a proxy type.</para>
            <para></para>
            <para> Proxy typeDescriptionDefault capabilities</para>
            <para>SOCKS 5	Generic proxy for any kind of connection. Supports TCP, UDP, binding to a port (incoming connections) and authentication.	TunnelingCapability, ListeningCapability, UdpTunnelingCapability, HostNameLookupCapability</para>
            <para>HTTP	Implemented using the &quot;CONNECT&quot; command, supports only outgoing TCP connections; supports authentication.	TunnelingCapability, CachingCapability, HostNameLookupCapability</para>
            <para>Caching-only HTTP	Implemented using normal HTTP commands, it is useful only in the context of HTTP requests (see QNetworkAccessManager)	CachingCapability, HostNameLookupCapability</para>
            <para>Caching FTP	Implemented using an FTP proxy, it is useful only in the context of FTP requests (see QNetworkAccessManager)	CachingCapability, HostNameLookupCapability</para>
            <para></para>
            <para>Also note that you shouldn't set the application default proxy (setApplicationProxy()) to a proxy that doesn't have the TunnelingCapability capability. If you do, QTcpSocket will not know how to open connections.</para>
            <para>See also setType(), type(), capabilities(), and setCapabilities().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.DefaultProxy">
            <summary>Proxy is determined based on the application proxy set using setApplicationProxy()</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.Socks5Proxy">
            <summary>Socks5 proxying is used</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.NoProxy">
            <summary>No proxying is used</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.HttpProxy">
            <summary>HTTP transparent proxying is used</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.HttpCachingProxy">
            <summary>Proxying for HTTP requests only</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.ProxyType.FtpCachingProxy">
            <summary>Proxying for FTP requests only</summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxy.Capability">
            <summary>
            <para>These flags indicate the capabilities that a given proxy server supports.</para>
            <para>QNetworkProxy sets different capabilities by default when the object is created (see QNetworkProxy::ProxyType for a list of the defaults). However, it is possible to change the capabitilies after the object has been created with setCapabilities().</para>
            <para>The capabilities that QNetworkProxy supports are:</para>
            <para>This enum was introduced or modified in  Qt 4.5.</para>
            <para>The Capabilities type is a typedef for QFlags&lt;Capability&gt;. It stores an OR combination of Capability values.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.TunnelingCapability">
            <summary>Ability to open transparent, tunneled TCP connections to a remote host. The proxy server relays the transmission verbatim from one side to the other and does no caching.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.ListeningCapability">
            <summary>Ability to create a listening socket and wait for an incoming TCP connection from a remote host.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.UdpTunnelingCapability">
            <summary>Ability to relay UDP datagrams via the proxy server to and from a remote host.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.CachingCapability">
            <summary>Ability to cache the contents of the transfer. This capability is specific to each protocol and proxy type. For example, HTTP proxies can cache the contents of web data transferred with "GET" commands.</summary>
        </member>
        <member name="F:QtNetwork.QNetworkProxy.Capability.HostNameLookupCapability">
            <summary>Ability to connect to perform the lookup on a remote host name and connect to it, as opposed to requiring the application to perform the name lookup and request connection to IP addresses only.</summary>
        </member>
        <member name="T:QtNetwork.QNetworkProxyFactory">
            <summary>
            <para>The QNetworkProxyFactory class provides fine-grained proxy selection.</para>
            </summary>
            <remarks>
            <para>QNetworkProxyFactory is an extension to QNetworkProxy, allowing applications to have a more fine-grained control over which proxy servers are used, depending on the socket requesting the proxy. This allows an application to apply different settings, according to the protocol or destination hostname, for instance.</para>
            <para>QNetworkProxyFactory can be set globally for an application, in which case it will override any global proxies set with QNetworkProxy::setApplicationProxy(). If set globally, any sockets created with Qt will query the factory to determine the proxy to be used.</para>
            <para>A factory can also be set in certain frameworks that support multiple connections, such as QNetworkAccessManager. When set on such object, the factory will be queried for sockets created by that framework only.</para>
            <para></para>
            <para>System Proxies</para>
            <para>You can configure a factory to use the system proxy's settings. Call the setUseSystemConfiguration() function with true to enable this behavior, or false to disable it.</para>
            <para>Similarly, you can use a factory to make queries directly to the system proxy by calling its systemProxyForQuery() function.</para>
            <para>Warning: Depending on the configuration of the user's system, the use of system proxy features on certain platforms may be subject to limitations. The systemProxyForQuery() documentation contains a list of these limitations for those platforms that are affected.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.#ctor">
            <summary>
            <para>Creates a QNetworkProxyFactory object.</para>
            <para>Since QNetworkProxyFactory is an abstract class, you cannot create objects of type QNetworkProxyFactory directly.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.SetUseSystemConfiguration(System.Boolean)">
            <summary>
            <para>Enables the use of the platform-specific proxy settings, and only those. See systemProxyForQuery() for more information.</para>
            <para>Internally, this method (when called with enable set to true) sets an application-wide proxy factory. For this reason, this method is mutually exclusive with setApplicationProxyFactory(): calling setApplicationProxyFactory() overrides the use of the system-wide proxy, and calling setUseSystemConfiguration() overrides any application proxy or proxy factory that was previously set.</para>
            <para>Note: See the systemProxyForQuery() documentation for a list of limitations related to the use of system proxies.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QNetworkProxyFactory.SetApplicationProxyFactory(QtNetwork.QNetworkProxyFactory)">
            <summary>
            <para>Sets the application-wide proxy factory to be factory. This function will take ownership of that object and will delete it when necessary.</para>
            <para>The application-wide proxy is used as a last-resort when all other proxy selection requests returned QNetworkProxy::DefaultProxy. For example, QTcpSocket objects can have a proxy set with QTcpSocket::setProxy, but if none is set, the proxy factory class set with this function will be queried.</para>
            <para>If you set a proxy factory with this function, any application level proxies set with QNetworkProxy::setApplicationProxy will be overridden.</para>
            <para>See also QNetworkProxy::setApplicationProxy(), QAbstractSocket::proxy(), and QAbstractSocket::setProxy().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QLocalServer">
            <summary>
            <para>The QLocalServer class provides a local socket based server.</para>
            </summary>
            <remarks>
            <para>This class makes it possible to accept incoming local socket connections.</para>
            <para>Call listen() to have the server start listening for incoming connections on a specified key. The newConnection() signal is then emitted each time a client connects to the server.</para>
            <para>Call nextPendingConnection() to accept the pending connection as a connected QLocalSocket. The function returns a pointer to a QLocalSocket that can be used for communicating with the client.</para>
            <para>If an error occurs, serverError() returns the type of error, and errorString() can be called to get a human readable description of what happened.</para>
            <para>When listening for connections, the name which the server is listening on is available through serverName().</para>
            <para>Calling close() makes QLocalServer stop listening for incoming connections.</para>
            <para>Although QLocalServer is designed for use with an event loop, it's possible to use it without one. In that case, you must use waitForNewConnection(), which blocks until either a connection is available or a timeout expires.</para>
            <para></para>
            <para>See also QLocalSocket and QTcpServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QLocalServer.#ctor(QtCore.QObject)">
            <summary>
            <para>Create a new local socket server with the given parent.</para>
            <para>See also listen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.Close">
            <summary>
            <para>Stop listening for incoming connections. Existing connections are not effected, but any new connections will be refused.</para>
            <para>See also isListening() and listen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.Listen(System.String)">
            <summary>
            <para>Tells the server to listen for incoming connections on name. If the server is currently listening then it will return false. Return true on success otherwise false.</para>
            <para>name can be a single name and QLocalServer will determine the correct platform specific path. serverName() will return the name that is passed into listen.</para>
            <para>Usually you would just pass in a name like &quot;foo&quot;, but on Unix this could also be a path such as &quot;/tmp/foo&quot; and on Windows this could be a pipe path such as &quot;\\.\pipe\foo&quot;</para>
            <para>Note: On Unix if the server crashes without closing listen will fail with AddressInUseError. To create a new server the file should be removed. On Windows two local servers can listen to the same pipe at the same time, but any connections will go to one of the server.</para>
            <para>See also serverName(), isListening(), and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.Listen(System.Int32)">
            <summary>
            <para>Instructs the server to listen for incoming connections on socketDescriptor. The property returns false if the server is currently listening. It returns true on success; otherwise, it returns false. The socket must be ready to accept new connections with no extra platform-specific functions called. The socket is set into non-blocking mode.</para>
            <para>serverName(), fullServerName() may return a string with a name if this option is supported by the platform; otherwise, they return an empty QString.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also isListening() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.WaitForNewConnection(System.Int32,System.Boolean@)">
            <summary>
            <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
            <para>This is a blocking function call. Its use is ill-advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
            <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
            <para>If msec is -1, this function will not time out.</para>
            <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.IncomingConnection(System.UInt32)">
            <summary>
            <para>This virtual function is called by QLocalServer when a new connection is available. socketDescriptor is the native socket descriptor for the accepted connection.</para>
            <para>The base implementation creates a QLocalSocket, sets the socket descriptor and then stores the QLocalSocket in an internal list of pending connections. Finally newConnection() is emitted.</para>
            <para>Reimplement this function to alter the server's behavior when a connection is available.</para>
            <para>See also newConnection(), nextPendingConnection(), and QLocalSocket::setSocketDescriptor().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.WaitForNewConnection(System.Int32)">
            <summary>
            <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
            <para>This is a blocking function call. Its use is ill-advised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
            <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
            <para>If msec is -1, this function will not time out.</para>
            <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalServer.RemoveServer(System.String)">
            <summary>
            <para>Removes any server instance that might cause a call to listen() to fail and returns true if successful; otherwise returns false. This function is meant to recover from a crash, when the previous server instance has not been cleaned up.</para>
            <para>On Windows, this function does nothing; on Unix, it removes the socket file given by name.</para>
            <para>Warning: Be careful to avoid removing sockets of running instances.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalServer.NewConnection">
            <summary>
            <para>This signal is emitted every time a new connection is available.</para>
            <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.MaxPendingConnections">
            <summary>
            <para>Returns the maximum number of pending accepted connections. The default is 30.</para>
            <para>See also setMaxPendingConnections() and hasPendingConnections().</para>
            <para></para>
            <para>Sets the maximum number of pending accepted connections to numConnections. QLocalServer will accept no more than numConnections incoming connections before nextPendingConnection() is called.</para>
            <para>Note: Even though QLocalServer will stop accepting new connections after it has reached its maximum number of pending connections, the operating system may still keep them in queue which will result in clients signaling that it is connected.</para>
            <para>See also maxPendingConnections() and hasPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.SocketOptions">
            <summary>
            <para>The setSocketOptions method controls how the socket operates. For example the socket may restrict access to what user ids can connect to the socket.</para>
            <para>These options must be set before listen() is called.</para>
            <para>In some cases, such as with Unix domain sockets on Linux, the access to the socket will be determined by file system permissions, and are created based on the umask. Setting the access flags will overide this and will restrict or permit access as specified.</para>
            <para>Other Unix-based operating systems, such as OS X, do not honor file permissions for Unix domain sockets and by default have WorldAccess and these permission flags will have no effect.</para>
            <para>On Windows, UserAccessOption is sufficient to allow a non elevated process to connect to a local server created by an elevated process run by the same user. GroupAccessOption refers to the primary group of the process (see TokenPrimaryGroup in the Windows documentation). OtherAccessOption refers to the well known &quot;Everyone&quot; group.</para>
            <para>By default none of the flags are set, access permissions are the platform default.</para>
            <para>This property was introduced in  Qt 5.0.</para>
            <para>See also listen().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.ErrorString">
            <summary>
            <para>Returns the human-readable message appropriate to the current error reported by serverError(). If no suitable string is available, an empty string is returned.</para>
            <para>See also serverError().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.HasPendingConnections">
            <summary>
            <para>Returns true if the server has a pending connection; otherwise returns false.</para>
            <para>See also nextPendingConnection() and setMaxPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.IsListening">
            <summary>
            <para>Returns true if the server is listening for incoming connections otherwise false.</para>
            <para>See also listen() and close().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.NextPendingConnection">
            <summary>
            <para>Returns the next pending connection as a connected QLocalSocket object.</para>
            <para>The socket is created as a child of the server, which means that it is automatically deleted when the QLocalServer object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</para>
            <para>0 is returned if this function is called when there are no pending connections.</para>
            <para>See also hasPendingConnections(), newConnection(), and incomingConnection().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.ServerName">
            <summary>
            <para>Returns the server name if the server is listening for connections; otherwise returns QString()</para>
            <para>See also listen() and fullServerName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.FullServerName">
            <summary>
            <para>Returns the full path that the server is listening on.</para>
            <para>Note: This is platform specific</para>
            <para>See also listen() and serverName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalServer.ServerError">
            <summary>
            <para>Returns the type of error that occurred last or NoError.</para>
            <para>See also errorString().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QLocalServer.SocketOption">
            <summary>
            <para>This enum describes the possible options that can be used to create the socket. This changes the access permissions on platforms (Linux, Windows) that support access permissions on the socket. Both GroupAccess and OtherAccess may vary slightly in meanings depending on the platform.</para>
            <para>This enum was introduced or modified in  Qt 5.0.</para>
            <para>The SocketOptions type is a typedef for QFlags&lt;SocketOption&gt;. It stores an OR combination of SocketOption values.</para>
            <para>See also socketOptions.</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalServer.SocketOption.NoOptions">
            <summary>No access restrictions have been set.</summary>
        </member>
        <member name="F:QtNetwork.QLocalServer.SocketOption.UserAccessOption">
            <summary>Access is restricted to the same user as the process that created the socket.</summary>
        </member>
        <member name="F:QtNetwork.QLocalServer.SocketOption.GroupAccessOption">
            <summary>Access is restricted to the same group but not the user that created the socket on Linux. Access is restricted to the primary group of the process on Windows</summary>
        </member>
        <member name="F:QtNetwork.QLocalServer.SocketOption.OtherAccessOption">
            <summary>Access is available to everyone but the user and group that created the socket on Linux. Access is available to everyone on Windows.</summary>
        </member>
        <member name="F:QtNetwork.QLocalServer.SocketOption.WorldAccessOption">
            <summary>No access restrictions.</summary>
        </member>
        <member name="T:QtNetwork.QLocalSocket">
            <summary>
            <para>The QLocalSocket class provides a local socket.</para>
            </summary>
            <remarks>
            <para>On Windows this is a named pipe and on Unix this is a local domain socket.</para>
            <para>If an error occurs, socketError() returns the type of error, and errorString() can be called to get a human readable description of what happened.</para>
            <para>Although QLocalSocket is designed for use with an event loop, it's possible to use it without one. In that case, you must use waitForConnected(), waitForReadyRead(), waitForBytesWritten(), and waitForDisconnected() which blocks until the operation is complete or the timeout expires.</para>
            <para></para>
            <para>See also QLocalServer.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QLocalSocket.#ctor(QtCore.QObject)">
            <summary>
            <para>Creates a new local socket. The parent argument is passed to QObject's constructor.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.ConnectToServer(QtCore.QIODevice.OpenModeFlag)">
            <summary>
            <para>Attempts to make a connection to serverName(). setServerName() must be called before you open the connection. Alternatively you can use connectToServer(const QString &amp;name, OpenMode openMode);</para>
            <para>The socket is opened in the given openMode and first enters ConnectingState. If a connection is established, QLocalSocket enters ConnectedState and emits connected().</para>
            <para>After calling this function, the socket can emit error() to signal that an error occurred.</para>
            <para>This function was introduced in  Qt 5.1.</para>
            <para>See also state(), serverName(), and waitForConnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.ConnectToServer(System.String,QtCore.QIODevice.OpenModeFlag)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Set the server name and attempts to make a connection to it.</para>
            <para>The socket is opened in the given openMode and first enters ConnectingState. If a connection is established, QLocalSocket enters ConnectedState and emits connected().</para>
            <para>After calling this function, the socket can emit error() to signal that an error occurred.</para>
            <para>See also state(), serverName(), and waitForConnected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.DisconnectFromServer">
            <summary>
            <para>Attempts to close the socket. If there is pending data waiting to be written, QLocalSocket will enter ClosingState and wait until all data has been written. Eventually, it will enter UnconnectedState and emit the disconnectedFromServer() signal.</para>
            <para>See also connectToServer().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.Abort">
            <summary>
            <para>Aborts the current connection and resets the socket. Unlike disconnectFromServer(), this function immediately closes the socket, clearing any pending data in the write buffer.</para>
            <para>See also disconnectFromServer() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.CanReadLine">
            <summary>
            <para>Reimplemented from QIODevice::canReadLine().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.Open(QtCore.QIODevice.OpenModeFlag)">
            <summary>
            <para>Reimplemented from QIODevice::open().</para>
            <para>Equivalent to connectToServer(OpenMode mode). The socket is opened in the given openMode to the server defined by setServerName().</para>
            <para>Note that unlike in most other QIODevice subclasses, open() may not open the device directly. The function return false if the socket was already connected or if the server to connect to was not defined and true in any other case. The connected() or error() signals will be emitted once the device is actualy open (or the connection failed).</para>
            <para>See connectToServer() for more details.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.Close">
            <summary>
            <para>Reimplemented from QIODevice::close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.SetSocketDescriptor(System.Int32,QtNetwork.QLocalSocket.LocalSocketState,QtCore.QIODevice.OpenModeFlag)">
            <summary>
            <para>Initializes QLocalSocket with the native socket descriptor socketDescriptor. Returns true if socketDescriptor is accepted as a valid socket descriptor; otherwise returns false. The socket is opened in the mode specified by openMode, and enters the socket state specified by socketState.</para>
            <para>Note: It is not possible to initialize two local sockets with the same native socket descriptor.</para>
            <para>See also socketDescriptor(), state(), and openMode().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForBytesWritten(System.Int32)">
            <summary>
            <para>Reimplemented from QIODevice::waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForConnected(System.Int32)">
            <summary>
            <para>Waits until the socket is connected, up to msecs milliseconds. If the connection has been established, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
            <para>The following example waits up to one second for a connection to be established:</para>
            <para>socket-&gt;connectToServer(&quot;market&quot;);</para>
            <para>if (socket-&gt;waitForConnected(1000))</para>
            <para>    qDebug(&quot;Connected!&quot;);</para>
            <para>If msecs is -1, this function will not time out.</para>
            <para>See also connectToServer() and connected().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForDisconnected(System.Int32)">
            <summary>
            <para>Waits until the socket has disconnected, up to msecs milliseconds. If the connection has been disconnected, this function returns true; otherwise it returns false. In the case where it returns false, you can call error() to determine the cause of the error.</para>
            <para>The following example waits up to one second for a connection to be closed:</para>
            <para>socket-&gt;disconnectFromServer();</para>
            <para>if (socket-&gt;waitForDisconnected(1000))</para>
            <para>    qDebug(&quot;Disconnected!&quot;);</para>
            <para>If msecs is -1, this function will not time out.</para>
            <para>See also disconnectFromServer() and close().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WaitForReadyRead(System.Int32)">
            <summary>
            <para>Reimplemented from QIODevice::waitForReadyRead().</para>
            <para>This function blocks until data is available for reading and the readyRead() signal has been emitted. The function will timeout after msecs milliseconds; the default timeout is 30000 milliseconds.</para>
            <para>The function returns true if data is available for reading; otherwise it returns false (if an error occurred or the operation timed out).</para>
            <para>See also waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.ReadData(System.Char*,System.Int64)">
            <summary>
            <para>Reimplemented from QIODevice::readData().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QLocalSocket.WriteData(System.String,System.Int64)">
            <summary>
            <para>Reimplemented from QIODevice::writeData().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.Connected">
            <summary>
            <para>This signal is emitted after connectToServer() has been called and a connection has been successfully established.</para>
            <para>See also connectToServer() and disconnected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.Disconnected">
            <summary>
            <para>This signal is emitted when the socket has been disconnected.</para>
            <para>See also connectToServer(), disconnectFromServer(), abort(), and connected().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.ErrorSocketError">
            <summary>
            <para>This signal is emitted after an error occurred. The socketError parameter describes the type of error that occurred.</para>
            <para>QLocalSocket::LocalSocketError is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
            <para>See also error(), errorString(), and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QLocalSocket.StateChanged">
            <summary>
            <para>This signal is emitted whenever QLocalSocket's state changes. The socketState parameter is the new state.</para>
            <para>QLocalSocket::SocketState is not a registered metatype, so for queued connections, you will have to register it with Q_DECLARE_METATYPE() and qRegisterMetaType().</para>
            <para>See also state() and Creating Custom Qt Types.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.ServerName">
            <summary>
            <para>Returns the name of the peer as specified by setServerName(), or an empty QString if setServerName() has not been called or connectToServer() failed.</para>
            <para>See also setServerName(), connectToServer(), and fullServerName().</para>
            <para></para>
            <para>Set the name of the peer to connect to. On Windows name is the name of a named pipe; on Unix name is the name of a local domain socket.</para>
            <para>This function must be called when the socket is not connected.</para>
            <para>This function was introduced in  Qt 5.1.</para>
            <para>See also serverName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.ReadBufferSize">
            <summary>
            <para>Returns the size of the internal read buffer. This limits the amount of data that the client can receive before you call read() or readAll(). A read buffer size of 0 (the default) means that the buffer has no size limit, ensuring that no data is lost.</para>
            <para>See also setReadBufferSize() and read().</para>
            <para></para>
            <para>Sets the size of QLocalSocket's internal read buffer to be size bytes.</para>
            <para>If the buffer size is limited to a certain size, QLocalSocket won't buffer more than this size of data. Exceptionally, a buffer size of 0 means that the read buffer is unlimited and all incoming data is buffered. This is the default.</para>
            <para>This option is useful if you only read the data at certain points in time (e.g., in a real-time streaming application) or if you want to protect your socket against receiving too much data, which may eventually cause your application to run out of memory.</para>
            <para>See also readBufferSize() and read().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.IsSequential">
            <summary>
            <para>Reimplemented from QIODevice::isSequential().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.BytesAvailable">
            <summary>
            <para>Reimplemented from QIODevice::bytesAvailable().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.BytesToWrite">
            <summary>
            <para>Reimplemented from QIODevice::bytesToWrite().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.FullServerName">
            <summary>
            <para>Returns the server path that the socket is connected to.</para>
            <para>Note: The return value of this function is platform specific.</para>
            <para>See also connectToServer() and serverName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.Error">
            <summary>
            <para>Returns the type of error that last occurred.</para>
            <para>See also state() and errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.Flush">
            <summary>
            <para>This function writes as much as possible from the internal write buffer to the socket, without blocking. If any data was written, this function returns true; otherwise false is returned.</para>
            <para>Call this function if you need QLocalSocket to start sending buffered data immediately. The number of bytes successfully written depends on the operating system. In most cases, you do not need to call this function, because QLocalSocket will start sending data automatically once control goes back to the event loop. In the absence of an event loop, call waitForBytesWritten() instead.</para>
            <para>See also write() and waitForBytesWritten().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.IsValid">
            <summary>
            <para>Returns true if the socket is valid and ready for use; otherwise returns false.</para>
            <para>Note: The socket's state must be ConnectedState before reading and writing can occur.</para>
            <para>See also state() and connectToServer().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.SocketDescriptor">
            <summary>
            <para>Returns the native socket descriptor of the QLocalSocket object if this is available; otherwise returns -1.</para>
            <para>The socket descriptor is not available when QLocalSocket is in UnconnectedState.</para>
            <para>See also setSocketDescriptor().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QLocalSocket.State">
            <summary>
            <para>Returns the state of the socket.</para>
            <para>See also error().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QLocalSocket.LocalSocketError">
            <summary>
            <para>The LocalServerError enumeration represents the errors that can occur. The most recent error can be retrieved through a call to QLocalSocket::error().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.ConnectionRefusedError">
            <summary>The connection was refused by the peer (or timed out).</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.PeerClosedError">
            <summary>The remote socket closed the connection. Note that the client socket (i.e., this socket) will be closed after the remote close notification has been sent.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.ServerNotFoundError">
            <summary>The local socket name was not found.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.SocketAccessError">
            <summary>The socket operation failed because the application lacked the required privileges.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.SocketResourceError">
            <summary>The local system ran out of resources (e.g., too many sockets).</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.SocketTimeoutError">
            <summary>The socket operation timed out.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.DatagramTooLargeError">
            <summary>The datagram was larger than the operating system's limit (which can be as low as 8192 bytes).</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.ConnectionError">
            <summary>An error occurred with the connection.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.UnsupportedSocketOperationError">
            <summary>The requested socket operation is not supported by the local operating system.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.UnknownSocketError">
            <summary>An unidentified error occurred.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketError.OperationError">
            <summary>An operation was attempted while the socket was in a state that did not permit it.</summary>
        </member>
        <member name="T:QtNetwork.QLocalSocket.LocalSocketState">
            <summary>
            <para>This enum describes the different states in which a socket can be.</para>
            <para>See also QLocalSocket::state().</para>
            </summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.UnconnectedState">
            <summary>The socket is not connected.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.ConnectingState">
            <summary>The socket has started establishing a connection.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.ConnectedState">
            <summary>A connection is established.</summary>
        </member>
        <member name="F:QtNetwork.QLocalSocket.LocalSocketState.ClosingState">
            <summary>The socket is about to close (data may still be waiting to be written).</summary>
        </member>
        <member name="T:QtNetwork.QTcpServer">
            <summary>
            <para>The QTcpServer class provides a TCP-based server.</para>
            </summary>
            <remarks>
            <para>This class makes it possible to accept incoming TCP connections. You can specify the port or have QTcpServer pick one automatically. You can listen on a specific address or on all the machine's addresses.</para>
            <para>Call listen() to have the server listen for incoming connections. The newConnection() signal is then emitted each time a client connects to the server.</para>
            <para>Call nextPendingConnection() to accept the pending connection as a connected QTcpSocket. The function returns a pointer to a QTcpSocket in QAbstractSocket::ConnectedState that you can use for communicating with the client.</para>
            <para>If an error occurs, serverError() returns the type of error, and errorString() can be called to get a human readable description of what happened.</para>
            <para>When listening for connections, the address and port on which the server is listening are available as serverAddress() and serverPort().</para>
            <para>Calling close() makes QTcpServer stop listening for incoming connections.</para>
            <para>Although QTcpServer is mostly designed for use with an event loop, it's possible to use it without one. In that case, you must use waitForNewConnection(), which blocks until either a connection is available or a timeout expires.</para>
            <para></para>
            <para>See also QTcpSocket, Fortune Server Example, Threaded Fortune Server Example, Loopback Example, and Torrent Example.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QTcpServer.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QTcpServer object.</para>
            <para>parent is passed to the QObject constructor.</para>
            <para>See also listen() and setSocketDescriptor().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.Listen(QtNetwork.QHostAddress,System.UInt16)">
            <summary>
            <para>Tells the server to listen for incoming connections on address address and port port. If port is 0, a port is chosen automatically. If address is QHostAddress::Any, the server will listen on all network interfaces.</para>
            <para>Returns true on success; otherwise returns false.</para>
            <para>See also isListening().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.Close">
            <summary>
            <para>Closes the server. The server will no longer listen for incoming connections.</para>
            <para>See also listen().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.SetSocketDescriptor(System.Int32)">
            <summary>
            <para>Sets the socket descriptor this server should use when listening for incoming connections to socketDescriptor. Returns true if the socket is set successfully; otherwise returns false.</para>
            <para>The socket is assumed to be in listening state.</para>
            <para>See also socketDescriptor() and isListening().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.WaitForNewConnection(System.Int32,System.Boolean@)">
            <summary>
            <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
            <para>This is a blocking function call. Its use is disadvised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
            <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
            <para>If msec is -1, this function will not time out.</para>
            <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.PauseAccepting">
            <summary>
            <para>Pauses accepting new connections. Queued connections will remain in queue.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also resumeAccepting().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.ResumeAccepting">
            <summary>
            <para>Resumes accepting new connections.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also pauseAccepting().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.IncomingConnection(System.Int32)">
            <summary>
            <para>This virtual function is called by QTcpServer when a new connection is available. The socketDescriptor argument is the native socket descriptor for the accepted connection.</para>
            <para>The base implementation creates a QTcpSocket, sets the socket descriptor and then stores the QTcpSocket in an internal list of pending connections. Finally newConnection() is emitted.</para>
            <para>Reimplement this function to alter the server's behavior when a connection is available.</para>
            <para>If this server is using QNetworkProxy then the socketDescriptor may not be usable with native socket functions, and should only be used with QTcpSocket::setSocketDescriptor().</para>
            <para>Note: If you want to handle an incoming connection as a new QTcpSocket object in another thread you have to pass the socketDescriptor to the other thread and create the QTcpSocket object there and use its setSocketDescriptor() method.</para>
            <para>See also newConnection(), nextPendingConnection(), and addPendingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.AddPendingConnection(QtNetwork.QTcpSocket)">
            <summary>
            <para>This function is called by QTcpServer::incomingConnection() to add the socket to the list of pending incoming connections.</para>
            <para>Note: Don't forget to call this member from reimplemented incomingConnection() if you do not want to break the Pending Connections mechanism.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also incomingConnection().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.Listen">
            <summary>
            <para>Tells the server to listen for incoming connections on address address and port port. If port is 0, a port is chosen automatically. If address is QHostAddress::Any, the server will listen on all network interfaces.</para>
            <para>Returns true on success; otherwise returns false.</para>
            <para>See also isListening().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QTcpServer.WaitForNewConnection(System.Int32)">
            <summary>
            <para>Waits for at most msec milliseconds or until an incoming connection is available. Returns true if a connection is available; otherwise returns false. If the operation timed out and timedOut is not 0, *timedOut will be set to true.</para>
            <para>This is a blocking function call. Its use is disadvised in a single-threaded GUI application, since the whole application will stop responding until the function returns. waitForNewConnection() is mostly useful when there is no event loop available.</para>
            <para>The non-blocking alternative is to connect to the newConnection() signal.</para>
            <para>If msec is -1, this function will not time out.</para>
            <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QTcpServer.NewConnection">
            <summary>
            <para>This signal is emitted every time a new connection is available.</para>
            <para>See also hasPendingConnections() and nextPendingConnection().</para>
            </summary>
        </member>
        <member name="E:QtNetwork.QTcpServer.AcceptError">
            <summary>
            <para>This signal is emitted when accepting a new connection results in an error. The socketError parameter describes the type of error that occurred.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            <para>See also pauseAccepting() and resumeAccepting().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.MaxPendingConnections">
            <summary>
            <para>Returns the maximum number of pending accepted connections. The default is 30.</para>
            <para>See also setMaxPendingConnections() and hasPendingConnections().</para>
            <para></para>
            <para>Sets the maximum number of pending accepted connections to numConnections. QTcpServer will accept no more than numConnections incoming connections before nextPendingConnection() is called. By default, the limit is 30 pending connections.</para>
            <para>Clients may still able to connect after the server has reached its maximum number of pending connections (i.e., QTcpSocket can still emit the connected() signal). QTcpServer will stop accepting the new connections, but the operating system may still keep them in queue.</para>
            <para>See also maxPendingConnections() and hasPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.Proxy">
            <summary>
            <para>Returns the network proxy for this socket. By default QNetworkProxy::DefaultProxy is used.</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also setProxy() and QNetworkProxy.</para>
            <para></para>
            <para>Sets the explicit network proxy for this socket to networkProxy.</para>
            <para>To disable the use of a proxy for this socket, use the QNetworkProxy::NoProxy proxy type:</para>
            <para>server-&gt;setProxy(QNetworkProxy::NoProxy);</para>
            <para>This function was introduced in  Qt 4.1.</para>
            <para>See also proxy() and QNetworkProxy.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.IsListening">
            <summary>
            <para>Returns true if the server is currently listening for incoming connections; otherwise returns false.</para>
            <para>See also listen().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ServerPort">
            <summary>
            <para>Returns the server's port if the server is listening for connections; otherwise returns 0.</para>
            <para>See also serverAddress() and listen().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ServerAddress">
            <summary>
            <para>Returns the server's address if the server is listening for connections; otherwise returns QHostAddress::Null.</para>
            <para>See also serverPort() and listen().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.SocketDescriptor">
            <summary>
            <para>Returns the native socket descriptor the server uses to listen for incoming instructions, or -1 if the server is not listening.</para>
            <para>If the server is using QNetworkProxy, the returned descriptor may not be usable with native socket functions.</para>
            <para>See also setSocketDescriptor() and isListening().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.HasPendingConnections">
            <summary>
            <para>Returns true if the server has a pending connection; otherwise returns false.</para>
            <para>See also nextPendingConnection() and setMaxPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.NextPendingConnection">
            <summary>
            <para>Returns the next pending connection as a connected QTcpSocket object.</para>
            <para>The socket is created as a child of the server, which means that it is automatically deleted when the QTcpServer object is destroyed. It is still a good idea to delete the object explicitly when you are done with it, to avoid wasting memory.</para>
            <para>0 is returned if this function is called when there are no pending connections.</para>
            <para>Note: The returned QTcpSocket object cannot be used from another thread. If you want to use an incoming connection from another thread, you need to override incomingConnection().</para>
            <para>See also hasPendingConnections().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ServerError">
            <summary>
            <para>Returns an error code for the last error that occurred.</para>
            <para>See also errorString().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QTcpServer.ErrorString">
            <summary>
            <para>Returns a human readable description of the last error that occurred.</para>
            <para>See also serverError().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QUdpSocket">
            <summary>
            <para>The QUdpSocket class provides a UDP socket.</para>
            </summary>
            <remarks>
            <para>UDP (User Datagram Protocol) is a lightweight, unreliable, datagram-oriented, connectionless protocol. It can be used when reliability isn't important. QUdpSocket is a subclass of QAbstractSocket that allows you to send and receive UDP datagrams.</para>
            <para>The most common way to use this class is to bind to an address and port using bind(), then call writeDatagram() and readDatagram() to transfer data. If you want to use the standard QIODevice functions read(), readLine(), write(), etc., you must first connect the socket directly to a peer by calling connectToHost().</para>
            <para>The socket emits the bytesWritten() signal every time a datagram is written to the network. If you just want to send datagrams, you don't need to call bind().</para>
            <para>The readyRead() signal is emitted whenever datagrams arrive. In that case, hasPendingDatagrams() returns true. Call pendingDatagramSize() to obtain the size of the first pending datagram, and readDatagram() to read it.</para>
            <para>Note: An incoming datagram should be read when you receive the readyRead() signal, otherwise this signal will not be emitted for the next datagram.</para>
            <para>Example:</para>
            <para>void Server::initSocket()</para>
            <para>{</para>
            <para>    udpSocket = new QUdpSocket(this);</para>
            <para>    udpSocket-&gt;bind(QHostAddress::LocalHost, 7755);</para>
            <para></para>
            <para>    connect(udpSocket, SIGNAL(readyRead()),</para>
            <para>            this, SLOT(readPendingDatagrams()));</para>
            <para>}</para>
            <para></para>
            <para>void Server::readPendingDatagrams()</para>
            <para>{</para>
            <para>    while (udpSocket-&gt;hasPendingDatagrams()) {</para>
            <para>        QByteArray datagram;</para>
            <para>        datagram.resize(udpSocket-&gt;pendingDatagramSize());</para>
            <para>        QHostAddress sender;</para>
            <para>        quint16 senderPort;</para>
            <para></para>
            <para>        udpSocket-&gt;readDatagram(datagram.data(), datagram.size(),</para>
            <para>                                &amp;sender, &amp;senderPort);</para>
            <para></para>
            <para>        processTheDatagram(datagram);</para>
            <para>    }</para>
            <para>}</para>
            <para>QUdpSocket also supports UDP multicast. Use joinMulticastGroup() and leaveMulticastGroup() to control group membership, and QAbstractSocket::MulticastTtlOption and QAbstractSocket::MulticastLoopbackOption to set the TTL and loopback socket options. Use setMulticastInterface() to control the outgoing interface for multicast datagrams, and multicastInterface() to query it.</para>
            <para>With QUdpSocket, you can also establish a virtual connection to a UDP server using connectToHost() and then use read() and write() to exchange datagrams without specifying the receiver for each datagram.</para>
            <para>The Broadcast Sender, Broadcast Receiver, Multicast Sender, and Multicast Receiver examples illustrate how to use QUdpSocket in applications.</para>
            <para></para>
            <para>See also QTcpSocket.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QUdpSocket.#ctor(QtCore.QObject)">
            <summary>
            <para>Creates a QUdpSocket object.</para>
            <para>parent is passed to the QObject constructor.</para>
            <para>See also socketType().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.JoinMulticastGroup(QtNetwork.QHostAddress)">
            <summary>
            <para>Joins the multicast group specified by groupAddress on the default interface chosen by the operating system. The socket must be in BoundState, otherwise an error occurs.</para>
            <para>Note that if you are attempting to join an IPv4 group, your socket must not be bound using IPv6 (or in dual mode, using QHostAddress::Any). You must use QHostAddress::AnyIPv4 instead.</para>
            <para>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also leaveMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.JoinMulticastGroup(QtNetwork.QHostAddress,QtNetwork.QNetworkInterface)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Joins the multicast group address groupAddress on the interface iface.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also leaveMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.LeaveMulticastGroup(QtNetwork.QHostAddress)">
            <summary>
            <para>Leaves the multicast group specified by groupAddress on the default interface chosen by the operating system. The socket must be in BoundState, otherwise an error occurs.</para>
            <para>This function returns true if successful; otherwise it returns false and sets the socket error accordingly.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also joinMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.LeaveMulticastGroup(QtNetwork.QHostAddress,QtNetwork.QNetworkInterface)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Leaves the multicast group specified by groupAddress on the interface iface.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also joinMulticastGroup().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.ReadDatagram(System.Char*,System.Int64,QtNetwork.QHostAddress,System.UInt16@)">
            <summary>
            <para>Receives a datagram no larger than maxSize bytes and stores it in data. The sender's host address and port is stored in *address and *port (unless the pointers are 0).</para>
            <para>Returns the size of the datagram on success; otherwise returns -1.</para>
            <para>If maxSize is too small, the rest of the datagram will be lost. To avoid loss of data, call pendingDatagramSize() to determine the size of the pending datagram before attempting to read it. If maxSize is 0, the datagram will be discarded.</para>
            <para>See also writeDatagram(), hasPendingDatagrams(), and pendingDatagramSize().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.WriteDatagram(System.String,System.Int64,QtNetwork.QHostAddress,System.UInt16)">
            <summary>
            <para>Sends the datagram at data of size size to the host address address at port port. Returns the number of bytes sent on success; otherwise returns -1.</para>
            <para>Datagrams are always written as one block. The maximum size of a datagram is highly platform-dependent, but can be as low as 8192 bytes. If the datagram is too large, this function will return -1 and error() will return DatagramTooLargeError.</para>
            <para>Sending datagrams larger than 512 bytes is in general disadvised, as even if they are sent successfully, they are likely to be fragmented by the IP layer before arriving at their final destination.</para>
            <para>Warning: Calling this function on a connected UDP socket may result in an error and no packet being sent. If you are using a connected socket, use write() to send datagrams.</para>
            <para>See also readDatagram() and write().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.WriteDatagram(QtCore.QByteArray,QtNetwork.QHostAddress,System.UInt16)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sends the datagram datagram to the host address host and at port port.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QUdpSocket.ReadDatagram(System.Char*,System.Int64,QtNetwork.QHostAddress)">
            <summary>
            <para>Receives a datagram no larger than maxSize bytes and stores it in data. The sender's host address and port is stored in *address and *port (unless the pointers are 0).</para>
            <para>Returns the size of the datagram on success; otherwise returns -1.</para>
            <para>If maxSize is too small, the rest of the datagram will be lost. To avoid loss of data, call pendingDatagramSize() to determine the size of the pending datagram before attempting to read it. If maxSize is 0, the datagram will be discarded.</para>
            <para>See also writeDatagram(), hasPendingDatagrams(), and pendingDatagramSize().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUdpSocket.MulticastInterface">
            <summary>
            <para>Returns the interface for the outgoing interface for multicast datagrams. This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. If no interface has been previously set, this function returns an invalid QNetworkInterface. The socket must be in BoundState, otherwise an invalid QNetworkInterface is returned.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also setMulticastInterface().</para>
            <para></para>
            <para>Sets the outgoing interface for multicast datagrams to the interface iface. This corresponds to the IP_MULTICAST_IF socket option for IPv4 sockets and the IPV6_MULTICAST_IF socket option for IPv6 sockets. The socket must be in BoundState, otherwise this function does nothing.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also multicastInterface(), joinMulticastGroup(), and leaveMulticastGroup().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUdpSocket.HasPendingDatagrams">
            <summary>
            <para>Returns true if at least one datagram is waiting to be read; otherwise returns false.</para>
            <para>See also pendingDatagramSize() and readDatagram().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QUdpSocket.PendingDatagramSize">
            <summary>
            <para>Returns the size of the first pending UDP datagram. If there is no datagram available, this function returns -1.</para>
            <para>See also hasPendingDatagrams() and readDatagram().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslCertificateExtension">
            <summary>
            <para>The QSslCertificateExtension class provides an API for accessing the extensions of an X509 certificate.</para>
            </summary>
            <remarks>
            <para>QSslCertificateExtension provides access to an extension stored in an X509 certificate. The information available depends on the type of extension being accessed.</para>
            <para>All X509 certificate extensions have the following properties:</para>
            <para></para>
            <para>PropertyDescription</para>
            <para>name	The human readable name of the extension, eg. 'basicConstraints'.</para>
            <para>criticality	This is a boolean value indicating if the extension is critical to correctly interpreting the certificate.</para>
            <para>oid	The ASN.1 object identifier that specifies which extension this is.</para>
            <para>supported	If this is true the structure of the extension's value will not change between Qt versions.</para>
            <para>value	A QVariant with a structure dependent on the type of extension.</para>
            <para></para>
            <para>Whilst this class provides access to any type of extension, only some are guaranteed to be returned in a format that will remain unchanged between releases. The isSupported() method returns true for extensions where this is the case.</para>
            <para>The extensions currently supported, and the structure of the value returned are as follows:</para>
            <para></para>
            <para>NameOIDDetails</para>
            <para>basicConstraints	2.5.29.19	Returned as a QVariantMap. The key 'ca' contains a boolean value, the optional key 'pathLenConstraint' contains an integer.</para>
            <para>authorityInfoAccess	1.3.6.1.5.5.7.1.1	Returned as a QVariantMap. There is a key for each access method, with the value being a URI.</para>
            <para>subjectKeyIdentifier	2.5.29.14	Returned as a QVariant containing a QString. The string is the key identifier.</para>
            <para>authorityKeyIdentifier	2.5.29.35	Returned as a QVariantMap. The optional key 'keyid' contains the key identifier as a hex string stored in a QByteArray. The optional key 'serial' contains the authority key serial number as a qlonglong. Currently there is no support for the general names field of this extension.</para>
            <para></para>
            <para>In addition to the supported extensions above, many other common extensions will be returned in a reasonably structured way. Extensions that the SSL backend has no support for at all will be returned as a QByteArray.</para>
            <para>Further information about the types of extensions certificates can contain can be found in RFC 5280.</para>
            <para></para>
            <para>See also QSslCertificate::extensions().</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslCertificateExtension.#ctor">
            <summary>
            <para>Constructs a QSslCertificateExtension.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificateExtension.#ctor(QtNetwork.QSslCertificateExtension)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCertificateExtension.Swap(QtNetwork.QSslCertificateExtension)">
            <summary>
            <para>Swaps this certificate extension instance with other. This function is very fast and never fails.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificateExtension.Oid">
            <summary>
            <para>Returns the ASN.1 OID of this extension.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificateExtension.Name">
            <summary>
            <para>Returns the name of the extension. If no name is known for the extension then the OID will be returned.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificateExtension.Value">
            <summary>
            <para>Returns the value of the extension. The structure of the value returned depends on the extension type.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificateExtension.IsCritical">
            <summary>
            <para>Returns the criticality of the extension.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCertificateExtension.IsSupported">
            <summary>
            <para>Returns the true if this extension is supported. In this case, supported simply means that the structure of the QVariant returned by the value() accessor will remain unchanged between versions. Unsupported extensions can be freely used, however there is no guarantee that the returned data will have the same structure between versions.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslCipher">
            <summary>
            <para>The QSslCipher class represents an SSL cryptographic cipher.</para>
            </summary>
            <remarks>
            <para>QSslCipher stores information about one cryptographic cipher. It is most commonly used with QSslSocket, either for configuring which ciphers the socket can use, or for displaying the socket's ciphers to the user.</para>
            <para></para>
            <para>See also QSslSocket and QSslKey.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslCipher.#ctor">
            <summary>
            <para>Constructs an empty QSslCipher object.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.#ctor(System.String)">
            <summary>
            <para>Constructs a QSslCipher object for the cipher determined by name. The constructor accepts only supported ciphers (i.e., the name must identify a cipher in the list of ciphers returned by QSslSocket::supportedCiphers()).</para>
            <para>You can call isNull() after construction to check if name correctly identified a supported cipher.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.#ctor(System.String,QtNetwork.QSsl.SslProtocol)">
            <summary>
            <para>Constructs a QSslCipher object for the cipher determined by name and protocol. The constructor accepts only supported ciphers (i.e., the name and protocol must identify a cipher in the list of ciphers returned by QSslSocket::supportedCiphers()).</para>
            <para>You can call isNull() after construction to check if name and protocol correctly identified a supported cipher.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.#ctor(QtNetwork.QSslCipher)">
            <summary>
            <para>Constructs an identical copy of the other cipher.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.Swap(QtNetwork.QSslCipher)">
            <summary>
            <para>Swaps this cipher instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.op_Equality(QtNetwork.QSslCipher,QtNetwork.QSslCipher)">
            <summary>
            <para>Returns true if this cipher is the same as other; otherwise, false is returned.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslCipher.op_Inequality(QtNetwork.QSslCipher,QtNetwork.QSslCipher)">
            <summary>
            <para>Returns true if this cipher is not the same as other; otherwise, false is returned.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.IsNull">
            <summary>
            <para>Returns true if this is a null cipher; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.Name">
            <summary>
            <para>Returns the name of the cipher, or an empty QString if this is a null cipher.</para>
            <para>See also isNull().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.SupportedBits">
            <summary>
            <para>Returns the number of bits supported by the cipher.</para>
            <para>See also usedBits().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.UsedBits">
            <summary>
            <para>Returns the number of bits used by the cipher.</para>
            <para>See also supportedBits().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.KeyExchangeMethod">
            <summary>
            <para>Returns the cipher's key exchange method as a QString.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.AuthenticationMethod">
            <summary>
            <para>Returns the cipher's authentication method as a QString.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.EncryptionMethod">
            <summary>
            <para>Returns the cipher's encryption method as a QString.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.ProtocolString">
            <summary>
            <para>Returns the cipher's protocol as a QString.</para>
            <para>See also protocol().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslCipher.Protocol">
            <summary>
            <para>Returns the cipher's protocol type, or QSsl::UnknownProtocol if QSslCipher is unable to determine the protocol (protocolString() may contain more information).</para>
            <para>See also protocolString().</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslEllipticCurve">
            <summary>
            <para>Represents an elliptic curve for use by elliptic-curve cipher algorithms.</para>
            </summary>
            <remarks>
            <para>The class QSslEllipticCurve represents an elliptic curve for use by elliptic-curve cipher algorithms.</para>
            <para>Elliptic curves can be constructed from a &quot;short name&quot; (SN) (fromShortName()), and by a call to QSslConfiguration::supportedEllipticCurves().</para>
            <para>QSslEllipticCurve instances can be compared for equality and can be used as keys in QHash and QSet. They cannot be used as key in a QMap.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslEllipticCurve.#ctor">
            <summary>
            <para>Constructs an invalid elliptic curve.</para>
            <para>See also isValid() and QSslConfiguration::supportedEllipticCurves().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslEllipticCurve.FromShortName(System.String)">
            <summary>
            <para>Returns an QSslEllipticCurve instance representing the named curve name. The name is the conventional short name for the curve, as represented by RFC 4492 (for instance secp521r1), or as NIST short names (for instance P-256). The actual set of recognized names depends on the SSL implementation.</para>
            <para>If the given name is not supported, returns an invalid QSslEllipticCurve instance.</para>
            <para>Note: The OpenSSL implementation of this function treats the name case-sensitively.</para>
            <para>See also shortName().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslEllipticCurve.FromLongName(System.String)">
            <summary>
            <para>Returns an QSslEllipticCurve instance representing the named curve name. The name is a long name for the curve, whose exact spelling depends on the SSL implementation.</para>
            <para>If the given name is not supported, returns an invalid QSslEllipticCurve instance.</para>
            <para>Note: The OpenSSL implementation of this function treats the name case-sensitively.</para>
            <para>See also longName().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslEllipticCurve.op_Equality(QtNetwork.QSslEllipticCurve,QtNetwork.QSslEllipticCurve)">
            <summary>
            <para>Returns true if the curve lhs represents the same curve of rhs;</para>
            <para>This function was introduced in  Qt 5.5.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslEllipticCurve.op_Inequality(QtNetwork.QSslEllipticCurve,QtNetwork.QSslEllipticCurve)">
            <summary>
            <para>Returns true if the curve lhs represents a different curve than rhs; false otherwise.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslEllipticCurve.ShortName">
            <summary>
            <para>Returns the conventional short name for this curve. If this curve is invalid, returns an empty string.</para>
            <para>See also longName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslEllipticCurve.LongName">
            <summary>
            <para>Returns the conventional long name for this curve. If this curve is invalid, returns an empty string.</para>
            <para>See also shortName().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslEllipticCurve.IsValid">
            <summary>
            <para>Returns true if this elliptic curve is a valid curve, false otherwise.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslEllipticCurve.IsTlsNamedCurve">
            <summary>
            <para>Returns true if this elliptic curve is one of the named curves that can be used in the key exchange when using an elliptic curve cipher with TLS; false otherwise.</para>
            </summary>
        </member>
        <member name="T:QtNetwork.QSslKey">
            <summary>
            <para>The QSslKey class provides an interface for private and public keys.</para>
            </summary>
            <remarks>
            <para>QSslKey provides a simple API for managing keys.</para>
            <para></para>
            <para>See also QSslSocket, QSslCertificate, and QSslCipher.</para>
            </remarks>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor">
            <summary>
            <para>Constructs a null key.</para>
            <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtCore.QByteArray,QtNetwork.QSsl.KeyAlgorithm,QtNetwork.QSsl.EncodingFormat,QtNetwork.QSsl.KeyType,QtCore.QByteArray)">
            <summary>
            <para>Constructs a QSslKey by decoding the string in the byte array encoded using a specified algorithm and encoding format. type specifies whether the key is public or private.</para>
            <para>If the key is encoded as PEM and encrypted, passPhrase is used to decrypt it.</para>
            <para>After construction, use isNull() to check if encoded contained a valid key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtCore.QIODevice,QtNetwork.QSsl.KeyAlgorithm,QtNetwork.QSsl.EncodingFormat,QtNetwork.QSsl.KeyType,QtCore.QByteArray)">
            <summary>
            <para>Constructs a QSslKey by reading and decoding data from a device using a specified algorithm and encoding format. type specifies whether the key is public or private.</para>
            <para>If the key is encoded as PEM and encrypted, passPhrase is used to decrypt it.</para>
            <para>After construction, use isNull() to check if device provided a valid key.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(System.IntPtr,QtNetwork.QSsl.KeyType)">
            <summary>
            <para>Constructs a QSslKey from a valid native key handle. type specifies whether the key is public or private.</para>
            <para>QSslKey will take ownership for this key and you must not free the key using the native library. The algorithm used when creating a key from a handle will always be QSsl::Opaque.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.#ctor(QtNetwork.QSslKey)">
            <summary>
            <para>Constructs an identical copy of other.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.Swap(QtNetwork.QSslKey)">
            <summary>
            <para>Swaps this ssl key with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.Clear">
            <summary>
            <para>Clears the contents of this key, making it a null key.</para>
            <para>See also isNull().</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.ToPem(QtCore.QByteArray)">
            <summary>
            <para>Returns the key in PEM encoding. The result is encrypted with passPhrase if the key is a private key and passPhrase is non-empty.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.ToDer(QtCore.QByteArray)">
            <summary>
            <para>Returns the key in DER encoding.</para>
            <para>The passPhrase argument should be omitted as DER cannot be encrypted. It will be removed in a future version of Qt.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.op_Equality(QtNetwork.QSslKey,QtNetwork.QSslKey)">
            <summary>
            <para>Returns true if this key is equal to other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtNetwork.QSslKey.op_Inequality(QtNetwork.QSslKey,QtNetwork.QSslKey)">
            <summary>
            <para>Returns true if this key is not equal to key other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.IsNull">
            <summary>
            <para>Returns true if this is a null key; otherwise false.</para>
            <para>See also clear().</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Length">
            <summary>
            <para>Returns the length of the key in bits, or -1 if the key is null.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Type">
            <summary>
            <para>Returns the type of the key (i.e., PublicKey or PrivateKey).</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Algorithm">
            <summary>
            <para>Returns the key algorithm.</para>
            </summary>
        </member>
        <member name="P:QtNetwork.QSslKey.Handle">
            <summary>
            <para>Returns a pointer to the native key handle, if it is available; otherwise a null pointer is returned.</para>
            <para>You can use this handle together with the native API to access extended information about the key.</para>
            <para>Warning: Use of this function has a high probability of being non-portable, and its return value may vary across platforms, and between minor Qt releases.</para>
            </summary>
        </member>
    </members>
</doc>
