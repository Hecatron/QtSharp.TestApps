<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QtOpenGLSharp</name>
    </assembly>
    <members>
        <member name="T:QtOpenGL.QGLColormap">
            <summary>
            <para>The QGLColormap class is used for installing custom colormaps into a QGLWidget.</para>
            </summary>
            <remarks>
            <para>QGLColormap provides a platform independent way of specifying and installing indexed colormaps for a QGLWidget. QGLColormap is especially useful when using the OpenGL color-index mode.</para>
            <para>Under X11 you must use an X server that supports either a PseudoColor or DirectColor visual class. If your X server currently only provides a GrayScale, TrueColor, StaticColor or StaticGray visual, you will not be able to allocate colorcells for writing. If this is the case, try setting your X server to 8 bit mode. It should then provide you with at least a PseudoColor visual. Note that you may experience colormap flashing if your X server is running in 8 bit mode.</para>
            <para>The size() of the colormap is always set to 256 colors. Note that under Windows you can also install colormaps in child widgets.</para>
            <para>This class uses implicit sharing as a memory and speed optimization.</para>
            <para>Example of use:</para>
            <para>#include &lt;QApplication&gt;</para>
            <para>#include &lt;QGLColormap&gt;</para>
            <para></para>
            <para>int main()</para>
            <para>{</para>
            <para>    QApplication app(argc, argv);</para>
            <para></para>
            <para>    MySuperGLWidget widget;     // a QGLWidget in color-index mode</para>
            <para>    QGLColormap colormap;</para>
            <para></para>
            <para>    // This will fill the colormap with colors ranging from</para>
            <para>    // black to white.</para>
            <para>    for (int i = 0; i &lt; colormap.size(); i++)</para>
            <para>        colormap.setEntry(i, qRgb(i, i, i));</para>
            <para></para>
            <para>    widget.setColormap(colormap);</para>
            <para>    widget.show();</para>
            <para>    return app.exec();</para>
            <para>}</para>
            <para></para>
            <para>See also QGLWidget::setColormap() and QGLWidget::colormap().</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLColormap.#ctor">
            <summary>
            <para>Construct a QGLColormap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.#ctor(QtOpenGL.QGLColormap)">
            <summary>
            <para>Construct a shallow copy of map.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.SetEntries(System.Int32,System.UInt32@,System.Int32)">
            <summary>
            <para>Set an array of cells in this colormap. count is the number of colors that should be set, colors is the array of colors, and base is the starting index. The first element in colors is set at base in the colormap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.SetEntry(System.Int32,System.UInt32)">
            <summary>
            <para>Set cell at index idx in the colormap to color color.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.SetEntry(System.Int32,QtGui.QColor)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Set the cell with index idx in the colormap to color color.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.EntryRgb(System.Int32)">
            <summary>
            <para>Returns the QRgb value in the colorcell with index idx.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.EntryColor(System.Int32)">
            <summary>
            <para>Returns the QRgb value in the colorcell with index idx.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.Find(System.UInt32)">
            <summary>
            <para>Returns the index of the color color. If color is not in the map, -1 is returned.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLColormap.FindNearest(System.UInt32)">
            <summary>
            <para>Returns the index of the color that is the closest match to color color.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLColormap.IsEmpty">
            <summary>
            <para>Returns true if the colormap is empty or it is not in use by a QGLWidget; otherwise returns false.</para>
            <para>A colormap with no color values set is considered to be empty. For historical reasons, a colormap that has color values set but which is not in use by a QGLWidget is also considered empty.</para>
            <para>Compare size() with zero to determine if the colormap is empty regardless of whether it is in use by a QGLWidget or not.</para>
            <para>See also size().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLColormap.Size">
            <summary>
            <para>Returns the number of colorcells in the colormap.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFormat">
            <summary>
            <para>The QGLFormat class specifies the display format of an OpenGL rendering context.</para>
            </summary>
            <remarks>
            <para>A display format has several characteristics:</para>
            <para></para>
            <para>Double or single buffering.</para>
            <para>Depth buffer.</para>
            <para>RGBA or color index mode.</para>
            <para>Alpha channel.</para>
            <para>Accumulation buffer.</para>
            <para>Stencil buffer.</para>
            <para>Stereo buffers.</para>
            <para>Direct rendering.</para>
            <para>Presence of an overlay.</para>
            <para>Plane of an overlay.</para>
            <para>Multisample buffers.</para>
            <para></para>
            <para>You can also specify preferred bit depths for the color buffer, depth buffer, alpha buffer, accumulation buffer and the stencil buffer with the functions: setRedBufferSize(), setGreenBufferSize(), setBlueBufferSize(), setDepthBufferSize(), setAlphaBufferSize(), setAccumBufferSize() and setStencilBufferSize().</para>
            <para>Note that even if you specify that you prefer a 32 bit depth buffer (e.g. with setDepthBufferSize(32)), the format that is chosen may not have a 32 bit depth buffer, even if there is a format available with a 32 bit depth buffer. The main reason for this is how the system dependant picking algorithms work on the different platforms, and some format options may have higher precedence than others.</para>
            <para>You create and tell a QGLFormat object what rendering options you want from an OpenGL rendering context.</para>
            <para>OpenGL drivers or accelerated hardware may or may not support advanced features such as alpha channel or stereographic viewing. If you request some features that the driver/hardware does not provide when you create a QGLWidget, you will get a rendering context with the nearest subset of features.</para>
            <para>There are different ways to define the display characteristics of a rendering context. One is to create a QGLFormat and make it the default for the entire application:</para>
            <para>QGLFormat fmt;</para>
            <para>fmt.setAlpha(true);</para>
            <para>fmt.setStereo(true);</para>
            <para>QGLFormat::setDefaultFormat(fmt);</para>
            <para>Or you can specify the desired format when creating an object of your QGLWidget subclass:</para>
            <para>QGLFormat fmt;</para>
            <para>fmt.setDoubleBuffer(false);                 // single buffer</para>
            <para>fmt.setDirectRendering(false);              // software rendering</para>
            <para>MyGLWidget* myWidget = new MyGLWidget(fmt, ...);</para>
            <para>After the widget has been created, you can find out which of the requested features the system was able to provide:</para>
            <para>QGLFormat fmt;</para>
            <para>fmt.setOverlay(true);</para>
            <para>fmt.setStereo(true);</para>
            <para>MyGLWidget* myWidget = new MyGLWidget(fmt, ...);</para>
            <para>if (!myWidget-&gt;format().stereo()) {</para>
            <para>    // ok, goggles off</para>
            <para>    if (!myWidget-&gt;format().hasOverlay()) {</para>
            <para>        qFatal(&quot;Cool hardware required&quot;);</para>
            <para>    }</para>
            <para>}</para>
            <para>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</para>
            <para></para>
            <para></para>
            <para>See also QGLContext and QGLWidget.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLFormat.#ctor">
            <summary>
            <para>Constructs a QGLFormat object with the following default settings:</para>
            <para></para>
            <para>Double buffer: Enabled.</para>
            <para>Depth buffer: Enabled.</para>
            <para>RGBA: Enabled (i.e., color index disabled).</para>
            <para>Alpha channel: Disabled.</para>
            <para>Accumulator buffer: Disabled.</para>
            <para>Stencil buffer: Enabled.</para>
            <para>Stereo: Disabled.</para>
            <para>Direct rendering: Enabled.</para>
            <para>Overlay: Disabled.</para>
            <para>Plane: 0 (i.e., normal plane).</para>
            <para>Multisample buffers: Disabled.</para>
            <para></para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.#ctor(QtOpenGL.QGL.FormatOption,System.Int32)">
            <summary>
            <para>Creates a QGLFormat object that is a copy of the current defaultFormat().</para>
            <para>If options is not 0, the default format is modified by the specified format options. The options parameter should be QGL::FormatOption values OR'ed together.</para>
            <para>This constructor makes it easy to specify a certain desired format in classes derived from QGLWidget, for example:</para>
            <para>// The rendering in MyGLWidget depends on using</para>
            <para>// stencil buffer and alpha channel</para>
            <para>MyGLWidget::MyGLWidget(QWidget* parent)</para>
            <para>    : QGLWidget(QGLFormat(QGL::StencilBuffer | QGL::AlphaChannel), parent)</para>
            <para>{</para>
            <para>    if (!format().stencil())</para>
            <para>        qWarning(&quot;Could not get stencil buffer; results will be suboptimal&quot;);</para>
            <para>    if (!format().alpha())</para>
            <para>        qWarning(&quot;Could not get alpha channel; results will be suboptimal&quot;);</para>
            <para>    ...</para>
            <para>}</para>
            <para>Note that there are QGL::FormatOption values to turn format settings both on and off, e.g. QGL::DepthBuffer and QGL::NoDepthBuffer, QGL::DirectRendering and QGL::IndirectRendering, etc.</para>
            <para>The plane parameter defaults to 0 and is the plane which this format should be associated with. Not all OpenGL implementations supports overlay/underlay rendering planes.</para>
            <para>See also defaultFormat(), setOption(), and setPlane().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.#ctor(QtOpenGL.QGLFormat)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.SetOverlay(System.Boolean)">
            <summary>
            <para>If enable is true enables an overlay plane; otherwise disables the overlay plane.</para>
            <para>Enabling the overlay plane will cause QGLWidget to create an additional context in an overlay plane. See the QGLWidget documentation for further information.</para>
            <para>See also hasOverlay().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.SetOption(QtOpenGL.QGL.FormatOption)">
            <summary>
            <para>Sets the format option to opt.</para>
            <para>See also testOption().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.TestOption(QtOpenGL.QGL.FormatOption)">
            <summary>
            <para>Returns true if format option opt is set; otherwise returns false.</para>
            <para>See also setOption().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.SetVersion(System.Int32,System.Int32)">
            <summary>
            <para>Set the OpenGL version to the major and minor numbers. If a context compatible with the requested OpenGL version cannot be created, a context compatible with version 1.x is created instead.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also majorVersion() and minorVersion().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.OpenGLVersionFlags">
            <summary>
            <para>Identifies, at runtime, which OpenGL versions that are supported by the current platform.</para>
            <para>Note that if OpenGL version 1.5 is supported, its predecessors (i.e., version 1.4 and lower) are also supported. To identify the support of a particular feature, like multi texturing, test for the version in which the feature was first introduced (i.e., version 1.3 in the case of multi texturing) to adapt to the largest possible group of runtime platforms.</para>
            <para>This function needs a valid current OpenGL context to work; otherwise it will return OpenGL_Version_None.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also hasOpenGL() and hasOpenGLOverlays().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.FromSurfaceFormat(QtGui.QSurfaceFormat)">
            <summary>
            <para>Returns an OpenGL format for the window format specified by format.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.ToSurfaceFormat(QtOpenGL.QGLFormat)">
            <summary>
            <para>Returns a window format for the OpenGL format specified by format.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.op_Equality(QtOpenGL.QGLFormat,QtOpenGL.QGLFormat)">
            <summary>
            <para>Returns true if all the options of the two QGLFormat objects a and b are equal; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFormat.op_Inequality(QtOpenGL.QGLFormat,QtOpenGL.QGLFormat)">
            <summary>
            <para>Returns false if all the options of the two QGLFormat objects a and b are equal; otherwise returns true.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DepthBufferSize">
            <summary>
            <para>Returns the depth buffer size.</para>
            <para>See also depth(), setDepth(), and setDepthBufferSize().</para>
            <para></para>
            <para>Set the minimum depth buffer size to size.</para>
            <para>See also depthBufferSize(), setDepth(), and depth().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.AccumBufferSize">
            <summary>
            <para>Returns the accumulation buffer size.</para>
            <para>See also setAccumBufferSize(), accum(), and setAccum().</para>
            <para></para>
            <para>Set the preferred accumulation buffer size, where size is the bit depth for each RGBA component.</para>
            <para>See also accum(), setAccum(), and accumBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.RedBufferSize">
            <summary>
            <para>Returns the red buffer size.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also setRedBufferSize().</para>
            <para></para>
            <para>Set the preferred red buffer size to size.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also redBufferSize(), setGreenBufferSize(), setBlueBufferSize(), and setAlphaBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.GreenBufferSize">
            <summary>
            <para>Returns the green buffer size.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also setGreenBufferSize().</para>
            <para></para>
            <para>Set the preferred green buffer size to size.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also greenBufferSize(), setRedBufferSize(), setBlueBufferSize(), and setAlphaBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.BlueBufferSize">
            <summary>
            <para>Returns the blue buffer size.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also setBlueBufferSize().</para>
            <para></para>
            <para>Set the preferred blue buffer size to size.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also blueBufferSize(), setRedBufferSize(), setGreenBufferSize(), and setAlphaBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.AlphaBufferSize">
            <summary>
            <para>Returns the alpha buffer size.</para>
            <para>See also alpha(), setAlpha(), and setAlphaBufferSize().</para>
            <para></para>
            <para>Set the preferred alpha buffer size to size. This function implicitly enables the alpha channel.</para>
            <para>See also setRedBufferSize(), setGreenBufferSize(), and alphaBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.StencilBufferSize">
            <summary>
            <para>Returns the stencil buffer size.</para>
            <para>See also stencil(), setStencil(), and setStencilBufferSize().</para>
            <para></para>
            <para>Set the preferred stencil buffer size to size.</para>
            <para>See also stencilBufferSize(), setStencil(), and stencil().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.SampleBuffers">
            <summary>
            <para>Returns true if multisample buffer support is enabled; otherwise returns false.</para>
            <para>The multisample buffer is disabled by default.</para>
            <para>See also setSampleBuffers().</para>
            <para></para>
            <para>If enable is true, a GL context with multisample buffer support is picked; otherwise ignored.</para>
            <para>See also sampleBuffers(), setSamples(), and samples().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Samples">
            <summary>
            <para>Returns the number of samples per pixel when multisampling is enabled. By default, the highest number of samples that is available is used.</para>
            <para>See also setSampleBuffers(), sampleBuffers(), and setSamples().</para>
            <para></para>
            <para>Set the preferred number of samples per pixel when multisampling is enabled to numSamples. By default, the highest number of samples available is used.</para>
            <para>See also setSampleBuffers(), sampleBuffers(), and samples().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.SwapInterval">
            <summary>
            <para>Returns the currently set swap interval. -1 is returned if setting the swap interval isn't supported in the system GL implementation.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also setSwapInterval().</para>
            <para></para>
            <para>Set the preferred swap interval. This can be used to sync the GL drawing into a system window to the vertical refresh of the screen. Setting an interval value of 0 will turn the vertical refresh syncing off, any value higher than 0 will turn the vertical syncing on.</para>
            <para>Under Windows and under X11, where the WGL_EXT_swap_control and GLX_SGI_video_sync extensions are used, the interval parameter can be used to set the minimum number of video frames that are displayed before a buffer swap will occur. In effect, setting the interval to 10, means there will be 10 vertical retraces between every buffer swap.</para>
            <para>Under Windows the WGL_EXT_swap_control extension has to be present, and under X11 the GLX_SGI_video_sync extension has to be present.</para>
            <para>This function was introduced in  Qt 4.2.</para>
            <para>See also swapInterval().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DoubleBuffer">
            <summary>
            <para>Returns true if double buffering is enabled; otherwise returns false. Double buffering is enabled by default.</para>
            <para>See also setDoubleBuffer().</para>
            <para></para>
            <para>If enable is true sets double buffering; otherwise sets single buffering.</para>
            <para>Double buffering is enabled by default.</para>
            <para>Double buffering is a technique where graphics are rendered on an off-screen buffer and not directly to the screen. When the drawing has been completed, the program calls a swapBuffers() function to exchange the screen contents with the buffer. The result is flicker-free drawing and often better performance.</para>
            <para>Note that single buffered contexts are currently not supported with EGL.</para>
            <para>See also doubleBuffer(), QGLContext::swapBuffers(), and QGLWidget::swapBuffers().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Depth">
            <summary>
            <para>Returns true if the depth buffer is enabled; otherwise returns false. The depth buffer is enabled by default.</para>
            <para>See also setDepth() and setDepthBufferSize().</para>
            <para></para>
            <para>If enable is true enables the depth buffer; otherwise disables the depth buffer.</para>
            <para>The depth buffer is enabled by default.</para>
            <para>The purpose of a depth buffer (or Z-buffering) is to remove hidden surfaces. Pixels are assigned Z values based on the distance to the viewer. A pixel with a high Z value is closer to the viewer than a pixel with a low Z value. This information is used to decide whether to draw a pixel or not.</para>
            <para>See also depth() and setDepthBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Rgba">
            <summary>
            <para>Returns true if RGBA color mode is set. Returns false if color index mode is set. The default color mode is RGBA.</para>
            <para>See also setRgba().</para>
            <para></para>
            <para>If enable is true sets RGBA mode. If enable is false sets color index mode.</para>
            <para>The default color mode is RGBA.</para>
            <para>RGBA is the preferred mode for most OpenGL applications. In RGBA color mode you specify colors as red + green + blue + alpha quadruplets.</para>
            <para>In color index mode you specify an index into a color lookup table.</para>
            <para>See also rgba().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Alpha">
            <summary>
            <para>Returns true if the alpha buffer in the framebuffer is enabled; otherwise returns false. The alpha buffer is disabled by default.</para>
            <para>See also setAlpha() and setAlphaBufferSize().</para>
            <para></para>
            <para>If enable is true enables the alpha buffer; otherwise disables the alpha buffer.</para>
            <para>The alpha buffer is disabled by default.</para>
            <para>The alpha buffer is typically used for implementing transparency or translucency. The A in RGBA specifies the transparency of a pixel.</para>
            <para>See also alpha() and setAlphaBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Accum">
            <summary>
            <para>Returns true if the accumulation buffer is enabled; otherwise returns false. The accumulation buffer is disabled by default.</para>
            <para>See also setAccum() and setAccumBufferSize().</para>
            <para></para>
            <para>If enable is true enables the accumulation buffer; otherwise disables the accumulation buffer.</para>
            <para>The accumulation buffer is disabled by default.</para>
            <para>The accumulation buffer is used to create blur effects and multiple exposures.</para>
            <para>See also accum() and setAccumBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Stencil">
            <summary>
            <para>Returns true if the stencil buffer is enabled; otherwise returns false. The stencil buffer is enabled by default.</para>
            <para>See also setStencil() and setStencilBufferSize().</para>
            <para></para>
            <para>If enable is true enables the stencil buffer; otherwise disables the stencil buffer.</para>
            <para>The stencil buffer is enabled by default.</para>
            <para>The stencil buffer masks certain parts of the drawing area so that masked parts are not drawn on.</para>
            <para>See also stencil() and setStencilBufferSize().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Stereo">
            <summary>
            <para>Returns true if stereo buffering is enabled; otherwise returns false. Stereo buffering is disabled by default.</para>
            <para>See also setStereo().</para>
            <para></para>
            <para>If enable is true enables stereo buffering; otherwise disables stereo buffering.</para>
            <para>Stereo buffering is disabled by default.</para>
            <para>Stereo buffering provides extra color buffers to generate left-eye and right-eye images.</para>
            <para>See also stereo().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DirectRendering">
            <summary>
            <para>Returns true if direct rendering is enabled; otherwise returns false.</para>
            <para>Direct rendering is enabled by default.</para>
            <para>See also setDirectRendering().</para>
            <para></para>
            <para>If enable is true enables direct rendering; otherwise disables direct rendering.</para>
            <para>Direct rendering is enabled by default.</para>
            <para>Enabling this option will make OpenGL bypass the underlying window system and render directly from hardware to the screen, if this is supported by the system.</para>
            <para>See also directRendering().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Plane">
            <summary>
            <para>Returns the plane of this format. The default for normal formats is 0, which means the normal plane. The default for overlay formats is 1, which is the first overlay plane.</para>
            <para>See also setPlane() and defaultOverlayFormat().</para>
            <para></para>
            <para>Sets the requested plane to plane. 0 is the normal plane, 1 is the first overlay plane, 2 is the second overlay plane, etc.; -1, -2, etc. are underlay planes.</para>
            <para>Note that in contrast to other format specifications, the plane specifications will be matched exactly. This means that if you specify a plane that the underlying OpenGL system cannot provide, an invalid QGLWidget will be created.</para>
            <para>See also plane().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DefaultFormat">
            <summary>
            <para>Returns the default QGLFormat for the application. All QGLWidget objects that are created use this format unless another format is specified, e.g. when they are constructed.</para>
            <para>If no special default format has been set using setDefaultFormat(), the default format is the same as that created with QGLFormat().</para>
            <para>See also setDefaultFormat().</para>
            <para></para>
            <para>Sets a new default QGLFormat for the application to f. For example, to set single buffering as the default instead of double buffering, your main() might contain code like this:</para>
            <para>QApplication a(argc, argv);</para>
            <para>QGLFormat f;</para>
            <para>f.setDoubleBuffer(false);</para>
            <para>QGLFormat::setDefaultFormat(f);</para>
            <para>See also defaultFormat().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.DefaultOverlayFormat">
            <summary>
            <para>Returns the default QGLFormat for overlay contexts.</para>
            <para>The default overlay format is:</para>
            <para></para>
            <para>Double buffer: Disabled.</para>
            <para>Depth buffer: Disabled.</para>
            <para>RGBA: Disabled (i.e., color index enabled).</para>
            <para>Alpha channel: Disabled.</para>
            <para>Accumulator buffer: Disabled.</para>
            <para>Stencil buffer: Disabled.</para>
            <para>Stereo: Disabled.</para>
            <para>Direct rendering: Enabled.</para>
            <para>Overlay: Disabled.</para>
            <para>Multisample buffers: Disabled.</para>
            <para>Plane: 1 (i.e., first overlay plane).</para>
            <para></para>
            <para>See also setDefaultOverlayFormat() and setDefaultFormat().</para>
            <para></para>
            <para>Sets a new default QGLFormat for overlay contexts to f. This format is used whenever a QGLWidget is created with a format that hasOverlay() enabled.</para>
            <para>For example, to get a double buffered overlay context (if available), use code like this:</para>
            <para>QGLFormat f = QGLFormat::defaultOverlayFormat();</para>
            <para>f.setDoubleBuffer(true);</para>
            <para>QGLFormat::setDefaultOverlayFormat(f);</para>
            <para>As usual, you can find out after widget creation whether the underlying OpenGL system was able to provide the requested specification:</para>
            <para>// ...continued from above</para>
            <para>MyGLWidget* myWidget = new MyGLWidget(QGLFormat(QGL::HasOverlay), ...);</para>
            <para>if (myWidget-&gt;format().hasOverlay()) {</para>
            <para>    // Yes, we got an overlay, let's check _its_ format:</para>
            <para>    QGLContext* olContext = myWidget-&gt;overlayContext();</para>
            <para>    if (olContext-&gt;format().doubleBuffer())</para>
            <para>        ; // yes, we got a double buffered overlay</para>
            <para>    else</para>
            <para>        ; // no, only single buffered overlays are available</para>
            <para>}</para>
            <para>See also defaultOverlayFormat().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.Profile">
            <summary>
            <para>Returns the OpenGL context profile.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setProfile().</para>
            <para></para>
            <para>Set the OpenGL context profile to profile. The profile is ignored if the requested OpenGL version is less than 3.2.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also profile().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.HasOverlay">
            <summary>
            <para>Returns true if overlay plane is enabled; otherwise returns false.</para>
            <para>Overlay is disabled by default.</para>
            <para>See also setOverlay().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.HasOpenGL">
            <summary>
            <para>Returns true if the window system has any OpenGL support; otherwise returns false.</para>
            <para>Warning: This function must not be called until the QApplication object has been created.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.HasOpenGLOverlays">
            <summary>
            <para>Returns true if the window system supports OpenGL overlays; otherwise returns false.</para>
            <para>Warning: This function must not be called until the QApplication object has been created.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.MajorVersion">
            <summary>
            <para>Returns the OpenGL major version.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setVersion() and minorVersion().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFormat.MinorVersion">
            <summary>
            <para>Returns the OpenGL minor version.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setVersion() and majorVersion().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFormat.OpenGLContextProfile">
            <summary>
            <para>This enum describes the OpenGL context profiles that can be specified for contexts implementing OpenGL version 3.2 or higher. These profiles are different from OpenGL ES profiles.</para>
            <para>This enum was introduced or modified in  Qt 4.7.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLContextProfile.NoProfile">
            <summary>OpenGL version is lower than 3.2.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLContextProfile.CoreProfile">
            <summary>Functionality deprecated in OpenGL version 3.0 is not available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLContextProfile.CompatibilityProfile">
            <summary>Functionality from earlier OpenGL versions is available.</summary>
        </member>
        <member name="T:QtOpenGL.QGLFormat.OpenGLVersionFlag">
            <summary>
            <para>This enum describes the various OpenGL versions that are recognized by Qt. Use the QGLFormat::openGLVersionFlags() function to identify which versions that are supported at runtime.</para>
            <para>See also http://www.opengl.org for more information about the different revisions of OpenGL.</para>
            <para>This enum was introduced or modified in  Qt 4.2.</para>
            <para>The OpenGLVersionFlags type is a typedef for QFlags&lt;OpenGLVersionFlag&gt;. It stores an OR combination of OpenGLVersionFlag values.</para>
            <para>See also openGLVersionFlags().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_None">
            <summary>If no OpenGL is present or if no OpenGL context is current.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_1">
            <summary>OpenGL version 1.1 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_2">
            <summary>OpenGL version 1.2 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_3">
            <summary>OpenGL version 1.3 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_4">
            <summary>OpenGL version 1.4 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_1_5">
            <summary>OpenGL version 1.5 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_2_0">
            <summary>OpenGL version 2.0 or higher is present. Note that version 2.0 supports all the functionality of version 1.5.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_2_1">
            <summary>OpenGL version 2.1 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_Common_Version_1_0">
            <summary>OpenGL ES version 1.0 Common or higher is present. The Common profile supports all the features of Common Lite.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_CommonLite_Version_1_0">
            <summary>OpenGL ES version 1.0 Common Lite or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_Common_Version_1_1">
            <summary>OpenGL ES version 1.1 Common or higher is present. The Common profile supports all the features of Common Lite.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_CommonLite_Version_1_1">
            <summary>OpenGL ES version 1.1 Common Lite or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_ES_Version_2_0">
            <summary>OpenGL ES version 2.0 or higher is present. Note that OpenGL ES version 2.0 does not support all the features of OpenGL ES 1.x. So if OpenGL_ES_Version_2_0 is returned, none of the ES 1.x flags are returned.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_0">
            <summary>OpenGL version 3.0 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_1">
            <summary>OpenGL version 3.1 or higher is present. Note that OpenGL version 3.1 or higher does not necessarily support all the features of version 3.0 and lower.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_2">
            <summary>OpenGL version 3.2 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_3_3">
            <summary>OpenGL version 3.3 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_4_0">
            <summary>OpenGL version 4.0 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_4_1">
            <summary>OpenGL version 4.1 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_4_2">
            <summary>OpenGL version 4.2 or higher is present.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFormat.OpenGLVersionFlag.OpenGL_Version_4_3">
            <summary>OpenGL version 4.3 or higher is present.</summary>
        </member>
        <member name="T:QtOpenGL.QGLContext">
            <summary>
            <para>The QGLContext class encapsulates an OpenGL rendering context.</para>
            </summary>
            <remarks>
            <para>An OpenGL rendering context is a complete set of OpenGL state variables. The rendering context's format is set in the constructor, but it can also be set later with setFormat(). The format options that are actually set are returned by format(); the options you asked for are returned by requestedFormat(). Note that after a QGLContext object has been constructed, the actual OpenGL context must be created by explicitly calling the create() function. The makeCurrent() function makes this context the current rendering context. You can make no context current using doneCurrent(). The reset() function will reset the context and make it invalid.</para>
            <para>You can examine properties of the context with, e.g. isValid(), isSharing(), initialized(), windowCreated() and overlayTransparentColor().</para>
            <para>If you're using double buffering you can swap the screen contents with the off-screen buffer using swapBuffers().</para>
            <para>Please note that QGLContext is not thread safe.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLContext.#ctor(QtOpenGL.QGLFormat,QtGui.IQPaintDevice)">
            <summary>
            <para>Constructs an OpenGL context for the given paint device, which can be a widget or a pixmap. The format specifies several display options for the context.</para>
            <para>If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</para>
            <para>Note that after a QGLContext object has been constructed, create() must be called explicitly to create the actual OpenGL context. The context will be invalid if it was not possible to obtain a GL context at all.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.#ctor(QtOpenGL.QGLFormat)">
            <summary>
            <para>Constructs an OpenGL context with the given format which specifies several display options for the context.</para>
            <para>If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</para>
            <para>Note that after a QGLContext object has been constructed, create() must be called explicitly to create the actual OpenGL context. The context will be invalid if it was not possible to obtain a GL context at all.</para>
            <para>See also format() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.Create(QtOpenGL.QGLContext)">
            <summary>
            <para>Creates the GL context. Returns true if it was successful in creating a valid GL rendering context on the paint device specified in the constructor; otherwise returns false (i.e. the context is invalid).</para>
            <para>If the OpenGL implementation on your system does not support the requested version of OpenGL context, then QGLContext will try to create the closest matching version. The actual created context properties can be queried using the QGLFormat returned by the format() function. For example, if you request a context that supports OpenGL 4.3 Core profile but the driver and/or hardware only supports version 3.2 Core profile contexts then you will get a 3.2 Core profile context.</para>
            <para>After successful creation, format() returns the set of features of the created GL rendering context.</para>
            <para>If shareContext points to a valid QGLContext, this method will try to establish OpenGL display list and texture object sharing between this context and the shareContext. Note that this may fail if the two contexts have different formats. Use isSharing() to see if sharing is in effect.</para>
            <para>Warning: Implementation note: initialization of C++ class members usually takes place in the class constructor. QGLContext is an exception because it must be simple to customize. The virtual functions chooseContext() (and chooseVisual() for X11) can be reimplemented in a subclass to select a particular context. The problem is that virtual functions are not properly called during construction (even though this is correct C++) because C++ constructs class hierarchies from the bottom up. For this reason we need a create() function.</para>
            <para>See also chooseContext(), format(), and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.Reset">
            <summary>
            <para>Resets the context and makes it invalid.</para>
            <para>See also create() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.MoveToThread(QtCore.QThread)">
            <summary>
            <para>Moves the QGLContext to the given thread.</para>
            <para>Enables calling swapBuffers() and makeCurrent() on the context in the given thread.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.MakeCurrent">
            <summary>
            <para>Makes this context the current OpenGL rendering context. All GL functions you call operate on this context until another context is made current.</para>
            <para>In some very rare cases the underlying call may fail. If this occurs an error message is output to stderr.</para>
            <para>If you call this from a thread other than the main UI thread, make sure you've first pushed the context to the relevant thread from the UI thread using moveToThread().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DoneCurrent">
            <summary>
            <para>Makes no GL context the current context. Normally, you do not need to call this function; QGLContext calls it as necessary.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.SwapBuffers">
            <summary>
            <para>Call this to finish a frame of OpenGL rendering, and make sure to call makeCurrent() again before you begin a new frame.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QImage,System.UInt32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
            <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
            <para>The target parameter specifies the texture target. The default target is GL_TEXTURE_2D.</para>
            <para>The format parameter sets the internal format for the texture. The default format is GL_RGBA.</para>
            <para>The binding options are a set of options used to decide how to bind the texture to the context.</para>
            <para>The texture that is generated is cached, so multiple calls to bindTexture() with the same QImage will return the same texture id.</para>
            <para>Note that we assume default values for the glPixelStore() and glPixelTransfer() parameters.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QPixmap,System.UInt32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Generates and binds a 2D GL texture to the current context, based on pixmap.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QImage,System.UInt32,System.Int32)">
            <summary>
            <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
            <para>This is an overloaded function.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(QtGui.QPixmap,System.UInt32,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Generates and binds a 2D GL texture based on pixmap.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.BindTexture(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Reads the compressed texture file fileName and generates a 2D GL texture from it.</para>
            <para>This function can load DirectDrawSurface (DDS) textures in the DXT1, DXT3 and DXT5 DDS formats if the GL_ARB_texture_compression and GL_EXT_texture_compression_s3tc extensions are supported.</para>
            <para>Since 4.6.1, textures in the ETC1 format can be loaded if the GL_OES_compressed_ETC1_RGB8_texture extension is supported and the ETC1 texture has been encapsulated in the PVR container format. Also, textures in the PVRTC2 and PVRTC4 formats can be loaded if the GL_IMG_texture_compression_pvrtc extension is supported.</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DeleteTexture(System.UInt32)">
            <summary>
            <para>Removes the texture identified by id from the texture cache, and calls glDeleteTextures() to delete the texture from the context.</para>
            <para>See also bindTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DrawTexture(QtCore.QRectF,System.UInt32,System.UInt32)">
            <summary>
            <para>This function supports the following use cases:</para>
            <para></para>
            <para>On OpenGL and OpenGL ES 1.x it draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
            <para>On OpenGL and OpenGL ES 2.x, if a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type QPaintEngine::OpenGL2, the function will draw the given texture, textureId, to the given target rectangle, target, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case, and that this is the only supported use case under OpenGL ES 2.x.</para>
            <para></para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.DrawTexture(QtCore.QPointF,System.UInt32,System.UInt32)">
            <summary>
            <para>This function supports the following use cases:</para>
            <para></para>
            <para>By default it draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget should be a 2D texture target.</para>
            <para>If a painter is active, not inside a beginNativePainting / endNativePainting block, and uses the engine with type QPaintEngine::OpenGL2, the function will draw the given texture, textureId, at the given point, respecting the current painter state. This will let you draw a texture with the clip, transform, render hints, and composition mode set by the painter. Note that the texture target needs to be GL_TEXTURE_2D for this use case.</para>
            <para></para>
            <para>Note: This function is not supported under any version of OpenGL ES.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.GetProcAddress(System.String)">
            <summary>
            <para>Returns a function pointer to the GL extension function passed in proc. 0 is returned if a pointer to the function could not be obtained.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.ChooseContext(QtOpenGL.QGLContext)">
            <summary>
            <para>This semi-internal function is called by create(). It creates a system-dependent OpenGL handle that matches the format() of shareContext as closely as possible, returning true if successful or false if a suitable handle could not be found.</para>
            <para>On Windows, it calls the virtual function choosePixelFormat(), which finds a matching pixel format identifier. On X11, it calls the virtual function chooseVisual() which finds an appropriate X visual. On other platforms it may work differently.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.AreSharing(QtOpenGL.QGLContext,QtOpenGL.QGLContext)">
            <summary>
            <para>Returns true if context1 and context2 are sharing their GL resources such as textures, shader programs, etc; otherwise returns false.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLContext.FromOpenGLContext(QtGui.QOpenGLContext)">
            <summary>
            <para>Returns an OpenGL context for the window context specified by the context parameter.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Format">
            <summary>
            <para>Returns the frame buffer format that was obtained (this may be a subset of what was requested).</para>
            <para>See also setFormat() and requestedFormat().</para>
            <para></para>
            <para>Sets a format for this context. The context is reset.</para>
            <para>Call create() to create a new GL context that tries to match the new format.</para>
            <para>QGLContext *cx;</para>
            <para>//  ...</para>
            <para>QGLFormat f;</para>
            <para>f.setStereo(true);</para>
            <para>cx-&gt;setFormat(f);</para>
            <para>if (!cx-&gt;create())</para>
            <para>    exit(); // no OpenGL support, or cannot render on the specified paintdevice</para>
            <para>if (!cx-&gt;format().stereo())</para>
            <para>    exit(); // could not create stereo context</para>
            <para>See also format(), reset(), and create().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.TextureCacheLimit">
            <summary>
            <para>Returns the current texture cache limit in kilobytes.</para>
            <para>See also setTextureCacheLimit().</para>
            <para></para>
            <para>This function sets the limit for the texture cache to size, expressed in kilobytes.</para>
            <para>By default, the cache limit is approximately 64 MB.</para>
            <para>See also textureCacheLimit().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.WindowCreated">
            <summary>
            <para>Returns true if a window has been created for this context; otherwise returns false.</para>
            <para>See also setWindowCreated().</para>
            <para></para>
            <para>If on is true the context has had a window created for it. If on is false no window has been created for the context.</para>
            <para>See also windowCreated().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Initialized">
            <summary>
            <para>Returns true if this context has been initialized, i.e. if QGLWidget::initializeGL() has been performed on it; otherwise returns false.</para>
            <para>See also setInitialized().</para>
            <para></para>
            <para>If on is true the context has been initialized, i.e. QGLContext::setInitialized() has been called on it. If on is false the context has not been initialized.</para>
            <para>See also initialized().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Valid">
            <summary>
            <para>Returns true if a GL rendering context has been successfully created; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Device">
            <summary>
            <para>Returns the paint device set for this context.</para>
            <para>See also QGLContext::QGLContext().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.IsSharing">
            <summary>
            <para>Returns true if this context is sharing its GL context with another QGLContext, otherwise false is returned. Note that context sharing might not be supported between contexts with different formats.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.RequestedFormat">
            <summary>
            <para>Returns the frame buffer format that was originally requested in the constructor or setFormat().</para>
            <para>See also format().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.Functions">
            <summary>
            <para>Returns a QGLFunctions object that is initialized for this context.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.OverlayTransparentColor">
            <summary>
            <para>If this context is a valid context in an overlay plane, returns the plane's transparent color. Otherwise returns an invalid color.</para>
            <para>The returned color's pixel value is the index of the transparent color in the colormap of the overlay plane. (Naturally, the color's RGB values are meaningless.)</para>
            <para>The returned QColor object will generally work as expected only when passed as the argument to QGLWidget::qglColor() or QGLWidget::qglClearColor(). Under certain circumstances it can also be used to draw transparent graphics with a QPainter.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.CurrentContext">
            <summary>
            <para>Returns the current context, i.e. the context to which any OpenGL commands will currently be directed. Returns 0 if no context is current.</para>
            <para>See also makeCurrent().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.ContextHandle">
            <summary>
            <para>Returns the OpenGL context handle.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLContext.DeviceIsPixmap">
            <summary>
            <para>Returns true if the paint device of this context is a pixmap; otherwise returns false.</para>
            <para>Since Qt 5 the paint device is never actually a pixmap. renderPixmap() is however still simulated using framebuffer objects and readbacks, and this function will return true in this case.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLContext.BindOption">
            <summary>
            <para>A set of options to decide how to bind a texture using bindTexture().</para>
            <para>Used by x11 from pixmap to choose whether or not it can bind the pixmap upside down or not.</para>
            <para>Used by paint engines to indicate that the pixmap should be memory managed along side with the pixmap/image that it stems from, e.g. installing destruction hooks in them.</para>
            <para>Used by paint engines on some platforms to indicate that the pixmap or image texture is possibly cached only temporarily and must be destroyed immediately after the use.</para>
            <para>This enum was introduced or modified in  Qt 4.6.</para>
            <para>The BindOptions type is a typedef for QFlags&lt;BindOption&gt;. It stores an OR combination of BindOption values.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.NoBindOption">
            <summary>Don't do anything, pass the texture straight through.</summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.InvertedYBindOption">
            <summary>Specifies that the texture should be flipped over the X axis so that the texture coordinate 0,0 corresponds to the top left corner. Inverting the texture implies a deep copy prior to upload.</summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.MipmapBindOption">
            <summary>Specifies that bindTexture() should try to generate mipmaps. If the GL implementation supports the GL_SGIS_generate_mipmap extension, mipmaps will be automatically generated for the texture. Mipmap generation is only supported for the GL_TEXTURE_2D target.</summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.PremultipliedAlphaBindOption">
            <summary>Specifies that the image should be uploaded with premultiplied alpha and does a conversion accordingly.</summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.LinearFilteringBindOption">
            <summary>Specifies that the texture filtering should be set to GL_LINEAR. Default is GL_NEAREST. If mipmap is also enabled, filtering will be set to GL_LINEAR_MIPMAP_LINEAR.</summary>
        </member>
        <member name="F:QtOpenGL.QGLContext.BindOption.DefaultBindOption">
            <summary>In Qt 4.5 and earlier, bindTexture() would mirror the image and automatically generate mipmaps. This option helps preserve this default behavior.</summary>
        </member>
        <member name="T:QtOpenGL.QGLWidget">
            <summary>
            <para>The QGLWidget class is a widget for rendering OpenGL graphics.</para>
            </summary>
            <remarks>
            <para>QGLWidget provides functionality for displaying OpenGL graphics integrated into a Qt application. It is very simple to use. You inherit from it and use the subclass like any other QWidget, except that you have the choice between using QPainter and standard OpenGL rendering commands.</para>
            <para>Note: This class is part of the legacy Qt OpenGL module and, like the other QGL classes, should be avoided in the new applications. Instead, starting from Qt 5.4, prefer using QOpenGLWidget and the QOpenGL classes.</para>
            <para>QGLWidget provides three convenient virtual functions that you can reimplement in your subclass to perform the typical OpenGL tasks:</para>
            <para></para>
            <para>paintGL() - Renders the OpenGL scene. Gets called whenever the widget needs to be updated.</para>
            <para>resizeGL() - Sets up the OpenGL viewport, projection, etc. Gets called whenever the widget has been resized (and also when it is shown for the first time because all newly created widgets get a resize event automatically).</para>
            <para>initializeGL() - Sets up the OpenGL rendering context, defines display lists, etc. Gets called once before the first time resizeGL() or paintGL() is called.</para>
            <para></para>
            <para>Here is a rough outline of how a QGLWidget subclass might look:</para>
            <para>class MyGLDrawer : public QGLWidget</para>
            <para>{</para>
            <para>    Q_OBJECT        // must include this if you use Qt signals/slots</para>
            <para></para>
            <para>public:</para>
            <para>    MyGLDrawer(QWidget *parent)</para>
            <para>        : QGLWidget(parent) {}</para>
            <para></para>
            <para>protected:</para>
            <para></para>
            <para>    void initializeGL()</para>
            <para>    {</para>
            <para>        // Set up the rendering context, define display lists etc.:</para>
            <para>        ...</para>
            <para>        glClearColor(0.0, 0.0, 0.0, 0.0);</para>
            <para>        glEnable(GL_DEPTH_TEST);</para>
            <para>        ...</para>
            <para>    }</para>
            <para></para>
            <para>    void resizeGL(int w, int h)</para>
            <para>    {</para>
            <para>        // setup viewport, projection etc.:</para>
            <para>        glViewport(0, 0, (GLint)w, (GLint)h);</para>
            <para>        ...</para>
            <para>        glFrustum(...);</para>
            <para>        ...</para>
            <para>    }</para>
            <para></para>
            <para>    void paintGL()</para>
            <para>    {</para>
            <para>        // draw the scene:</para>
            <para>        ...</para>
            <para>        glRotatef(...);</para>
            <para>        glMaterialfv(...);</para>
            <para>        glBegin(GL_QUADS);</para>
            <para>        glVertex3f(...);</para>
            <para>        glVertex3f(...);</para>
            <para>        ...</para>
            <para>        glEnd();</para>
            <para>        ...</para>
            <para>    }</para>
            <para></para>
            <para>};</para>
            <para>If you need to trigger a repaint from places other than paintGL() (a typical example is when using timers to animate scenes), you should call the widget's updateGL() function.</para>
            <para>Your widget's OpenGL rendering context is made current when paintGL(), resizeGL(), or initializeGL() is called. If you need to call the standard OpenGL API functions from other places (e.g. in your widget's constructor or in your own paint functions), you must call makeCurrent() first.</para>
            <para>QGLWidget provides functions for requesting a new display format and you can also create widgets with customized rendering contexts.</para>
            <para>You can also share OpenGL display lists between QGLWidget objects (see the documentation of the QGLWidget constructors for details).</para>
            <para>Note that under Windows, the QGLContext belonging to a QGLWidget has to be recreated when the QGLWidget is reparented. This is necessary due to limitations on the Windows platform. This will most likely cause problems for users that have subclassed and installed their own QGLContext on a QGLWidget. It is possible to work around this issue by putting the QGLWidget inside a dummy widget and then reparenting the dummy widget, instead of the QGLWidget. This will side-step the issue altogether, and is what we recommend for users that need this kind of functionality.</para>
            <para>On OS X, when Qt is built with Cocoa support, a QGLWidget can't have any sibling widgets placed ontop of itself. This is due to limitations in the Cocoa API and is not supported by Apple.</para>
            <para></para>
            <para>Overlays</para>
            <para>The QGLWidget creates a GL overlay context in addition to the normal context if overlays are supported by the underlying system.</para>
            <para>If you want to use overlays, you specify it in the format. (Note: Overlay must be requested in the format passed to the QGLWidget constructor.) Your GL widget should also implement some or all of these virtual methods:</para>
            <para></para>
            <para>paintOverlayGL()</para>
            <para>resizeOverlayGL()</para>
            <para>initializeOverlayGL()</para>
            <para></para>
            <para>These methods work in the same way as the normal paintGL() etc. functions, except that they will be called when the overlay context is made current. You can explicitly make the overlay context current by using makeOverlayCurrent(), and you can access the overlay context directly (e.g. to ask for its transparent color) by calling overlayContext().</para>
            <para>On X servers in which the default visual is in an overlay plane, non-GL Qt windows can also be used for overlays.</para>
            <para></para>
            <para>Painting Techniques</para>
            <para>As described above, subclass QGLWidget to render pure 3D content in the following way:</para>
            <para></para>
            <para>Reimplement the QGLWidget::initializeGL() and QGLWidget::resizeGL() to set up the OpenGL state and provide a perspective transformation.</para>
            <para>Reimplement QGLWidget::paintGL() to paint the 3D scene, calling only OpenGL functions to draw on the widget.</para>
            <para></para>
            <para>It is also possible to draw 2D graphics onto a QGLWidget subclass, it is necessary to reimplement QGLWidget::paintEvent() and do the following:</para>
            <para></para>
            <para>Construct a QPainter object.</para>
            <para>Initialize it for use on the widget with the QPainter::begin() function.</para>
            <para>Draw primitives using QPainter's member functions.</para>
            <para>Call QPainter::end() to finish painting.</para>
            <para></para>
            <para></para>
            <para>Threading</para>
            <para>As of Qt version 4.8, support for doing threaded GL rendering has been improved. There are three scenarios that we currently support:</para>
            <para></para>
            <para>1. Buffer swapping in a thread.Swapping buffers in a double buffered context may be a synchronous, locking call that may be a costly operation in some GL implementations. Especially so on embedded devices. It's not optimal to have the CPU idling while the GPU is doing a buffer swap. In those cases it is possible to do the rendering in the main thread and do the actual buffer swap in a separate thread. This can be done with the following steps:</para>
            <para>1. Call doneCurrent() in the main thread when the rendering is finished.</para>
            <para>2. Call QGLContext::moveToThread(swapThread) to transfer ownership of the context to the swapping thread.</para>
            <para>3. Notify the swapping thread that it can grab the context.</para>
            <para>4. Make the rendering context current in the swapping thread with makeCurrent() and then call swapBuffers().</para>
            <para>5. Call doneCurrent() in the swapping thread.</para>
            <para>6. Call QGLContext::moveToThread(qApp-&gt;thread()) and notify the main thread that swapping is done.</para>
            <para>Doing this will free up the main thread so that it can continue with, for example, handling UI events or network requests. Even if there is a context swap involved, it may be preferable compared to having the main thread wait while the GPU finishes the swap operation. Note that this is highly implementation dependent.</para>
            <para></para>
            <para>2. Texture uploading in a thread.Doing texture uploads in a thread may be very useful for applications handling large amounts of images that needs to be displayed, like for instance a photo gallery application. This is supported in Qt through the existing bindTexture() API. A simple way of doing this is to create two sharing QGLWidgets. One is made current in the main GUI thread, while the other is made current in the texture upload thread. The widget in the uploading thread is never shown, it is only used for sharing textures with the main thread. For each texture that is bound via bindTexture(), notify the main thread so that it can start using the texture.</para>
            <para></para>
            <para>3. Using QPainter to draw into a QGLWidget in a thread.In Qt 4.8, it is possible to draw into a QGLWidget using a QPainter in a separate thread. Note that this is also possible for QGLPixelBuffers and QGLFramebufferObjects. Since this is only supported in the GL 2 paint engine, OpenGL 2.0 or OpenGL ES 2.0 is required.</para>
            <para>QGLWidgets can only be created in the main GUI thread. This means a call to doneCurrent() is necessary to release the GL context from the main thread, before the widget can be drawn into by another thread. You then need to call QGLContext::moveToThread() to transfer ownership of the context to the thread in which you want to make it current. Also, the main GUI thread will dispatch resize and paint events to a QGLWidget when the widget is resized, or parts of it becomes exposed or needs redrawing. It is therefore necessary to handle those events because the default implementations inside QGLWidget will try to make the QGLWidget's context current, which again will interfere with any threads rendering into the widget. Reimplement QGLWidget::paintEvent() and QGLWidget::resizeEvent() to notify the rendering thread that a resize or update is necessary, and be careful not to call the base class implementation. If you are rendering an animation, it might not be necessary to handle the paint event at all since the rendering thread is doing regular updates. Then it would be enough to reimplement QGLWidget::paintEvent() to do nothing.</para>
            <para></para>
            <para></para>
            <para>As a general rule when doing threaded rendering: be aware that binding and releasing contexts in different threads have to be synchronized by the user. A GL rendering context can only be current in one thread at any time. If you try to open a QPainter on a QGLWidget and the widget's rendering context is current in another thread, it will fail.</para>
            <para>In addition to this, rendering using raw GL calls in a separate thread is supported.</para>
            <para>OpenGL is a trademark of Silicon Graphics, Inc. in the United States and other countries.</para>
            <para></para>
            <para>See also QOpenGLWidget and QGLPixelBuffer.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLWidget.#ctor(QtWidgets.QWidget,QtOpenGL.QGLWidget,QtCore.Qt.WindowType)">
            <summary>
            <para>Constructs an OpenGL widget with a parent widget.</para>
            <para>The default format is used. The widget will be invalid if the system has no OpenGL support.</para>
            <para>The parent and widget flag, f, arguments are passed to the QWidget constructor.</para>
            <para>If shareWidget is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with shareWidget. But if shareWidget and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</para>
            <para>The initialization of OpenGL rendering state, etc. should be done by overriding the initializeGL() function, rather than in the constructor of your QGLWidget subclass.</para>
            <para>See also QGLFormat::defaultFormat() and Textures Example.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.#ctor(QtOpenGL.QGLContext,QtWidgets.QWidget,QtOpenGL.QGLWidget,QtCore.Qt.WindowType)">
            <summary>
            <para>Constructs an OpenGL widget with parent parent.</para>
            <para>The context argument is a pointer to the QGLContext that you wish to be bound to this widget. This allows you to pass in your own QGLContext sub-classes.</para>
            <para>The widget will be invalid if the system has no OpenGL support.</para>
            <para>The parent and widget flag, f, arguments are passed to the QWidget constructor.</para>
            <para>If shareWidget is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with shareWidget. But if shareWidget and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</para>
            <para>The initialization of OpenGL rendering state, etc. should be done by overriding the initializeGL() function, rather than in the constructor of your QGLWidget subclass.</para>
            <para>See also QGLFormat::defaultFormat() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.#ctor(QtOpenGL.QGLFormat,QtWidgets.QWidget,QtOpenGL.QGLWidget,QtCore.Qt.WindowType)">
            <summary>
            <para>Constructs an OpenGL widget with parent parent.</para>
            <para>The format argument specifies the desired rendering options. If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual format obtained.</para>
            <para>The widget will be invalid if the system has no OpenGL support.</para>
            <para>The parent and widget flag, f, arguments are passed to the QWidget constructor.</para>
            <para>If shareWidget is a valid QGLWidget, this widget will share OpenGL display lists and texture objects with shareWidget. But if shareWidget and this widget have different formats, sharing might not be possible. You can check whether sharing is in effect by calling isSharing().</para>
            <para>The initialization of OpenGL rendering state, etc. should be done by overriding the initializeGL() function, rather than in the constructor of your QGLWidget subclass.</para>
            <para>See also QGLFormat::defaultFormat() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.QglColor(QtGui.QColor)">
            <summary>
            <para>Convenience function for specifying a drawing color to OpenGL. Calls glColor4 (in RGBA mode) or glIndex (in color-index mode) with the color c. Applies to this widgets GL context.</para>
            <para>Note: This function is not supported on OpenGL/ES 2.0 systems.</para>
            <para>See also qglClearColor(), QGLContext::currentContext(), and QColor.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.QglClearColor(QtGui.QColor)">
            <summary>
            <para>Convenience function for specifying the clearing color to OpenGL. Calls glClearColor (in RGBA mode) or glClearIndex (in color-index mode) with the color c. Applies to this widgets GL context.</para>
            <para>See also qglColor(), QGLContext::currentContext(), and QColor.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.MakeCurrent">
            <summary>
            <para>Makes this widget the current widget for OpenGL operations, i.e. makes the widget's rendering context the current OpenGL rendering context.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DoneCurrent">
            <summary>
            <para>Makes no GL context the current context. Normally, you do not need to call this function; QGLContext calls it as necessary. However, it may be useful in multithreaded environments.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.SwapBuffers">
            <summary>
            <para>Swaps the screen contents with an off-screen buffer. This only works if the widget's format specifies double buffer mode.</para>
            <para>Normally, there is no need to explicitly call this function because it is done automatically after each widget repaint, i.e. each time after paintGL() has been executed.</para>
            <para>See also doubleBuffer(), setAutoBufferSwap(), and QGLFormat::setDoubleBuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.SetContext(QtOpenGL.QGLContext,QtOpenGL.QGLContext,System.Boolean)">
            <summary>
            <para>Sets a new context for this widget. The QGLContext context must be created using new. QGLWidget will delete context when another context is set or when the widget is destroyed.</para>
            <para>If context is invalid, QGLContext::create() is performed on it. The initializeGL() function will then be executed for the new context before the first resizeGL() or paintGL().</para>
            <para>If context is invalid, this method will try to keep display list and texture object sharing in effect, or (if shareContext points to a valid context) start display list and texture object sharing with that context, but sharing might be impossible if the two contexts have different formats. Use isSharing() to see whether sharing is in effect.</para>
            <para>If deleteOldContext is true (the default), the existing context will be deleted. You may use false here if you have kept a pointer to the old context (as returned by context()), and want to restore that context later.</para>
            <para>Note: This function is obsolete and should no longer be used. If you were using it to recreate the context for a QGLWidget, you should instead create a new QGLWidget or use the QOpenGLContext API in conjunction with QWindow. There is currently no officially supported way to substitute QGLWidget's context with your own implementation of QGLContext.</para>
            <para>See also context() and isSharing().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderPixmap(System.Int32,System.Int32,System.Boolean)">
            <summary>
            <para>Renders the current scene on a pixmap and returns the pixmap.</para>
            <para>You can use this method on both visible and invisible QGLWidget objects.</para>
            <para>Internally the function renders into a framebuffer object and performs pixel readback. This has a performance penalty, meaning that this function is not suitable to be called at a high frequency.</para>
            <para>After creating and binding the framebuffer object, the function will call initializeGL(), resizeGL(), and paintGL(). On the next normal update initializeGL() and resizeGL() will be triggered again since the size of the destination pixmap and the QGLWidget's size may differ.</para>
            <para>The size of the pixmap will be w pixels wide and h pixels high unless one of these parameters is 0 (the default), in which case the pixmap will have the same size as the widget.</para>
            <para>Care must be taken when using framebuffer objects in paintGL() in combination with this function. To switch back to the default framebuffer, use QGLFramebufferObject::bindDefault(). Binding FBO 0 is wrong since renderPixmap() uses a custom framebuffer instead of the one provided by the windowing system.</para>
            <para>useContext is ignored. Historically this parameter enabled the usage of the existing GL context. This is not supported anymore since additional contexts are never created.</para>
            <para>Overlays are not rendered onto the pixmap.</para>
            <para>If the GL rendering context and the desktop have different bit depths, the result will most likely look surprising.</para>
            <para>Note that the creation of display lists, modifications of the view frustum etc. should be done from within initializeGL(). If this is not done, the temporary QGLContext will not be initialized properly, and the rendered pixmap may be incomplete/corrupted.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.GrabFrameBuffer(System.Boolean)">
            <summary>
            <para>Returns an image of the frame buffer. If withAlpha is true the alpha channel is included.</para>
            <para>Depending on your hardware, you can explicitly select which color buffer to grab with a glReadBuffer() call before calling this function.</para>
            <para>On QNX the back buffer is not preserved when swapBuffers() is called. The back buffer where this function reads from, might thus not contain the same content as the front buffer. In order to retrieve what is currently visible on the screen, swapBuffers() has to be executed prior to this function call.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.MakeOverlayCurrent">
            <summary>
            <para>Makes the overlay context of this widget current. Use this if you need to issue OpenGL commands to the overlay context outside of initializeOverlayGL(), resizeOverlayGL(), and paintOverlayGL().</para>
            <para>Does nothing if this widget has no overlay.</para>
            <para>See also makeCurrent().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Int32,System.Int32,System.String,QtGui.QFont)">
            <summary>
            <para>Renders the string str into the GL context of this widget.</para>
            <para>x and y are specified in window coordinates, with the origin in the upper left-hand corner of the window. If font is not specified, the currently set application font will be used to render the string. To change the color of the rendered text you can use the glColor() call (or the qglColor() convenience function), just before the renderText() call.</para>
            <para>Note: This function clears the stencil buffer.</para>
            <para>Note: This function is not supported on OpenGL/ES systems.</para>
            <para>Note: This function temporarily disables depth-testing when the text is drawn.</para>
            <para>Note: This function can only be used inside a QPainter::beginNativePainting()/QPainter::endNativePainting() block if a painter is active on the QGLWidget.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Double,System.Double,System.Double,System.String,QtGui.QFont)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>x, y and z are specified in scene or object coordinates relative to the currently set projection and model matrices. This can be useful if you want to annotate models with text labels and have the labels move with the model as it is rotated etc.</para>
            <para>Note: This function is not supported on OpenGL/ES systems.</para>
            <para>Note: If depth testing is enabled before this function is called, then the drawn text will be depth-tested against the models that have already been drawn in the scene. Use glDisable(GL_DEPTH_TEST) before calling this function to annotate the models without depth-testing the text.</para>
            <para>Note: This function can only be used inside a QPainter::beginNativePainting()/QPainter::endNativePainting() block if a painter is active on the QGLWidget.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QImage,System.UInt32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>The binding options are a set of options used to decide how to bind the texture to the context.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QPixmap,System.UInt32,System.Int32,QtOpenGL.QGLContext.BindOption)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Generates and binds a 2D GL texture to the current context, based on pixmap. The generated texture id is returned and can be used in</para>
            <para>The binding options are a set of options used to decide how to bind the texture to the context.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QImage,System.UInt32,System.Int32)">
            <summary>
            <para>Calls QGLContext:::bindTexture(image, target, format) on the currently set context.</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(QtGui.QPixmap,System.UInt32,System.Int32)">
            <summary>
            <para>Calls QGLContext:::bindTexture(pixmap, target, format) on the currently set context.</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.BindTexture(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Calls QGLContext::bindTexture(fileName) on the currently set context.</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DeleteTexture(System.UInt32)">
            <summary>
            <para>Calls QGLContext::deleteTexture(id) on the currently set context.</para>
            <para>See also bindTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DrawTexture(QtCore.QRectF,System.UInt32,System.UInt32)">
            <summary>
            <para>Calls the corresponding QGLContext::drawTexture() with target, textureId, and textureTarget for this widget's context.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.DrawTexture(QtCore.QPointF,System.UInt32,System.UInt32)">
            <summary>
            <para>Calls the corresponding QGLContext::drawTexture() with point, textureId, and textureTarget for this widget's context.</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.UpdateGL">
            <summary>
            <para>Updates the widget by calling glDraw().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.UpdateOverlayGL">
            <summary>
            <para>Updates the widget's overlay (if any). Will cause the virtual function paintOverlayGL() to be executed.</para>
            <para>The widget's rendering context will become the current context and initializeGL() will be called if it hasn't already been called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.OnEvent(QtCore.QEvent)">
            <summary>
            <para>Reimplemented from QObject::event().</para>
            <para>Handles the event e passed as a parameter.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.InitializeGL">
            <summary>
            <para>This virtual function is called once before the first call to paintGL() or resizeGL(), and then once whenever the widget has been assigned a new QGLContext. Reimplement it in a subclass.</para>
            <para>This function should set up any required OpenGL context rendering flags, defining display lists, etc.</para>
            <para>There is no need to call makeCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.ResizeGL(System.Int32,System.Int32)">
            <summary>
            <para>This virtual function is called whenever the widget has been resized. The new size is passed in width and height. Reimplement it in a subclass.</para>
            <para>There is no need to call makeCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.PaintGL">
            <summary>
            <para>This virtual function is called whenever the widget needs to be painted. Reimplement it in a subclass.</para>
            <para>There is no need to call makeCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.InitializeOverlayGL">
            <summary>
            <para>This virtual function is used in the same manner as initializeGL() except that it operates on the widget's overlay context instead of the widget's main context. This means that initializeOverlayGL() is called once before the first call to paintOverlayGL() or resizeOverlayGL(). Reimplement it in a subclass.</para>
            <para>This function should set up any required OpenGL context rendering flags, defining display lists, etc. for the overlay context.</para>
            <para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.ResizeOverlayGL(System.Int32,System.Int32)">
            <summary>
            <para>This virtual function is used in the same manner as paintGL() except that it operates on the widget's overlay context instead of the widget's main context. This means that resizeOverlayGL() is called whenever the widget has been resized. The new size is passed in width and height. Reimplement it in a subclass.</para>
            <para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.PaintOverlayGL">
            <summary>
            <para>This virtual function is used in the same manner as paintGL() except that it operates on the widget's overlay context instead of the widget's main context. This means that paintOverlayGL() is called whenever the widget's overlay needs to be painted. Reimplement it in a subclass.</para>
            <para>There is no need to call makeOverlayCurrent() because this has already been done when this function is called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.OnPaintEvent(QtGui.QPaintEvent)">
            <summary>
            <para>Reimplemented from QWidget::paintEvent().</para>
            <para>Handles paint events passed in the event parameter. Will cause the virtual paintGL() function to be called.</para>
            <para>The widget's rendering context will become the current context and initializeGL() will be called if it hasn't already been called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.OnResizeEvent(QtGui.QResizeEvent)">
            <summary>
            <para>Reimplemented from QWidget::resizeEvent().</para>
            <para>Handles resize events that are passed in the event parameter. Calls the virtual function resizeGL().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.GlInit">
            <summary>
            <para>Initializes OpenGL for this widget's context. Calls the virtual function initializeGL().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.GlDraw">
            <summary>
            <para>Executes the virtual function paintGL().</para>
            <para>The widget's rendering context will become the current context and initializeGL() will be called if it hasn't already been called.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Int32,System.Int32,System.String)">
            <summary>
            <para>Renders the string str into the GL context of this widget.</para>
            <para>x and y are specified in window coordinates, with the origin in the upper left-hand corner of the window. If font is not specified, the currently set application font will be used to render the string. To change the color of the rendered text you can use the glColor() call (or the qglColor() convenience function), just before the renderText() call.</para>
            <para>Note: This function clears the stencil buffer.</para>
            <para>Note: This function is not supported on OpenGL/ES systems.</para>
            <para>Note: This function temporarily disables depth-testing when the text is drawn.</para>
            <para>Note: This function can only be used inside a QPainter::beginNativePainting()/QPainter::endNativePainting() block if a painter is active on the QGLWidget.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.RenderText(System.Double,System.Double,System.Double,System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>x, y and z are specified in scene or object coordinates relative to the currently set projection and model matrices. This can be useful if you want to annotate models with text labels and have the labels move with the model as it is rotated etc.</para>
            <para>Note: This function is not supported on OpenGL/ES systems.</para>
            <para>Note: If depth testing is enabled before this function is called, then the drawn text will be depth-tested against the models that have already been drawn in the scene. Use glDisable(GL_DEPTH_TEST) before calling this function to annotate the models without depth-testing the text.</para>
            <para>Note: This function can only be used inside a QPainter::beginNativePainting()/QPainter::endNativePainting() block if a painter is active on the QGLWidget.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLWidget.ConvertToGLFormat(QtGui.QImage)">
            <summary>
            <para>Converts the image img into the unnamed format expected by OpenGL functions such as glTexImage2D(). The returned image is not usable as a QImage, but QImage::width(), QImage::height() and QImage::bits() may be used with OpenGL. The GL format used is GL_RGBA.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.Format">
            <summary>
            <para>Returns the format of the contained GL rendering context.</para>
            <para>See also setFormat().</para>
            <para></para>
            <para>Sets a new format for this widget.</para>
            <para>If the underlying OpenGL/Window system cannot satisfy all the features requested in format, the nearest subset of features will be used. After creation, the format() method will return the actual rendering context format obtained.</para>
            <para>The widget will be assigned a new QGLContext, and the initializeGL() function will be executed for this new context before the first resizeGL() or paintGL().</para>
            <para>This method will try to keep display list and texture object sharing in effect with other QGLWidget objects, but changing the format might make sharing impossible. Use isSharing() to see if sharing is still in effect.</para>
            <para>See also format(), isSharing(), and isValid().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.Colormap">
            <summary>
            <para>Returns the colormap for this widget.</para>
            <para>Usually it is only top-level widgets that can have different colormaps installed. Asking for the colormap of a child widget will return the colormap for the child's top-level widget.</para>
            <para>If no colormap has been set for this widget, the QGLColormap returned will be empty.</para>
            <para>See also setColormap() and QGLColormap::isEmpty().</para>
            <para></para>
            <para>Set the colormap for this widget to cmap. Usually it is only top-level widgets that can have colormaps installed.</para>
            <para>See also colormap().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.AutoBufferSwap">
            <summary>
            <para>Returns true if the widget is doing automatic GL buffer swapping; otherwise returns false.</para>
            <para>See also setAutoBufferSwap().</para>
            <para></para>
            <para>If on is true automatic GL buffer swapping is switched on; otherwise it is switched off.</para>
            <para>If on is true and the widget is using a double-buffered format, the background and foreground GL buffers will automatically be swapped after each paintGL() call.</para>
            <para>The buffer auto-swapping is on by default.</para>
            <para>See also autoBufferSwap(), doubleBuffer(), and swapBuffers().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.Context">
            <summary>
            <para>Returns the context of this widget.</para>
            <para>It is possible that the context is not valid (see isValid()), for example, if the underlying hardware does not support the format attributes that were requested.</para>
            <para>See also setContext().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.IsValid">
            <summary>
            <para>Returns true if the widget has a valid GL rendering context; otherwise returns false. A widget will be invalid if the system has no OpenGL support.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.IsSharing">
            <summary>
            <para>Returns true if this widget's GL context is shared with another GL context, otherwise false is returned. Context sharing might not be possible if the widgets use different formats.</para>
            <para>See also format().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.DoubleBuffer">
            <summary>
            <para>Returns true if the contained GL rendering context has double buffering; otherwise returns false.</para>
            <para>See also QGLFormat::doubleBuffer().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLWidget.OverlayContext">
            <summary>
            <para>Returns the overlay context of this widget, or 0 if this widget has no overlay.</para>
            <para>See also context().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGL.FormatOption">
            <summary>
            <para>This enum specifies the format options that can be used to configure an OpenGL context. These are set using QGLFormat::setOption().</para>
            <para>The FormatOptions type is a typedef for QFlags&lt;FormatOption&gt;. It stores an OR combination of FormatOption values.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.DoubleBuffer">
            <summary>Specifies the use of double buffering.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.DepthBuffer">
            <summary>Enables the use of a depth buffer.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.Rgba">
            <summary>Specifies that the context should use RGBA as its pixel format.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.AlphaChannel">
            <summary>Enables the use of an alpha channel.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.AccumBuffer">
            <summary>Enables the use of an accumulation buffer.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.StencilBuffer">
            <summary>Enables the use of a stencil buffer.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.StereoBuffers">
            <summary>Enables the use of a stereo buffers for use with visualization hardware.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.DirectRendering">
            <summary>Specifies that the context is used for direct rendering to a display.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.HasOverlay">
            <summary>Enables the use of an overlay.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.SampleBuffers">
            <summary>Enables the use of sample buffers.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.DeprecatedFunctions">
            <summary>Enables the use of deprecated functionality for OpenGL 3.x contexts. A context with deprecated functionality enabled is called a full context in the OpenGL specification.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.SingleBuffer">
            <summary>Specifies the use of a single buffer, as opposed to double buffers.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoDepthBuffer">
            <summary>Disables the use of a depth buffer.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.ColorIndex">
            <summary>Specifies that the context should use a color index as its pixel format.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoAlphaChannel">
            <summary>Disables the use of an alpha channel.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoAccumBuffer">
            <summary>Disables the use of an accumulation buffer.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoStencilBuffer">
            <summary>Disables the use of a stencil buffer.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoStereoBuffers">
            <summary>Disables the use of stereo buffers.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.IndirectRendering">
            <summary>Specifies that the context is used for indirect rendering to a buffer.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoOverlay">
            <summary>Disables the use of an overlay.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoSampleBuffers">
            <summary>Disables the use of sample buffers.</summary>
        </member>
        <member name="F:QtOpenGL.QGL.FormatOption.NoDeprecatedFunctions">
            <summary>Disables the use of deprecated functionality for OpenGL 3.x contexts. A context with deprecated functionality disabled is called a forward compatible context in the OpenGL specification.</summary>
        </member>
        <member name="T:QtOpenGL.QGLBuffer">
            <summary>
            <para>The QGLBuffer class provides functions for creating and managing GL buffer objects.</para>
            </summary>
            <remarks>
            <para>Buffer objects are created in the GL server so that the client application can avoid uploading vertices, indices, texture image data, etc every time they are needed.</para>
            <para>QGLBuffer objects can be copied around as a reference to the underlying GL buffer object:</para>
            <para>QGLBuffer buffer1(QGLBuffer::IndexBuffer);</para>
            <para>buffer1.create();</para>
            <para></para>
            <para>QGLBuffer buffer2 = buffer1;</para>
            <para>QGLBuffer performs a shallow copy when objects are copied in this manner, but does not implement copy-on-write semantics. The original object will be affected whenever the copy is modified.</para>
            <para>Note: This class has been deprecated in favor of QOpenGLBuffer.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.#ctor">
            <summary>
            <para>Constructs a new buffer object of type QGLBuffer::VertexBuffer.</para>
            <para>Note: this constructor just creates the QGLBuffer instance. The actual buffer object in the GL server is not created until create() is called.</para>
            <para>See also create().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.#ctor(QtOpenGL.QGLBuffer.Type)">
            <summary>
            <para>Constructs a new buffer object of type.</para>
            <para>Note: this constructor just creates the QGLBuffer instance. The actual buffer object in the GL server is not created until create() is called.</para>
            <para>See also create().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.#ctor(QtOpenGL.QGLBuffer)">
            <summary>
            <para>Constructs a shallow copy of other.</para>
            <para>Note: QGLBuffer does not implement copy-on-write semantics, so other will be affected whenever the copy is modified.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Create">
            <summary>
            <para>Creates the buffer object in the GL server. Returns true if the object was created; false otherwise.</para>
            <para>This function must be called with a current QGLContext. The buffer will be bound to and can only be used in that context (or any other context that is shared with it).</para>
            <para>This function will return false if the GL implementation does not support buffers, or there is no current QGLContext.</para>
            <para>See also isCreated(), allocate(), write(), and destroy().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Destroy">
            <summary>
            <para>Destroys this buffer object, including the storage being used in the GL server. All references to the buffer will become invalid.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Bind">
            <summary>
            <para>Binds the buffer associated with this object to the current GL context. Returns false if binding was not possible, usually because type() is not supported on this GL implementation.</para>
            <para>The buffer must be bound to the same QGLContext current when create() was called, or to another QGLContext that is sharing with it. Otherwise, false will be returned from this function.</para>
            <para>See also release() and create().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Release">
            <summary>
            <para>Releases the buffer associated with this object from the current GL context.</para>
            <para>This function must be called with the same QGLContext current as when bind() was called on the buffer.</para>
            <para>See also bind().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Read(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <para>Reads the count bytes in this buffer starting at offset into data. Returns true on success; false if reading from the buffer is not supported. Buffer reading is not supported under OpenGL/ES.</para>
            <para>It is assumed that this buffer has been bound to the current context.</para>
            <para>See also write() and bind().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Write(System.Int32,System.IntPtr,System.Int32)">
            <summary>
            <para>Replaces the count bytes of this buffer starting at offset with the contents of data. Any other bytes in the buffer will be left unmodified.</para>
            <para>It is assumed that create() has been called on this buffer and that it has been bound to the current context.</para>
            <para>See also create(), read(), and allocate().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Allocate(System.IntPtr,System.Int32)">
            <summary>
            <para>Allocates count bytes of space to the buffer, initialized to the contents of data. Any previous contents will be removed.</para>
            <para>It is assumed that create() has been called on this buffer and that it has been bound to the current context.</para>
            <para>See also create(), read(), and write().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Allocate(System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Allocates count bytes of space to the buffer. Any previous contents will be removed.</para>
            <para>It is assumed that create() has been called on this buffer and that it has been bound to the current context.</para>
            <para>See also create() and write().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Map(QtOpenGL.QGLBuffer.Access)">
            <summary>
            <para>Maps the contents of this buffer into the application's memory space and returns a pointer to it. Returns null if memory mapping is not possible. The access parameter indicates the type of access to be performed.</para>
            <para>It is assumed that create() has been called on this buffer and that it has been bound to the current context.</para>
            <para>This function is only supported under OpenGL/ES if the GL_OES_mapbuffer extension is present.</para>
            <para>See also unmap(), create(), and bind().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Unmap">
            <summary>
            <para>Unmaps the buffer after it was mapped into the application's memory space with a previous call to map(). Returns true if the unmap succeeded; false otherwise.</para>
            <para>It is assumed that this buffer has been bound to the current context, and that it was previously mapped with map().</para>
            <para>This function is only supported under OpenGL/ES if the GL_OES_mapbuffer extension is present.</para>
            <para>See also map().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLBuffer.Release(QtOpenGL.QGLBuffer.Type)">
            <summary>
            <para>Releases the buffer associated with type in the current QGLContext.</para>
            <para>This function is a direct call to glBindBuffer(type, 0) for use when the caller does not know which QGLBuffer has been bound to the context but wants to make sure that it is released.</para>
            <para>QGLBuffer::release(QGLBuffer::VertexBuffer);</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.usagePattern">
            <summary>
            <para>Returns the usage pattern for this buffer object. The default value is StaticDraw.</para>
            <para>See also setUsagePattern().</para>
            <para></para>
            <para>Sets the usage pattern for this buffer object to value. This function must be called before allocate() or write().</para>
            <para>See also usagePattern(), allocate(), and write().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.type">
            <summary>
            <para>Returns the type of buffer represented by this object.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.IsCreated">
            <summary>
            <para>Returns true if this buffer has been created; false otherwise.</para>
            <para>See also create() and destroy().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.BufferId">
            <summary>
            <para>Returns the GL identifier associated with this buffer; zero if the buffer has not been created.</para>
            <para>See also isCreated().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLBuffer.Size">
            <summary>
            <para>Returns the size of the data in this buffer, for reading operations. Returns -1 if fetching the buffer size is not supported, or the buffer has not been created.</para>
            <para>It is assumed that this buffer has been bound to the current context.</para>
            <para>See also isCreated() and bind().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLBuffer.Type">
            <summary>
            <para>This enum defines the type of GL buffer object to create with QGLBuffer.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.VertexBuffer">
            <summary>Vertex buffer object for use when specifying vertex arrays.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.IndexBuffer">
            <summary>Index buffer object for use with glDrawElements().</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.PixelPackBuffer">
            <summary>Pixel pack buffer object for reading pixel data from the GL server (for example, with glReadPixels()). Not supported under OpenGL/ES.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Type.PixelUnpackBuffer">
            <summary>Pixel unpack buffer object for writing pixel data to the GL server (for example, with glTexImage2D()). Not supported under OpenGL/ES.</summary>
        </member>
        <member name="T:QtOpenGL.QGLBuffer.UsagePattern">
            <summary>
            <para>This enum defines the usage pattern of a QGLBuffer object.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StreamDraw">
            <summary>The data will be set once and used a few times for drawing operations. Under OpenGL/ES 1.1 this is identical to StaticDraw.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StreamRead">
            <summary>The data will be set once and used a few times for reading data back from the GL server. Not supported under OpenGL/ES.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StreamCopy">
            <summary>The data will be set once and used a few times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StaticDraw">
            <summary>The data will be set once and used many times for drawing operations.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StaticRead">
            <summary>The data will be set once and used many times for reading data back from the GL server. Not supported under OpenGL/ES.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.StaticCopy">
            <summary>The data will be set once and used many times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.DynamicDraw">
            <summary>The data will be modified repeatedly and used many times for drawing operations.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.DynamicRead">
            <summary>The data will be modified repeatedly and used many times for reading data back from the GL server. Not supported under OpenGL/ES.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.UsagePattern.DynamicCopy">
            <summary>The data will be modified repeatedly and used many times for reading data back from the GL server for use in further drawing operations. Not supported under OpenGL/ES.</summary>
        </member>
        <member name="T:QtOpenGL.QGLBuffer.Access">
            <summary>
            <para>This enum defines the access mode for QGLBuffer::map().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Access.ReadOnly">
            <summary>The buffer will be mapped for reading only.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Access.WriteOnly">
            <summary>The buffer will be mapped for writing only.</summary>
        </member>
        <member name="F:QtOpenGL.QGLBuffer.Access.ReadWrite">
            <summary>The buffer will be mapped for reading and writing.</summary>
        </member>
        <member name="T:QtOpenGL.QGLFramebufferObject">
            <summary>
            <para>The QGLFramebufferObject class encapsulates an OpenGL framebuffer object.</para>
            </summary>
            <remarks>
            <para>The QGLFramebufferObject class encapsulates an OpenGL framebuffer object, defined by the GL_EXT_framebuffer_object extension. In addition it provides a rendering surface that can be painted on with a QPainter, rendered to using native GL calls, or both. This surface can be bound and used as a regular texture in your own GL drawing code. By default, the QGLFramebufferObject class generates a 2D GL texture (using the GL_TEXTURE_2D target), which is used as the internal rendering target.</para>
            <para>It is important to have a current GL context when creating a QGLFramebufferObject, otherwise initialization will fail.</para>
            <para>OpenGL framebuffer objects and pbuffers (see QGLPixelBuffer) can both be used to render to offscreen surfaces, but there are a number of advantages with using framebuffer objects instead of pbuffers:</para>
            <para></para>
            <para>A framebuffer object does not require a separate rendering context, so no context switching will occur when switching rendering targets. There is an overhead involved in switching targets, but in general it is cheaper than a context switch to a pbuffer.</para>
            <para>Rendering to dynamic textures (i.e. render-to-texture functionality) works on all platforms. No need to do explicit copy calls from a render buffer into a texture, as was necessary on systems that did not support the render_texture extension.</para>
            <para>It is possible to attach several rendering buffers (or texture objects) to the same framebuffer object, and render to all of them without doing a context switch.</para>
            <para>The OpenGL framebuffer extension is a pure GL extension with no system dependant WGL, CGL, or GLX parts. This makes using framebuffer objects more portable.</para>
            <para></para>
            <para>When using a QPainter to paint to a QGLFramebufferObject you should take care that the QGLFramebufferObject is created with the CombinedDepthStencil attachment for QPainter to be able to render correctly. Note that you need to create a QGLFramebufferObject with more than one sample per pixel for primitives to be antialiased when drawing using a QPainter. To create a multisample framebuffer object you should use one of the constructors that take a QGLFramebufferObjectFormat parameter, and set the QGLFramebufferObjectFormat::samples() property to a non-zero value.</para>
            <para>When painting to a QGLFramebufferObject using QPainter, the state of the current GL context will be altered by the paint engine to reflect its needs. Applications should not rely upon the GL state being reset to its original conditions, particularly the current shader program, GL viewport, texture units, and drawing modes.</para>
            <para>For multisample framebuffer objects a color render buffer is created, otherwise a texture with the specified texture target is created. The color render buffer or texture will have the specified internal format, and will be bound to the GL_COLOR_ATTACHMENT0 attachment in the framebuffer object.</para>
            <para>If you want to use a framebuffer object with multisampling enabled as a texture, you first need to copy from it to a regular framebuffer object using QGLContext::blitFramebuffer().</para>
            <para></para>
            <para>Threading</para>
            <para>As of Qt 4.8, it's possible to draw into a QGLFramebufferObject using a QPainter in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.</para>
            <para>Note: This class has been deprecated in favor of QOpenGLFramebufferObject.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,System.UInt32)">
            <summary>
            <para>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the size size. The texture is bound to the GL_COLOR_ATTACHMENT0 target in the framebuffer object.</para>
            <para>The target parameter is used to specify the GL texture target. The default target is GL_TEXTURE_2D. Keep in mind that GL_TEXTURE_2D textures must have a power of 2 width and height (e.g. 256x512), unless you are using OpenGL 2.0 or higher.</para>
            <para>By default, no depth and stencil buffers are attached. This behavior can be toggled using one of the overloaded constructors.</para>
            <para>The default internal texture format is GL_RGBA8 for desktop OpenGL, and GL_RGBA for OpenGL/ES.</para>
            <para>It is important that you have a current GL context set when creating the QGLFramebufferObject, otherwise the initialization will fail.</para>
            <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,System.UInt32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Constructs an OpenGL framebuffer object and binds a 2D GL texture to the buffer of the given width and height.</para>
            <para>See also size() and texture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,QtOpenGL.QGLFramebufferObject.Attachment,System.UInt32,System.UInt32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given size.</para>
            <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
            <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFramebufferObject.Attachment,System.UInt32,System.UInt32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Constructs an OpenGL framebuffer object and binds a texture to the buffer of the given width and height.</para>
            <para>The attachment parameter describes the depth/stencil buffer configuration, target the texture target and internal_format the internal texture format. The default texture target is GL_TEXTURE_2D, while the default internal format is GL_RGBA8 for desktop OpenGL and GL_RGBA for OpenGL/ES.</para>
            <para>See also size(), texture(), and attachment().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(QtCore.QSize,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Constructs an OpenGL framebuffer object of the given size based on the supplied format.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Constructs an OpenGL framebuffer object of the given width and height based on the supplied format.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.Bind">
            <summary>
            <para>Switches rendering from the default, windowing system provided framebuffer to this framebuffer object. Returns true upon success, false otherwise.</para>
            <para>See also release().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.ToImage">
            <summary>
            <para>Returns the contents of this framebuffer object as a QImage.</para>
            <para>The returned image has a format of premultiplied ARGB32 or RGB32. The latter is used only when internalTextureFormat() is set to GL_RGB.</para>
            <para>If the rendering in the framebuffer was not done with premultiplied alpha in mind, create a wrapper QImage with a non-premultiplied format. This is necessary before performing operations like QImage::save() because otherwise the image data would get unpremultiplied, even though it was not premultiplied in the first place. To create such a wrapper without performing a copy of the pixel data, do the following:</para>
            <para>QImage fboImage(fbo.toImage());</para>
            <para>QImage image(fboImage.constBits(), fboImage.width(), fboImage.height(), QImage::Format_ARGB32);</para>
            <para>On QNX the back buffer is not preserved when a buffer swap occures. So this function might return old content.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.DrawTexture(QtCore.QRectF,System.UInt32,System.UInt32)">
            <summary>
            <para>Draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
            <para>The framebuffer object should be bound when calling this function.</para>
            <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.DrawTexture(QtCore.QPointF,System.UInt32,System.UInt32)">
            <summary>
            <para>Draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget should be a 2D texture target.</para>
            <para>The framebuffer object should be bound when calling this function.</para>
            <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.Metric(QtGui.QPaintDevice.PaintDeviceMetric)">
            <summary>
            <para>Reimplemented from QPaintDevice::metric().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.BindDefault">
            <summary>
            <para>Switches rendering back to the default, windowing system provided framebuffer. Returns true upon success, false otherwise.</para>
            <para>See also bind() and release().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObject.BlitFramebuffer(QtOpenGL.QGLFramebufferObject,QtCore.QRect,QtOpenGL.QGLFramebufferObject,QtCore.QRect,System.UInt32,System.UInt32)">
            <summary>
            <para>Blits from the sourceRect rectangle in the source framebuffer object to the targetRect rectangle in the target framebuffer object.</para>
            <para>If source or target is 0, the default framebuffer will be used instead of a framebuffer object as source or target respectively.</para>
            <para>The buffers parameter should be a mask consisting of any combination of GL_COLOR_BUFFER_BIT, GL_DEPTH_BUFFER_BIT, and GL_STENCIL_BUFFER_BIT. Any buffer type that is not present both in the source and target buffers is ignored.</para>
            <para>The sourceRect and targetRect rectangles may have different sizes; in this case buffers should not contain GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT. The filter parameter should be set to GL_LINEAR or GL_NEAREST, and specifies whether linear or nearest interpolation should be used when scaling is performed.</para>
            <para>If source equals target a copy is performed within the same buffer. Results are undefined if the source and target rectangles overlap and have different sizes. The sizes must also be the same if any of the framebuffer objects are multisample framebuffers.</para>
            <para>Note that the scissor test will restrict the blit area if enabled.</para>
            <para>This function will have no effect unless hasOpenGLFramebufferBlit() returns true.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also hasOpenGLFramebufferBlit().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.PaintEngine">
            <summary>
            <para>Reimplemented from QPaintDevice::paintEngine().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Format">
            <summary>
            <para>Returns the format of this framebuffer object.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.IsValid">
            <summary>
            <para>Returns true if the framebuffer object is valid.</para>
            <para>The framebuffer can become invalid if the initialization process fails, the user attaches an invalid buffer to the framebuffer object, or a non-power of two width/height is specified as the texture size if the texture target is GL_TEXTURE_2D. The non-power of two limitation does not apply if the OpenGL version is 2.0 or higher, or if the GL_ARB_texture_non_power_of_two extension is present.</para>
            <para>The framebuffer can also become invalid if the QGLContext that the framebuffer was created within is destroyed and there are no other shared contexts that can take over ownership of the framebuffer.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.IsBound">
            <summary>
            <para>Returns true if the framebuffer object is currently bound to a context, otherwise false is returned.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Release">
            <summary>
            <para>Switches rendering back to the default, windowing system provided framebuffer. Returns true upon success, false otherwise.</para>
            <para>See also bind().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Texture">
            <summary>
            <para>Returns the texture id for the texture attached as the default rendering target in this framebuffer object. This texture id can be bound as a normal texture in your own GL code.</para>
            <para>If a multisample framebuffer object is used then the value returned from this function will be invalid.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Size">
            <summary>
            <para>Returns the size of the texture attached to this framebuffer object.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.attachment">
            <summary>
            <para>Returns the status of the depth and stencil buffers attached to this framebuffer object.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.Handle">
            <summary>
            <para>Returns the GL framebuffer object handle for this framebuffer object (returned by the glGenFrameBuffersEXT() function). This handle can be used to attach new images or buffers to the framebuffer. The user is responsible for cleaning up and destroying these objects.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.HasOpenGLFramebufferObjects">
            <summary>
            <para>Returns true if the OpenGL GL_EXT_framebuffer_object extension is present on this system; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObject.HasOpenGLFramebufferBlit">
            <summary>
            <para>Returns true if the OpenGL GL_EXT_framebuffer_blit extension is present on this system; otherwise returns false.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also blitFramebuffer().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFramebufferObject.Attachment">
            <summary>
            <para>This enum type is used to configure the depth and stencil buffers attached to the framebuffer object when it is created.</para>
            <para>This enum was introduced or modified in  Qt 4.3.</para>
            <para>See also attachment().</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFramebufferObject.Attachment.NoAttachment">
            <summary>No attachment is added to the framebuffer object. Note that the OpenGL depth and stencil tests won't work when rendering to a framebuffer object without any depth or stencil buffers. This is the default value.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFramebufferObject.Attachment.CombinedDepthStencil">
            <summary>If the GL_EXT_packed_depth_stencil extension is present, a combined depth and stencil buffer is attached. If the extension is not present, only a depth buffer is attached.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFramebufferObject.Attachment.Depth">
            <summary>A depth buffer is attached to the framebuffer object.</summary>
        </member>
        <member name="T:QtOpenGL.QGLFramebufferObjectFormat">
            <summary>
            <para>The QGLFramebufferObjectFormat class specifies the format of an OpenGL framebuffer object.</para>
            </summary>
            <remarks>
            <para>A framebuffer object has several characteristics:</para>
            <para></para>
            <para>Number of samples per pixels.</para>
            <para>Depth and/or stencil attachments.</para>
            <para>Texture target.</para>
            <para>Internal texture format.</para>
            <para></para>
            <para>Note that the desired attachments or number of samples per pixels might not be supported by the hardware driver. Call QGLFramebufferObject::format() after creating a QGLFramebufferObject to find the exact format that was used to create the frame buffer object.</para>
            <para>Note: This class has been deprecated in favor of QOpenGLFramebufferObjectFormat.</para>
            <para></para>
            <para>See also QGLFramebufferObject.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.#ctor">
            <summary>
            <para>Creates a QGLFramebufferObjectFormat object for specifying the format of an OpenGL framebuffer object.</para>
            <para>By default the format specifies a non-multisample framebuffer object with no attachments, texture target GL_TEXTURE_2D, and internal format GL_RGBA8. On OpenGL/ES systems, the default internal format is GL_RGBA.</para>
            <para>See also samples(), attachment(), and internalTextureFormat().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.#ctor(QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
            <para>Constructs a copy of other.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.op_Equality(QtOpenGL.QGLFramebufferObjectFormat,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
            <para>Returns true if all the options of this framebuffer object format are the same as other; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFramebufferObjectFormat.op_Inequality(QtOpenGL.QGLFramebufferObjectFormat,QtOpenGL.QGLFramebufferObjectFormat)">
            <summary>
            <para>Returns false if all the options of this framebuffer object format are the same as other; otherwise returns true.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.Samples">
            <summary>
            <para>Returns the number of samples per pixel if a framebuffer object is a multisample framebuffer object. Otherwise, returns 0. The default value is 0.</para>
            <para>See also setSamples().</para>
            <para></para>
            <para>Sets the number of samples per pixel for a multisample framebuffer object to samples. The default sample count of 0 represents a regular non-multisample framebuffer object.</para>
            <para>If the desired amount of samples per pixel is not supported by the hardware then the maximum number of samples per pixel will be used. Note that multisample framebuffer objects can not be bound as textures. Also, the GL_EXT_framebuffer_multisample extension is required to create a framebuffer with more than one sample per pixel.</para>
            <para>See also samples().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.Mipmap">
            <summary>
            <para>Returns true if mipmapping is enabled.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also setMipmap().</para>
            <para></para>
            <para>Enables mipmapping if enabled is true; otherwise disables it.</para>
            <para>Mipmapping is disabled by default.</para>
            <para>If mipmapping is enabled, additional memory will be allocated for the mipmap levels. The mipmap levels can be updated by binding the texture and calling glGenerateMipmap(). Mipmapping cannot be enabled for multisampled framebuffer objects.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also mipmap() and QGLFramebufferObject::texture().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.Attachment">
            <summary>
            <para>Returns the configuration of the depth and stencil buffers attached to a framebuffer object. The default is QGLFramebufferObject::NoAttachment.</para>
            <para>See also setAttachment().</para>
            <para></para>
            <para>Sets the attachment configuration of a framebuffer object to attachment.</para>
            <para>See also attachment().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.TextureTarget">
            <summary>
            <para>Returns the texture target of the texture attached to a framebuffer object. Ignored for multisample framebuffer objects. The default is GL_TEXTURE_2D.</para>
            <para>See also setTextureTarget() and samples().</para>
            <para></para>
            <para>Sets the texture target of the texture attached to a framebuffer object to target. Ignored for multisample framebuffer objects.</para>
            <para>See also textureTarget() and samples().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFramebufferObjectFormat.InternalTextureFormat">
            <summary>
            <para>Returns the internal format of a framebuffer object's texture or multisample framebuffer object's color buffer. The default is GL_RGBA8 on desktop OpenGL systems, and GL_RGBA on OpenGL/ES systems.</para>
            <para>See also setInternalTextureFormat().</para>
            <para></para>
            <para>Sets the internal format of a framebuffer object's texture or multisample framebuffer object's color buffer to internalTextureFormat.</para>
            <para>See also internalTextureFormat().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFunctions">
            <summary>
            <para>The QGLFunctions class provides cross-platform access to the OpenGL ES 2.0 API.</para>
            </summary>
            <remarks>
            <para>OpenGL ES 2.0 defines a subset of the OpenGL specification that is common across many desktop and embedded OpenGL implementations. However, it can be difficult to use the functions from that subset because they need to be resolved manually on desktop systems.</para>
            <para>QGLFunctions provides a guaranteed API that is available on all OpenGL systems and takes care of function resolution on systems that need it. The recommended way to use QGLFunctions is by direct inheritance:</para>
            <para>class MyGLWidget : public QGLWidget, protected QGLFunctions</para>
            <para>{</para>
            <para>    Q_OBJECT</para>
            <para>public:</para>
            <para>    MyGLWidget(QWidget *parent = 0) : QGLWidget(parent) {}</para>
            <para></para>
            <para>protected:</para>
            <para>    void initializeGL();</para>
            <para>    void paintGL();</para>
            <para>};</para>
            <para></para>
            <para>void MyGLWidget::initializeGL()</para>
            <para>{</para>
            <para>    initializeGLFunctions();</para>
            <para>}</para>
            <para>The paintGL() function can then use any of the OpenGL ES 2.0 functions without explicit resolution, such as glActiveTexture() in the following example:</para>
            <para>void MyGLWidget::paintGL()</para>
            <para>{</para>
            <para>    glActiveTexture(GL_TEXTURE1);</para>
            <para>    glBindTexture(GL_TEXTURE_2D, textureId);</para>
            <para>    ...</para>
            <para>}</para>
            <para>QGLFunctions can also be used directly for ad-hoc invocation of OpenGL ES 2.0 functions on all platforms:</para>
            <para>QGLFunctions glFuncs(QGLContext::currentContext());</para>
            <para>glFuncs.glActiveTexture(GL_TEXTURE1);</para>
            <para>QGLFunctions provides wrappers for all OpenGL ES 2.0 functions, except those like glDrawArrays(), glViewport(), and glBindTexture() that don't have portability issues.</para>
            <para>Including the header for QGLFunctions will also define all of the OpenGL ES 2.0 macro constants that are not already defined by the system's OpenGL headers, such as GL_TEXTURE1 above.</para>
            <para>The hasOpenGLFeature() and openGLFeatures() functions can be used to determine if the OpenGL implementation has a major OpenGL ES 2.0 feature. For example, the following checks if non power of two textures are available:</para>
            <para>QGLFunctions funcs(QGLContext::currentContext());</para>
            <para>bool npot = funcs.hasOpenGLFeature(QGLFunctions::NPOTTextures);</para>
            <para>Note: This class has been deprecated in favor of QOpenGLFunctions.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.#ctor">
            <summary>
            <para>Constructs a default function resolver. The resolver cannot be used until initializeGLFunctions() is called to specify the context.</para>
            <para>See also initializeGLFunctions().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.#ctor(QtOpenGL.QGLContext)">
            <summary>
            <para>Constructs a function resolver for context. If context is null, then the resolver will be created for the current QGLContext.</para>
            <para>An object constructed in this way can only be used with context and other contexts that share with it. Use initializeGLFunctions() to change the object's context association.</para>
            <para>See also initializeGLFunctions().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.OpenGLFeatures">
            <summary>
            <para>Returns the set of features that are present on this system's OpenGL implementation.</para>
            <para>It is assumed that the QGLContext associated with this function resolver is current.</para>
            <para>See also hasOpenGLFeature().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.HasOpenGLFeature(QtOpenGL.QGLFunctions.OpenGLFeature)">
            <summary>
            <para>Returns true if feature is present on this system's OpenGL implementation; false otherwise.</para>
            <para>It is assumed that the QGLContext associated with this function resolver is current.</para>
            <para>See also openGLFeatures().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.InitializeGLFunctions(QtOpenGL.QGLContext)">
            <summary>
            <para>Initializes GL function resolution for context. If context is null, then the current QGLContext will be used.</para>
            <para>After calling this function, the QGLFunctions object can only be used with context and other contexts that share with it. Call initializeGLFunctions() again to change the object's context association.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlActiveTexture(System.UInt32)">
            <summary>
            <para>Convenience function that calls glActiveTexture(texture).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glActiveTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlAttachShader(System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glAttachShader(program, shader).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glAttachShader().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBindAttribLocation(System.UInt32,System.UInt32,System.String)">
            <summary>
            <para>Convenience function that calls glBindAttribLocation(program, index, name).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBindAttribLocation().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBindBuffer(System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glBindBuffer(target, buffer).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBindBuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBindFramebuffer(System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glBindFramebuffer(target, framebuffer).</para>
            <para>Note that Qt will translate a framebuffer argument of 0 to the currently bound QOpenGLContext's defaultFramebufferObject().</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBindFramebuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBindRenderbuffer(System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glBindRenderbuffer(target, renderbuffer).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBindRenderbuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBlendColor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glBlendColor(red, green, blue, alpha).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBlendColor().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBlendEquation(System.UInt32)">
            <summary>
            <para>Convenience function that calls glBlendEquation(mode).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBlendEquation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBlendEquationSeparate(System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glBlendEquationSeparate(modeRGB, modeAlpha).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBlendEquationSeparate().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBlendFuncSeparate(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glBlendFuncSeparate(srcRGB, dstRGB, srcAlpha, dstAlpha).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBlendFuncSeparate().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBufferData(System.UInt32,System.Int32,System.IntPtr,System.UInt32)">
            <summary>
            <para>Convenience function that calls glBufferData(target, size, data, usage).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBufferData().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlBufferSubData(System.UInt32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            <para>Convenience function that calls glBufferSubData(target, offset, size, data).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glBufferSubData().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlCheckFramebufferStatus(System.UInt32)">
            <summary>
            <para>Convenience function that calls glCheckFramebufferStatus(target).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glCheckFramebufferStatus().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlClearDepthf(System.Single)">
            <summary>
            <para>Convenience function that calls glClearDepth(depth) on desktop OpenGL systems and glClearDepthf(depth) on embedded OpenGL ES systems.</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glClearDepthf().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlCompileShader(System.UInt32)">
            <summary>
            <para>Convenience function that calls glCompileShader(shader).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glCompileShader().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlCompressedTexImage2D(System.UInt32,System.Int32,System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,System.IntPtr)">
            <summary>
            <para>Convenience function that calls glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glCompressedTexImage2D().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlCompressedTexSubImage2D(System.UInt32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,System.Int32,System.IntPtr)">
            <summary>
            <para>Convenience function that calls glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glCompressedTexSubImage2D().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlCreateShader(System.UInt32)">
            <summary>
            <para>Convenience function that calls glCreateShader(type).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glCreateShader().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDeleteBuffers(System.Int32,System.UInt32@)">
            <summary>
            <para>Convenience function that calls glDeleteBuffers(n, buffers).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDeleteBuffers().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDeleteFramebuffers(System.Int32,System.UInt32@)">
            <summary>
            <para>Convenience function that calls glDeleteFramebuffers(n, framebuffers).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDeleteFramebuffers().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDeleteProgram(System.UInt32)">
            <summary>
            <para>Convenience function that calls glDeleteProgram(program).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDeleteProgram().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDeleteRenderbuffers(System.Int32,System.UInt32@)">
            <summary>
            <para>Convenience function that calls glDeleteRenderbuffers(n, renderbuffers).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDeleteRenderbuffers().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDeleteShader(System.UInt32)">
            <summary>
            <para>Convenience function that calls glDeleteShader(shader).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDeleteShader().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDepthRangef(System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glDepthRange(zNear, zFar) on desktop OpenGL systems and glDepthRangef(zNear, zFar) on embedded OpenGL ES systems.</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDepthRangef().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDetachShader(System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glDetachShader(program, shader).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDetachShader().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlDisableVertexAttribArray(System.UInt32)">
            <summary>
            <para>Convenience function that calls glDisableVertexAttribArray(index).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glDisableVertexAttribArray().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlEnableVertexAttribArray(System.UInt32)">
            <summary>
            <para>Convenience function that calls glEnableVertexAttribArray(index).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glEnableVertexAttribArray().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlFramebufferRenderbuffer(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glFramebufferRenderbuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlFramebufferTexture2D(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.Int32)">
            <summary>
            <para>Convenience function that calls glFramebufferTexture2D(target, attachment, textarget, texture, level).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glFramebufferTexture2D().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGenBuffers(System.Int32,System.UInt32@)">
            <summary>
            <para>Convenience function that calls glGenBuffers(n, buffers).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGenBuffers().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGenerateMipmap(System.UInt32)">
            <summary>
            <para>Convenience function that calls glGenerateMipmap(target).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGenerateMipmap().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGenFramebuffers(System.Int32,System.UInt32@)">
            <summary>
            <para>Convenience function that calls glGenFramebuffers(n, framebuffers).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGenFramebuffers().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGenRenderbuffers(System.Int32,System.UInt32@)">
            <summary>
            <para>Convenience function that calls glGenRenderbuffers(n, renderbuffers).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGenRenderbuffers().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetActiveAttrib(System.UInt32,System.UInt32,System.Int32,System.Int32@,System.Int32@,System.UInt32@,System.Char*)">
            <summary>
            <para>Convenience function that calls glGetActiveAttrib(program, index, bufsize, length, size, type, name).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetActiveAttrib().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetActiveUniform(System.UInt32,System.UInt32,System.Int32,System.Int32@,System.Int32@,System.UInt32@,System.Char*)">
            <summary>
            <para>Convenience function that calls glGetActiveUniform(program, index, bufsize, length, size, type, name).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetActiveUniform().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetAttachedShaders(System.UInt32,System.Int32,System.Int32@,System.UInt32@)">
            <summary>
            <para>Convenience function that calls glGetAttachedShaders(program, maxcount, count, shaders).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetAttachedShaders().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetAttribLocation(System.UInt32,System.String)">
            <summary>
            <para>Convenience function that calls glGetAttribLocation(program, name).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetAttribLocation().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetBufferParameteriv(System.UInt32,System.UInt32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetBufferParameteriv(target, pname, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetBufferParameteriv().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetFramebufferAttachmentParameteriv(System.UInt32,System.UInt32,System.UInt32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetFramebufferAttachmentParameteriv(target, attachment, pname, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetFramebufferAttachmentParameteriv().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetProgramiv(System.UInt32,System.UInt32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetProgramiv(program, pname, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetProgramiv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetProgramInfoLog(System.UInt32,System.Int32,System.Int32@,System.Char*)">
            <summary>
            <para>Convenience function that calls glGetProgramInfoLog(program, bufsize, length, infolog).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetProgramInfoLog().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetRenderbufferParameteriv(System.UInt32,System.UInt32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetRenderbufferParameteriv(target, pname, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetRenderbufferParameteriv().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetShaderiv(System.UInt32,System.UInt32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetShaderiv(shader, pname, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetShaderiv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetShaderInfoLog(System.UInt32,System.Int32,System.Int32@,System.Char*)">
            <summary>
            <para>Convenience function that calls glGetShaderInfoLog(shader, bufsize, length, infolog).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetShaderInfoLog().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetShaderPrecisionFormat(System.UInt32,System.UInt32,System.Int32@,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetShaderPrecisionFormat().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetShaderSource(System.UInt32,System.Int32,System.Int32@,System.Char*)">
            <summary>
            <para>Convenience function that calls glGetShaderSource(shader, bufsize, length, source).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetShaderSource().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetUniformfv(System.UInt32,System.Int32,System.Single@)">
            <summary>
            <para>Convenience function that calls glGetUniformfv(program, location, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetUniformfv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetUniformiv(System.UInt32,System.Int32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetUniformiv(program, location, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetUniformiv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetUniformLocation(System.UInt32,System.String)">
            <summary>
            <para>Convenience function that calls glGetUniformLocation(program, name).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetUniformLocation().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetVertexAttribfv(System.UInt32,System.UInt32,System.Single@)">
            <summary>
            <para>Convenience function that calls glGetVertexAttribfv(index, pname, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetVertexAttribfv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetVertexAttribiv(System.UInt32,System.UInt32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glGetVertexAttribiv(index, pname, params).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetVertexAttribiv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlGetVertexAttribPointerv(System.UInt32,System.UInt32,System.Void**)">
            <summary>
            <para>Convenience function that calls glGetVertexAttribPointerv(index, pname, pointer).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glGetVertexAttribPointerv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlIsBuffer(System.UInt32)">
            <summary>
            <para>Convenience function that calls glIsBuffer(buffer).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glIsBuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlIsFramebuffer(System.UInt32)">
            <summary>
            <para>Convenience function that calls glIsFramebuffer(framebuffer).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glIsFramebuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlIsProgram(System.UInt32)">
            <summary>
            <para>Convenience function that calls glIsProgram(program).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glIsProgram().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlIsRenderbuffer(System.UInt32)">
            <summary>
            <para>Convenience function that calls glIsRenderbuffer(renderbuffer).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glIsRenderbuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlIsShader(System.UInt32)">
            <summary>
            <para>Convenience function that calls glIsShader(shader).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glIsShader().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlLinkProgram(System.UInt32)">
            <summary>
            <para>Convenience function that calls glLinkProgram(program).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glLinkProgram().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlReleaseShaderCompiler">
            <summary>
            <para>Convenience function that calls glReleaseShaderCompiler().</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glReleaseShaderCompiler().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlRenderbufferStorage(System.UInt32,System.UInt32,System.Int32,System.Int32)">
            <summary>
            <para>Convenience function that calls glRenderbufferStorage(target, internalformat, width, height).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glRenderbufferStorage().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlSampleCoverage(System.Single,System.Byte)">
            <summary>
            <para>Convenience function that calls glSampleCoverage(value, invert).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glSampleCoverage().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlShaderBinary(System.Int32,System.UInt32@,System.UInt32,System.IntPtr,System.Int32)">
            <summary>
            <para>Convenience function that calls glShaderBinary(n, shaders, binaryformat, binary, length).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glShaderBinary().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlShaderSource(System.UInt32,System.Int32,System.Char**,System.Int32@)">
            <summary>
            <para>Convenience function that calls glShaderSource(shader, count, string, length).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glShaderSource().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlStencilFuncSeparate(System.UInt32,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glStencilFuncSeparate(face, func, ref, mask).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glStencilFuncSeparate().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlStencilMaskSeparate(System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glStencilMaskSeparate(face, mask).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glStencilMaskSeparate().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlStencilOpSeparate(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            <para>Convenience function that calls glStencilOpSeparate(face, fail, zfail, zpass).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glStencilOpSeparate().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform1f(System.Int32,System.Single)">
            <summary>
            <para>Convenience function that calls glUniform1f(location, x).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform1f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform1fv(System.Int32,System.Int32,System.Single@)">
            <summary>
            <para>Convenience function that calls glUniform1fv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform1fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform1i(System.Int32,System.Int32)">
            <summary>
            <para>Convenience function that calls glUniform1i(location, x).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform1i().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform1iv(System.Int32,System.Int32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glUniform1iv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform1iv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform2f(System.Int32,System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glUniform2f(location, x, y).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform2f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform2fv(System.Int32,System.Int32,System.Single@)">
            <summary>
            <para>Convenience function that calls glUniform2fv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform2fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform2i(System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Convenience function that calls glUniform2i(location, x, y).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform2i().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform2iv(System.Int32,System.Int32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glUniform2iv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform2iv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform3f(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glUniform3f(location, x, y, z).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform3f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform3fv(System.Int32,System.Int32,System.Single@)">
            <summary>
            <para>Convenience function that calls glUniform3fv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform3fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform3i(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Convenience function that calls glUniform3i(location, x, y, z).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform3i().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform3iv(System.Int32,System.Int32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glUniform3iv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform3iv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform4f(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glUniform4f(location, x, y, z, w).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform4f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform4fv(System.Int32,System.Int32,System.Single@)">
            <summary>
            <para>Convenience function that calls glUniform4fv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform4fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform4i(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Convenience function that calls glUniform4i(location, x, y, z, w).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform4i().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniform4iv(System.Int32,System.Int32,System.Int32@)">
            <summary>
            <para>Convenience function that calls glUniform4iv(location, count, v).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniform4iv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniformMatrix2fv(System.Int32,System.Int32,System.Byte,System.Single@)">
            <summary>
            <para>Convenience function that calls glUniformMatrix2fv(location, count, transpose, value).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniformMatrix2fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniformMatrix3fv(System.Int32,System.Int32,System.Byte,System.Single@)">
            <summary>
            <para>Convenience function that calls glUniformMatrix3fv(location, count, transpose, value).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniformMatrix3fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUniformMatrix4fv(System.Int32,System.Int32,System.Byte,System.Single@)">
            <summary>
            <para>Convenience function that calls glUniformMatrix4fv(location, count, transpose, value).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUniformMatrix4fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlUseProgram(System.UInt32)">
            <summary>
            <para>Convenience function that calls glUseProgram(program).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glUseProgram().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlValidateProgram(System.UInt32)">
            <summary>
            <para>Convenience function that calls glValidateProgram(program).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glValidateProgram().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib1f(System.UInt32,System.Single)">
            <summary>
            <para>Convenience function that calls glVertexAttrib1f(indx, x).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib1f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib1fv(System.UInt32,System.Single@)">
            <summary>
            <para>Convenience function that calls glVertexAttrib1fv(indx, values).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib1fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib2f(System.UInt32,System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glVertexAttrib2f(indx, x, y).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib2f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib2fv(System.UInt32,System.Single@)">
            <summary>
            <para>Convenience function that calls glVertexAttrib2fv(indx, values).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib2fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib3f(System.UInt32,System.Single,System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glVertexAttrib3f(indx, x, y, z).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib3f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib3fv(System.UInt32,System.Single@)">
            <summary>
            <para>Convenience function that calls glVertexAttrib3fv(indx, values).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib3fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib4f(System.UInt32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Convenience function that calls glVertexAttrib4f(indx, x, y, z, w).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib4f().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttrib4fv(System.UInt32,System.Single@)">
            <summary>
            <para>Convenience function that calls glVertexAttrib4fv(indx, values).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttrib4fv().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLFunctions.GlVertexAttribPointer(System.UInt32,System.Int32,System.UInt32,System.Byte,System.Int32,System.IntPtr)">
            <summary>
            <para>Convenience function that calls glVertexAttribPointer(indx, size, type, normalized, stride, ptr).</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glVertexAttribPointer().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLFunctions.GlCreateProgram">
            <summary>
            <para>Convenience function that calls glCreateProgram().</para>
            <para>For more information, see the OpenGL ES 2.0 documentation for glCreateProgram().</para>
            <para>This convenience function will do nothing on OpenGL ES 1.x systems.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLFunctions.OpenGLFeature">
            <summary>
            <para>This enum defines OpenGL ES 2.0 features that may be optional on other platforms.</para>
            <para>The OpenGLFeatures type is a typedef for QFlags&lt;OpenGLFeature&gt;. It stores an OR combination of OpenGLFeature values.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.Multitexture">
            <summary>glActiveTexture() function is available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.Shaders">
            <summary>Shader functions are available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.Buffers">
            <summary>Vertex and index buffer functions are available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.Framebuffers">
            <summary>Framebuffer object functions are available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.BlendColor">
            <summary>glBlendColor() is available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.BlendEquation">
            <summary>glBlendEquation() is available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.BlendEquationSeparate">
            <summary>glBlendEquationSeparate() is available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.BlendFuncSeparate">
            <summary>glBlendFuncSeparate() is available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.BlendSubtract">
            <summary>Blend subtract mode is available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.CompressedTextures">
            <summary>Compressed texture functions are available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.Multisample">
            <summary>glSampleCoverage() function is available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.StencilSeparate">
            <summary>Separate stencil functions are available.</summary>
        </member>
        <member name="F:QtOpenGL.QGLFunctions.OpenGLFeature.NPOTTextures">
            <summary>Non power of two textures are available.</summary>
        </member>
        <member name="T:QtOpenGL.QGLPixelBuffer">
            <summary>
            <para>The QGLPixelBuffer class encapsulates an OpenGL pbuffer.</para>
            </summary>
            <remarks>
            <para>Rendering into a pbuffer is normally done using full hardware acceleration. This can be significantly faster than rendering into a QPixmap.</para>
            <para>There are three approaches to using this class:</para>
            <para></para>
            <para>We can draw into the pbuffer and convert it to a QImage using toImage(). This is normally much faster than calling QGLWidget::renderPixmap().</para>
            <para>We can draw into the pbuffer and copy the contents into an OpenGL texture using updateDynamicTexture(). This allows us to create dynamic textures and works on all systems with pbuffer support.</para>
            <para>On systems that support it, we can bind the pbuffer to an OpenGL texture. The texture is then updated automatically when the pbuffer contents change, eliminating the need for additional copy operations. This is supported only on Windows and OS X systems that provide the render_texture extension. Note that under Windows, a multi-sampled pbuffer can't be used in conjunction with the render_texture extension. If a multi-sampled pbuffer is requested under Windows, the render_texture extension is turned off for that pbuffer.</para>
            <para></para>
            <para>Note: This class has been deprecated, use QOpenGLFramebufferObject for offscreen rendering.</para>
            <para></para>
            <para>Threading</para>
            <para>As of Qt 4.8, it's possible to render into a QGLPixelBuffer using a QPainter in a separate thread. Note that OpenGL 2.0 or OpenGL ES 2.0 is required for this to work.</para>
            <para>Pbuffers are provided by the OpenGL pbuffer extension; call hasOpenGLPbuffer() to find out if the system provides pbuffers.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(QtCore.QSize,QtOpenGL.QGLFormat,QtOpenGL.QGLWidget)">
            <summary>
            <para>Constructs an OpenGL pbuffer of the given size. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
            <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
            <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(System.Int32,System.Int32,QtOpenGL.QGLFormat,QtOpenGL.QGLWidget)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Constructs an OpenGL pbuffer with the width and height. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
            <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
            <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(QtCore.QSize)">
            <summary>
            <para>Constructs an OpenGL pbuffer of the given size. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
            <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
            <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.#ctor(System.Int32,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Constructs an OpenGL pbuffer with the width and height. If no format is specified, the default format is used. If the shareWidget parameter points to a valid QGLWidget, the pbuffer will share its context with shareWidget.</para>
            <para>If you intend to bind this pbuffer as a dynamic texture, the width and height components of size must be powers of two (e.g., 512 x 128).</para>
            <para>See also size() and format().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.MakeCurrent">
            <summary>
            <para>Makes this pbuffer the current OpenGL rendering context. Returns true on success; otherwise returns false.</para>
            <para>See also QGLContext::makeCurrent() and doneCurrent().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DoneCurrent">
            <summary>
            <para>Makes no context the current OpenGL context. Returns true on success; otherwise returns false.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.GenerateDynamicTexture">
            <summary>
            <para>Generates and binds a 2D GL texture that is the same size as the pbuffer, and returns the texture's ID. This can be used in conjunction with bindToDynamicTexture() and updateDynamicTexture().</para>
            <para>See also size().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindToDynamicTexture(System.UInt32)">
            <summary>
            <para>Binds the texture specified by texture_id to this pbuffer. Returns true on success; otherwise returns false.</para>
            <para>The texture must be of the same size and format as the pbuffer.</para>
            <para>To unbind the texture, call releaseFromDynamicTexture(). While the texture is bound, it is updated automatically when the pbuffer contents change, eliminating the need for additional copy operations.</para>
            <para>Example:</para>
            <para>QGLPixelBuffer pbuffer(...);</para>
            <para>...</para>
            <para>pbuffer.makeCurrent();</para>
            <para>GLuint dynamicTexture = pbuffer.generateDynamicTexture();</para>
            <para>pbuffer.bindToDynamicTexture(dynamicTexture);</para>
            <para>...</para>
            <para>pbuffer.releaseFromDynamicTexture();</para>
            <para>Warning: This function uses the render_texture extension, which is currently not supported under X11. An alternative that works on all systems (including X11) is to manually copy the pbuffer contents to a texture using updateDynamicTexture().</para>
            <para>Warning: For the bindToDynamicTexture() call to succeed on the OS X, the pbuffer needs a shared context, i.e. the QGLPixelBuffer must be created with a share widget.</para>
            <para>See also generateDynamicTexture() and releaseFromDynamicTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.ReleaseFromDynamicTexture">
            <summary>
            <para>Releases the pbuffer from any previously bound texture.</para>
            <para>See also bindToDynamicTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.UpdateDynamicTexture(System.UInt32)">
            <summary>
            <para>Copies the pbuffer contents into the texture specified with texture_id.</para>
            <para>The texture must be of the same size and format as the pbuffer.</para>
            <para>Example:</para>
            <para>QGLPixelBuffer pbuffer(...);</para>
            <para>...</para>
            <para>pbuffer.makeCurrent();</para>
            <para>GLuint dynamicTexture = pbuffer.generateDynamicTexture();</para>
            <para>...</para>
            <para>pbuffer.updateDynamicTexture(dynamicTexture);</para>
            <para>An alternative on Windows and OS X systems that support the render_texture extension is to use bindToDynamicTexture() to get dynamic updates of the texture.</para>
            <para>See also generateDynamicTexture() and bindToDynamicTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(QtGui.QImage,System.UInt32)">
            <summary>
            <para>Generates and binds a 2D GL texture to the current context, based on image. The generated texture id is returned and can be used in later glBindTexture() calls.</para>
            <para>The target parameter specifies the texture target.</para>
            <para>Equivalent to calling QGLContext::bindTexture().</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(QtGui.QPixmap,System.UInt32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Generates and binds a 2D GL texture based on pixmap.</para>
            <para>Equivalent to calling QGLContext::bindTexture().</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.BindTexture(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Reads the DirectDrawSurface (DDS) compressed file fileName and generates a 2D GL texture from it.</para>
            <para>Equivalent to calling QGLContext::bindTexture().</para>
            <para>See also deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DeleteTexture(System.UInt32)">
            <summary>
            <para>Removes the texture identified by texture_id from the texture cache.</para>
            <para>Equivalent to calling QGLContext::deleteTexture().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DrawTexture(QtCore.QRectF,System.UInt32,System.UInt32)">
            <summary>
            <para>Draws the given texture, textureId, to the given target rectangle, target, in OpenGL model space. The textureTarget should be a 2D texture target.</para>
            <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.DrawTexture(QtCore.QPointF,System.UInt32,System.UInt32)">
            <summary>
            <para>Draws the given texture, textureId, at the given point in OpenGL model space. The textureTarget parameter should be a 2D texture target.</para>
            <para>Equivalent to the corresponding QGLContext::drawTexture().</para>
            <para>This function was introduced in  Qt 4.4.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.ToImage">
            <summary>
            <para>Returns the contents of the pbuffer as a QImage.</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLPixelBuffer.Metric(QtGui.QPaintDevice.PaintDeviceMetric)">
            <summary>
            <para>Reimplemented from QPaintDevice::metric().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.PaintEngine">
            <summary>
            <para>Reimplemented from QPaintDevice::paintEngine().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.IsValid">
            <summary>
            <para>Returns true if this pbuffer is valid; otherwise returns false.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.Context">
            <summary>
            <para>Returns the context of this pixelbuffer.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.Size">
            <summary>
            <para>Returns the size of the pbuffer.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.Handle">
            <summary>
            <para>Returns the native pbuffer handle.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.Format">
            <summary>
            <para>Returns the format of the pbuffer. The format may be different from the one that was requested.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLPixelBuffer.HasOpenGLPbuffers">
            <summary>
            <para>Returns true if the OpenGL pbuffer extension is present on this system; otherwise returns false.</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLShader">
            <summary>
            <para>The QGLShader class allows OpenGL shaders to be compiled.</para>
            </summary>
            <remarks>
            <para>This class supports shaders written in the OpenGL Shading Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).</para>
            <para>QGLShader and QGLShaderProgram shelter the programmer from the details of compiling and linking vertex and fragment shaders.</para>
            <para>Note: This class has been deprecated in favor of QOpenGLShader.</para>
            <para></para>
            <para>See also QGLShaderProgram.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLShader.#ctor(QtOpenGL.QGLShader.ShaderTypeBit,QtCore.QObject)">
            <summary>
            <para>Constructs a new QGLShader object of the specified type and attaches it to parent. If shader programs are not supported, QGLShaderProgram::hasOpenGLShaderPrograms() will return false.</para>
            <para>This constructor is normally followed by a call to compileSourceCode() or compileSourceFile().</para>
            <para>The shader will be associated with the current QGLContext.</para>
            <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.#ctor(QtOpenGL.QGLShader.ShaderTypeBit,QtOpenGL.QGLContext,QtCore.QObject)">
            <summary>
            <para>Constructs a new QGLShader object of the specified type and attaches it to parent. If shader programs are not supported, then QGLShaderProgram::hasOpenGLShaderPrograms() will return false.</para>
            <para>This constructor is normally followed by a call to compileSourceCode() or compileSourceFile().</para>
            <para>The shader will be associated with context.</para>
            <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.CompileSourceCode(System.String)">
            <summary>
            <para>Sets the source code for this shader and compiles it. Returns true if the source was successfully compiled, false otherwise.</para>
            <para>See also compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.CompileSourceCode(QtCore.QByteArray)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the source code for this shader and compiles it. Returns true if the source was successfully compiled, false otherwise.</para>
            <para>See also compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.CompileSourceCode1(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the source code for this shader and compiles it. Returns true if the source was successfully compiled, false otherwise.</para>
            <para>See also compileSourceFile().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.CompileSourceFile(System.String)">
            <summary>
            <para>Sets the source code for this shader to the contents of fileName and compiles it. Returns true if the file could be opened and the source compiled, false otherwise.</para>
            <para>See also compileSourceCode().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShader.HasOpenGLShaders(QtOpenGL.QGLShader.ShaderTypeBit,QtOpenGL.QGLContext)">
            <summary>
            <para>Returns true if shader programs of type type are supported on this system; false otherwise.</para>
            <para>The context is used to resolve the GLSL extensions. If context is null, then QGLContext::currentContext() is used.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.ShaderType">
            <summary>
            <para>Returns the type of this shader.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.SourceCode">
            <summary>
            <para>Returns the source code for this shader.</para>
            <para>See also compileSourceCode().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.IsCompiled">
            <summary>
            <para>Returns true if this shader has been compiled; false otherwise.</para>
            <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.Log">
            <summary>
            <para>Returns the errors and warnings that occurred during the last compile.</para>
            <para>See also compileSourceCode() and compileSourceFile().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShader.ShaderId">
            <summary>
            <para>Returns the OpenGL identifier associated with this shader.</para>
            <para>See also QGLShaderProgram::programId().</para>
            </summary>
        </member>
        <member name="T:QtOpenGL.QGLShader.ShaderTypeBit">
            <summary>
            <para>This enum specifies the type of QGLShader that is being created.</para>
            <para>The ShaderType type is a typedef for QFlags&lt;ShaderTypeBit&gt;. It stores an OR combination of ShaderTypeBit values.</para>
            </summary>
        </member>
        <member name="F:QtOpenGL.QGLShader.ShaderTypeBit.Vertex">
            <summary>Vertex shader written in the OpenGL Shading Language (GLSL).</summary>
        </member>
        <member name="F:QtOpenGL.QGLShader.ShaderTypeBit.Fragment">
            <summary>Fragment shader written in the OpenGL Shading Language (GLSL).</summary>
        </member>
        <member name="F:QtOpenGL.QGLShader.ShaderTypeBit.Geometry">
            <summary>Geometry shaders written in the OpenGL Shading Language (GLSL), based on the GL_EXT_geometry_shader4 extension.</summary>
        </member>
        <member name="T:QtOpenGL.QGLShaderProgram">
            <summary>
            <para>The QGLShaderProgram class allows OpenGL shader programs to be linked and used.</para>
            </summary>
            <remarks>
            <para></para>
            <para>Introduction</para>
            <para>This class supports shader programs written in the OpenGL Shading Language (GLSL) and in the OpenGL/ES Shading Language (GLSL/ES).</para>
            <para>QGLShader and QGLShaderProgram shelter the programmer from the details of compiling and linking vertex and fragment shaders.</para>
            <para>The following example creates a vertex shader program using the supplied source code. Once compiled and linked, the shader program is activated in the current QGLContext by calling QGLShaderProgram::bind():</para>
            <para>QGLShader shader(QGLShader::Vertex);</para>
            <para>shader.compileSourceCode(code);</para>
            <para></para>
            <para>QGLShaderProgram program(context);</para>
            <para>program.addShader(shader);</para>
            <para>program.link();</para>
            <para></para>
            <para>program.bind();</para>
            <para></para>
            <para>Writing Portable Shaders</para>
            <para>Shader programs can be difficult to reuse across OpenGL implementations because of varying levels of support for standard vertex attributes and uniform variables. In particular, GLSL/ES lacks all of the standard variables that are present on desktop OpenGL systems: gl_Vertex, gl_Normal, gl_Color, and so on. Desktop OpenGL lacks the variable qualifiers highp, mediump, and lowp.</para>
            <para>The QGLShaderProgram class makes the process of writing portable shaders easier by prefixing all shader programs with the following lines on desktop OpenGL:</para>
            <para>#define highp</para>
            <para>#define mediump</para>
            <para>#define lowp</para>
            <para>This makes it possible to run most GLSL/ES shader programs on desktop systems. The programmer should restrict themselves to just features that are present in GLSL/ES, and avoid standard variable names that only work on the desktop.</para>
            <para></para>
            <para>Simple Shader Example</para>
            <para>program.addShaderFromSourceCode(QGLShader::Vertex,</para>
            <para>    &quot;attribute highp vec4 vertex;\n&quot;</para>
            <para>    &quot;uniform highp mat4 matrix;\n&quot;</para>
            <para>    &quot;void main(void)\n&quot;</para>
            <para>    &quot;{\n&quot;</para>
            <para>    &quot;   gl_Position = matrix * vertex;\n&quot;</para>
            <para>    &quot;}&quot;);</para>
            <para>program.addShaderFromSourceCode(QGLShader::Fragment,</para>
            <para>    &quot;uniform mediump vec4 color;\n&quot;</para>
            <para>    &quot;void main(void)\n&quot;</para>
            <para>    &quot;{\n&quot;</para>
            <para>    &quot;   gl_FragColor = color;\n&quot;</para>
            <para>    &quot;}&quot;);</para>
            <para>program.link();</para>
            <para>program.bind();</para>
            <para></para>
            <para>int vertexLocation = program.attributeLocation(&quot;vertex&quot;);</para>
            <para>int matrixLocation = program.uniformLocation(&quot;matrix&quot;);</para>
            <para>int colorLocation = program.uniformLocation(&quot;color&quot;);</para>
            <para>With the above shader program active, we can draw a green triangle as follows:</para>
            <para>static GLfloat const triangleVertices[] = {</para>
            <para>    60.0f,  10.0f,  0.0f,</para>
            <para>    110.0f, 110.0f, 0.0f,</para>
            <para>    10.0f,  110.0f, 0.0f</para>
            <para>};</para>
            <para></para>
            <para>QColor color(0, 255, 0, 255);</para>
            <para></para>
            <para>QMatrix4x4 pmvMatrix;</para>
            <para>pmvMatrix.ortho(rect());</para>
            <para></para>
            <para>program.enableAttributeArray(vertexLocation);</para>
            <para>program.setAttributeArray(vertexLocation, triangleVertices, 3);</para>
            <para>program.setUniformValue(matrixLocation, pmvMatrix);</para>
            <para>program.setUniformValue(colorLocation, color);</para>
            <para></para>
            <para>glDrawArrays(GL_TRIANGLES, 0, 3);</para>
            <para></para>
            <para>program.disableAttributeArray(vertexLocation);</para>
            <para></para>
            <para>Binary Shaders and Programs</para>
            <para>Binary shaders may be specified using glShaderBinary() on the return value from QGLShader::shaderId(). The QGLShader instance containing the binary can then be added to the shader program with addShader() and linked in the usual fashion with link().</para>
            <para>Binary programs may be specified using glProgramBinaryOES() on the return value from programId(). Then the application should call link(), which will notice that the program has already been specified and linked, allowing other operations to be performed on the shader program.</para>
            <para>Note: This class has been deprecated in favor of QOpenGLShaderProgram.</para>
            <para></para>
            <para>See also QGLShader.</para>
            </remarks>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a new shader program and attaches it to parent. The program will be invalid until addShader() is called.</para>
            <para>The shader program will be associated with the current QGLContext.</para>
            <para>See also addShader().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.#ctor(QtOpenGL.QGLContext,QtCore.QObject)">
            <summary>
            <para>Constructs a new shader program and attaches it to parent. The program will be invalid until addShader() is called.</para>
            <para>The shader program will be associated with context.</para>
            <para>See also addShader().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShader(QtOpenGL.QGLShader)">
            <summary>
            <para>Adds a compiled shader to this shader program. Returns true if the shader could be added, or false otherwise.</para>
            <para>Ownership of the shader object remains with the caller. It will not be deleted when this QGLShaderProgram instance is deleted. This allows the caller to add the same shader to multiple shader programs.</para>
            <para>See also addShaderFromSourceCode(), addShaderFromSourceFile(), removeShader(), link(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.RemoveShader(QtOpenGL.QGLShader)">
            <summary>
            <para>Removes shader from this shader program. The object is not deleted.</para>
            <para>The shader program must be valid in the current QGLContext.</para>
            <para>See also addShader(), link(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShaderFromSourceCode(QtOpenGL.QGLShader.ShaderTypeBit,System.String)">
            <summary>
            <para>Compiles source as a shader of the specified type and adds it to this shader program. Returns true if compilation was successful, false otherwise. The compilation errors and warnings will be made available via log().</para>
            <para>This function is intended to be a short-cut for quickly adding vertex and fragment shaders to a shader program without creating an instance of QGLShader first.</para>
            <para>See also addShader(), addShaderFromSourceFile(), removeShader(), link(), log(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShaderFromSourceCode(QtOpenGL.QGLShader.ShaderTypeBit,QtCore.QByteArray)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Compiles source as a shader of the specified type and adds it to this shader program. Returns true if compilation was successful, false otherwise. The compilation errors and warnings will be made available via log().</para>
            <para>This function is intended to be a short-cut for quickly adding vertex and fragment shaders to a shader program without creating an instance of QGLShader first.</para>
            <para>See also addShader(), addShaderFromSourceFile(), removeShader(), link(), log(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShaderFromSourceCode1(QtOpenGL.QGLShader.ShaderTypeBit,System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Compiles source as a shader of the specified type and adds it to this shader program. Returns true if compilation was successful, false otherwise. The compilation errors and warnings will be made available via log().</para>
            <para>This function is intended to be a short-cut for quickly adding vertex and fragment shaders to a shader program without creating an instance of QGLShader first.</para>
            <para>See also addShader(), addShaderFromSourceFile(), removeShader(), link(), log(), and removeAllShaders().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AddShaderFromSourceFile(QtOpenGL.QGLShader.ShaderTypeBit,System.String)">
            <summary>
            <para>Compiles the contents of fileName as a shader of the specified type and adds it to this shader program. Returns true if compilation was successful, false otherwise. The compilation errors and warnings will be made available via log().</para>
            <para>This function is intended to be a short-cut for quickly adding vertex and fragment shaders to a shader program without creating an instance of QGLShader first.</para>
            <para>See also addShader() and addShaderFromSourceCode().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.RemoveAllShaders">
            <summary>
            <para>Removes all of the shaders that were added to this program previously. The QGLShader objects for the shaders will not be deleted if they were constructed externally. QGLShader objects that are constructed internally by QGLShaderProgram will be deleted.</para>
            <para>See also addShader() and removeShader().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.Bind">
            <summary>
            <para>Binds this shader program to the active QGLContext and makes it the current shader program. Any previously bound shader program is released. This is equivalent to calling glUseProgram() on programId(). Returns true if the program was successfully bound; false otherwise. If the shader program has not yet been linked, or it needs to be re-linked, this function will call link().</para>
            <para>See also link() and release().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.Release">
            <summary>
            <para>Releases the active shader program from the current QGLContext. This is equivalent to calling glUseProgram(0).</para>
            <para>See also bind().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.BindAttributeLocation(System.String,System.Int32)">
            <summary>
            <para>Binds the attribute name to the specified location. This function can be called before or after the program has been linked. Any attributes that have not been explicitly bound when the program is linked will be assigned locations automatically.</para>
            <para>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</para>
            <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.BindAttributeLocation(QtCore.QByteArray,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Binds the attribute name to the specified location. This function can be called before or after the program has been linked. Any attributes that have not been explicitly bound when the program is linked will be assigned locations automatically.</para>
            <para>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</para>
            <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.BindAttributeLocation1(System.String,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Binds the attribute name to the specified location. This function can be called before or after the program has been linked. Any attributes that have not been explicitly bound when the program is linked will be assigned locations automatically.</para>
            <para>When this function is called after the program has been linked, the program will need to be relinked for the change to take effect.</para>
            <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AttributeLocation(System.String)">
            <summary>
            <para>Returns the location of the attribute name within this shader program's parameter list. Returns -1 if name is not a valid attribute for this shader program.</para>
            <para>See also uniformLocation() and bindAttributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AttributeLocation(QtCore.QByteArray)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Returns the location of the attribute name within this shader program's parameter list. Returns -1 if name is not a valid attribute for this shader program.</para>
            <para>See also uniformLocation() and bindAttributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.AttributeLocation1(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Returns the location of the attribute name within this shader program's parameter list. Returns -1 if name is not a valid attribute for this shader program.</para>
            <para>See also uniformLocation() and bindAttributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single)">
            <summary>
            <para>Sets the attribute at location in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single,System.Single)">
            <summary>
            <para>Sets the attribute at location in the current context to the 2D vector (x, y).</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            <para>Sets the attribute at location in the current context to the 3D vector (x, y, z).</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Sets the attribute at location in the current context to the 4D vector (x, y, z, w).</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QVector2D)">
            <summary>
            <para>Sets the attribute at location in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QVector3D)">
            <summary>
            <para>Sets the attribute at location in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QVector4D)">
            <summary>
            <para>Sets the attribute at location in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,QtGui.QColor)">
            <summary>
            <para>Sets the attribute at location in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.Int32,System.Single@,System.Int32,System.Int32)">
            <summary>
            <para>Sets the attribute at location in the current context to the contents of values, which contains columns elements, each consisting of rows elements. The rows value should be 1, 2, 3, or 4. This function is typically used to set matrix values and column vectors.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to the 2D vector (x, y).</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single,System.Single,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to the 3D vector (x, y, z).</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to the 4D vector (x, y, z, w).</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QVector2D)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QVector3D)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QVector4D)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,QtGui.QColor)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to value.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeValue(System.String,System.Single@,System.Int32,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the attribute called name in the current context to the contents of values, which contains columns elements, each consisting of rows elements. The rows value should be 1, 2, 3, or 4. This function is typically used to set matrix values and column vectors.</para>
            <para>See also setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,System.Single@,System.Int32,System.Int32)">
            <summary>
            <para>Sets an array of vertex values on the attribute at location in this shader program. The tupleSize indicates the number of components per vertex (1, 2, 3, or 4), and the stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,QtGui.QVector2D,System.Int32)">
            <summary>
            <para>Sets an array of 2D vertex values on the attribute at location in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,QtGui.QVector3D,System.Int32)">
            <summary>
            <para>Sets an array of 3D vertex values on the attribute at location in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,QtGui.QVector4D,System.Int32)">
            <summary>
            <para>Sets an array of 4D vertex values on the attribute at location in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.Int32,System.UInt32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            <para>Sets an array of vertex values on the attribute at location in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The type indicates the type of elements in the values array, usually GL_FLOAT, GL_UNSIGNED_BYTE, etc. The tupleSize indicates the number of components per vertex: 1, 2, 3, or 4.</para>
            <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
            <para>The setAttributeBuffer() function can be used to set the attribute array to an offset within a vertex buffer.</para>
            <para>Note: Normalization will be enabled. If this is not desired, call glVertexAttribPointer directly through QGLFunctions.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), disableAttributeArray(), and setAttributeBuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,System.Single@,System.Int32,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets an array of vertex values on the attribute called name in this shader program. The tupleSize indicates the number of components per vertex (1, 2, 3, or 4), and the stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,QtGui.QVector2D,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets an array of 2D vertex values on the attribute called name in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,QtGui.QVector3D,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets an array of 3D vertex values on the attribute called name in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,QtGui.QVector4D,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets an array of 4D vertex values on the attribute called name in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The array will become active when enableAttributeArray() is called on name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), and disableAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeArray(System.String,System.UInt32,System.IntPtr,System.Int32,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets an array of vertex values on the attribute called name in this shader program. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in values.</para>
            <para>The type indicates the type of elements in the values array, usually GL_FLOAT, GL_UNSIGNED_BYTE, etc. The tupleSize indicates the number of components per vertex: 1, 2, 3, or 4.</para>
            <para>The array will become active when enableAttributeArray() is called on the name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
            <para>The setAttributeBuffer() function can be used to set the attribute array to an offset within a vertex buffer.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setAttributeValue(), setUniformValue(), enableAttributeArray(), disableAttributeArray(), and setAttributeBuffer().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeBuffer(System.Int32,System.UInt32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>Sets an array of vertex values on the attribute at location in this shader program, starting at a specific offset in the currently bound vertex buffer. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in the value array.</para>
            <para>The type indicates the type of elements in the vertex value array, usually GL_FLOAT, GL_UNSIGNED_BYTE, etc. The tupleSize indicates the number of components per vertex: 1, 2, 3, or 4.</para>
            <para>The array will become active when enableAttributeArray() is called on the location. Otherwise the value specified with setAttributeValue() for location will be used.</para>
            <para>Note: Normalization will be enabled. If this is not desired, call glVertexAttribPointer directly though QGLFunctions.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetAttributeBuffer(System.String,System.UInt32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets an array of vertex values on the attribute called name in this shader program, starting at a specific offset in the currently bound vertex buffer. The stride indicates the number of bytes between vertices. A default stride value of zero indicates that the vertices are densely packed in the value array.</para>
            <para>The type indicates the type of elements in the vertex value array, usually GL_FLOAT, GL_UNSIGNED_BYTE, etc. The tupleSize indicates the number of components per vertex: 1, 2, 3, or 4.</para>
            <para>The array will become active when enableAttributeArray() is called on the name. Otherwise the value specified with setAttributeValue() for name will be used.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setAttributeArray().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.EnableAttributeArray(System.Int32)">
            <summary>
            <para>Enables the vertex array at location in this shader program so that the value set by setAttributeArray() on location will be used by the shader program.</para>
            <para>See also disableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.EnableAttributeArray(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Enables the vertex array called name in this shader program so that the value set by setAttributeArray() on name will be used by the shader program.</para>
            <para>See also disableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.DisableAttributeArray(System.Int32)">
            <summary>
            <para>Disables the vertex array at location in this shader program that was enabled by a previous call to enableAttributeArray().</para>
            <para>See also enableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.DisableAttributeArray(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Disables the vertex array called name in this shader program that was enabled by a previous call to enableAttributeArray().</para>
            <para>See also enableAttributeArray(), setAttributeArray(), setAttributeValue(), and setUniformValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.UniformLocation(System.String)">
            <summary>
            <para>Returns the location of the uniform variable name within this shader program's parameter list. Returns -1 if name is not a valid uniform variable for this shader program.</para>
            <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.UniformLocation(QtCore.QByteArray)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Returns the location of the uniform variable name within this shader program's parameter list. Returns -1 if name is not a valid uniform variable for this shader program.</para>
            <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.UniformLocation1(System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Returns the location of the uniform variable name within this shader program's parameter list. Returns -1 if name is not a valid uniform variable for this shader program.</para>
            <para>See also attributeLocation().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single)">
            <summary>
            <para>Sets the uniform variable at location in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Int32)">
            <summary>
            <para>Sets the uniform variable at location in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.UInt32)">
            <summary>
            <para>Sets the uniform variable at location in the current context to value. This function should be used when setting sampler values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single,System.Single)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the 2D vector (x, y).</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single,System.Single,System.Single)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the 3D vector (x, y, z).</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the 4D vector (x, y, z, w).</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QVector2D)">
            <summary>
            <para>Sets the uniform variable at location in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QVector3D)">
            <summary>
            <para>Sets the uniform variable at location in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QVector4D)">
            <summary>
            <para>Sets the uniform variable at location in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QColor)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the red, green, blue, and alpha components of color.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QPoint)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the x and y coordinates of point.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QPointF)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the x and y coordinates of point.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QSize)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the width and height of the given size.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtCore.QSizeF)">
            <summary>
            <para>Sets the uniform variable at location in the current context to the width and height of the given size.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QMatrix4x4)">
            <summary>
            <para>Sets the uniform variable at location in the current context to a 4x4 matrix value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.Int32,QtGui.QTransform)">
            <summary>
            <para>Sets the uniform variable at location in the current context to a 3x3 transformation matrix value that is specified as a QTransform value.</para>
            <para>To set a QTransform value as a 4x4 matrix in a shader, use setUniformValue(location, QMatrix4x4(value)).</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.UInt32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to value. This function should be used when setting sampler values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to the 2D vector (x, y).</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single,System.Single,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to the 3D vector (x, y, z).</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to the 4D vector (x, y, z, w).</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QVector2D)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QVector3D)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QVector4D)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QColor)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to the red, green, blue, and alpha components of color.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QPoint)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable associated with name in the current context to the x and y coordinates of point.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QPointF)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable associated with name in the current context to the x and y coordinates of point.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QSize)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable associated with name in the current context to the width and height of the given size.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtCore.QSizeF)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable associated with name in the current context to the width and height of the given size.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QMatrix4x4)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to a 4x4 matrix value.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValue(System.String,QtGui.QTransform)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable called name in the current context to a 3x3 transformation matrix value that is specified as a QTransform value.</para>
            <para>To set a QTransform value as a 4x4 matrix in a shader, use setUniformValue(name, QMatrix4x4(value)).</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,System.Single@,System.Int32,System.Int32)">
            <summary>
            <para>Sets the uniform variable array at location in the current context to the count elements of values. Each element has tupleSize components. The tupleSize must be 1, 2, 3, or 4.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,System.Int32@,System.Int32)">
            <summary>
            <para>Sets the uniform variable array at location in the current context to the count elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,System.UInt32@,System.Int32)">
            <summary>
            <para>Sets the uniform variable array at location in the current context to the count elements of values. This overload should be used when setting an array of sampler values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QVector2D,System.Int32)">
            <summary>
            <para>Sets the uniform variable array at location in the current context to the count 2D vector elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QVector3D,System.Int32)">
            <summary>
            <para>Sets the uniform variable array at location in the current context to the count 3D vector elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QVector4D,System.Int32)">
            <summary>
            <para>Sets the uniform variable array at location in the current context to the count 4D vector elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.Int32,QtGui.QMatrix4x4,System.Int32)">
            <summary>
            <para>Sets the uniform variable array at location in the current context to the count 4x4 matrix elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,System.Single@,System.Int32,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable array called name in the current context to the count elements of values. Each element has tupleSize components. The tupleSize must be 1, 2, 3, or 4.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,System.Int32@,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable array called name in the current context to the count elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,System.UInt32@,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable array called name in the current context to the count elements of values. This overload should be used when setting an array of sampler values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QVector2D,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable array called name in the current context to the count 2D vector elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QVector3D,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable array called name in the current context to the count 3D vector elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QVector4D,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable array called name in the current context to the count 4D vector elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.SetUniformValueArray(System.String,QtGui.QMatrix4x4,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sets the uniform variable array called name in the current context to the count 4x4 matrix elements of values.</para>
            <para>See also setAttributeValue().</para>
            </summary>
        </member>
        <member name="M:QtOpenGL.QGLShaderProgram.HasOpenGLShaderPrograms(QtOpenGL.QGLContext)">
            <summary>
            <para>Returns true if shader programs written in the OpenGL Shading Language (GLSL) are supported on this system; false otherwise.</para>
            <para>The context is used to resolve the GLSL extensions. If context is null, then QGLContext::currentContext() is used.</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.GeometryOutputVertexCount">
            <summary>
            <para>Returns the maximum number of vertices the current geometry shader program will produce, if active.</para>
            <para>This parameter takes effect the ntext time the program is linked.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setGeometryOutputVertexCount().</para>
            <para></para>
            <para>Sets the maximum number of vertices the current geometry shader program will produce, if active, to count.</para>
            <para>This parameter takes effect the next time the program is linked.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also geometryOutputVertexCount().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.GeometryInputType">
            <summary>
            <para>Returns the geometry shader input type, if active.</para>
            <para>This parameter takes effect the next time the program is linked.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setGeometryInputType().</para>
            <para></para>
            <para>Sets the input type from inputType.</para>
            <para>This parameter takes effect the next time the program is linked.</para>
            <para>See also geometryInputType().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.GeometryOutputType">
            <summary>
            <para>Returns the geometry shader output type, if active.</para>
            <para>This parameter takes effect the next time the program is linked.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setGeometryOutputType().</para>
            <para></para>
            <para>Sets the output type from the geometry shader, if active, to outputType.</para>
            <para>This parameter takes effect the next time the program is linked.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also geometryOutputType().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.Link">
            <summary>
            <para>Links together the shaders that were added to this program with addShader(). Returns true if the link was successful or false otherwise. If the link failed, the error messages can be retrieved with log().</para>
            <para>Subclasses can override this function to initialize attributes and uniform variables for use in specific shader programs.</para>
            <para>If the shader program was already linked, calling this function again will force it to be re-linked.</para>
            <para>See also addShader() and log().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.IsLinked">
            <summary>
            <para>Returns true if this shader program has been linked; false otherwise.</para>
            <para>See also link().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.Log">
            <summary>
            <para>Returns the errors and warnings that occurred during the last link() or addShader() with explicitly specified source code.</para>
            <para>See also link().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.ProgramId">
            <summary>
            <para>Returns the OpenGL identifier associated with this shader program.</para>
            <para>See also QGLShader::shaderId().</para>
            </summary>
        </member>
        <member name="P:QtOpenGL.QGLShaderProgram.MaxGeometryOutputVertices">
            <summary>
            <para>Returns the hardware limit for how many vertices a geometry shader can output.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setGeometryOutputVertexCount().</para>
            </summary>
        </member>
    </members>
</doc>
