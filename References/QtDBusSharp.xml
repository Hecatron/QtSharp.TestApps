<?xml version="1.0"?>
<doc>
    <assembly>
        <name>QtDBusSharp</name>
    </assembly>
    <members>
        <member name="T:QtDBus.QDBusAbstractAdaptor">
            <summary>
            <para>The QDBusAbstractAdaptor class is the base class of D-Bus adaptor classes.</para>
            </summary>
            <remarks>
            <para>The QDBusAbstractAdaptor class is the starting point for all objects intending to provide interfaces to the external world using D-Bus. This is accomplished by attaching a one or more classes derived from QDBusAbstractAdaptor to a normal QObject and then registering that QObject with QDBusConnection::registerObject. QDBusAbstractAdaptor objects are intended to be light-weight wrappers, mostly just relaying calls into the real object (its parent) and the signals from it.</para>
            <para>Each QDBusAbstractAdaptor-derived class should define the D-Bus interface it is implementing using the Q_CLASSINFO macro in the class definition. Note that only one interface can be exposed in this way.</para>
            <para>QDBusAbstractAdaptor uses the standard QObject mechanism of signals, slots and properties to determine what signals, methods and properties to export to the bus. Any signal emitted by QDBusAbstractAdaptor-derived classes will be automatically be relayed through any D-Bus connections the object is registered on.</para>
            <para>Classes derived from QDBusAbstractAdaptor must be created on the heap using the new operator and must not be deleted by the user (they will be deleted automatically when the object they are connected to is also deleted).</para>
            <para></para>
            <para>See also Using adaptors and QDBusConnection.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusAbstractAdaptor.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QDBusAbstractAdaptor with obj as the parent object.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractAdaptor.AutoRelaySignals">
            <summary>
            <para>Returns true if automatic signal relaying from the real object (see object()) is enabled, otherwiser returns false.</para>
            <para>See also setAutoRelaySignals().</para>
            <para></para>
            <para>Toggles automatic signal relaying from the real object (see object()).</para>
            <para>Automatic signal relaying consists of signal-to-signal connection of the signals on the parent that have the exact same method signatue in both classes.</para>
            <para>If enable is set to true, connect the signals; if set to false, disconnect all signals.</para>
            <para>See also autoRelaySignals().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusError">
            <summary>
            <para>The QDBusError class represents an error received from the D-Bus bus or from remote applications found in the bus.</para>
            </summary>
            <remarks>
            <para>When dealing with the D-Bus bus service or with remote applications over D-Bus, a number of error conditions can happen. This error conditions are sometimes signalled by a returned error value or by a QDBusError.</para>
            <para>C++ and Java exceptions are a valid analogy for D-Bus errors: instead of returning normally with a return value, remote applications and the bus may decide to throw an error condition. However, the Qt D-Bus implementation does not use the C++ exception-throwing mechanism, so you will receive QDBusErrors in the return reply (see QDBusReply::error()).</para>
            <para>QDBusError objects are used to inspect the error name and message as received from the bus and remote applications. You should not create such objects yourself to signal error conditions when called from D-Bus: instead, use QDBusMessage::createError() and QDBusConnection::send().</para>
            <para></para>
            <para>See also QDBusConnection::send(), QDBusMessage, and QDBusReply.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusError.ErrorString(QtDBus.QDBusError.ErrorType)">
            <summary>
            <para>Returns the error name associated with error condition error.</para>
            <para>This function was introduced in  Qt 4.3.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusError.Type">
            <summary>
            <para>Returns this error's ErrorType.</para>
            <para>See also ErrorType.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusError.Name">
            <summary>
            <para>Returns this error's name. Error names are similar to D-Bus Interface names, like org.freedesktop.DBus.InvalidArgs.</para>
            <para>See also type().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusError.Message">
            <summary>
            <para>Returns the message that the callee associated with this error. Error messages are implementation defined and usually contain a human-readable error code, though this does not mean it is suitable for your end-users.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusError.IsValid">
            <summary>
            <para>Returns true if this is a valid error condition (i.e., if there was an error), otherwise false.</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusError.ErrorType">
            <summary>
            <para>In order to facilitate verification of the most common D-Bus errors generated by the D-Bus implementation and by the bus daemon itself, QDBusError can be compared to a set of pre-defined values:</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.NoError">
            <summary>QDBusError is invalid (i.e., the call succeeded)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.Other">
            <summary>QDBusError contains an error that is one of the well-known ones</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.Failed">
            <summary>The call failed (org.freedesktop.DBus.Error.Failed)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.NoMemory">
            <summary>Out of memory (org.freedesktop.DBus.Error.NoMemory)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.ServiceUnknown">
            <summary>The called service is not known (org.freedesktop.DBus.Error.ServiceUnknown)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.NoReply">
            <summary>The called method did not reply within the specified timeout (org.freedesktop.DBus.Error.NoReply)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.BadAddress">
            <summary>The address given is not valid (org.freedesktop.DBus.Error.BadAddress)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.NotSupported">
            <summary>The call/operation is not supported (org.freedesktop.DBus.Error.NotSupported)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.LimitsExceeded">
            <summary>The limits allocated to this process/call/connection exceeded the pre-defined values (org.freedesktop.DBus.Error.LimitsExceeded)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.AccessDenied">
            <summary>The call/operation tried to access a resource it isn't allowed to (org.freedesktop.DBus.Error.AccessDenied)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.NoServer">
            <summary>Documentation doesn't say what this is for (org.freedesktop.DBus.Error.NoServer)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.Timeout">
            <summary>Documentation doesn't say what this is for or how it's used (org.freedesktop.DBus.Error.Timeout)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.NoNetwork">
            <summary>Documentation doesn't say what this is for (org.freedesktop.DBus.Error.NoNetwork)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.AddressInUse">
            <summary>QDBusServer tried to bind to an address that is already in use (org.freedesktop.DBus.Error.AddressInUse)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.Disconnected">
            <summary>The call/process/message was sent after QDBusConnection disconnected (org.freedesktop.DBus.Error.Disconnected)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.InvalidArgs">
            <summary>The arguments passed to this call/operation are not valid (org.freedesktop.DBus.Error.InvalidArgs)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.UnknownMethod">
            <summary>The method called was not found in this object/interface with the given parameters (org.freedesktop.DBus.Error.UnknownMethod)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.TimedOut">
            <summary>Documentation doesn't say... (org.freedesktop.DBus.Error.TimedOut)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.InvalidSignature">
            <summary>The type signature is not valid or compatible (org.freedesktop.DBus.Error.InvalidSignature)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.UnknownInterface">
            <summary>The interface is not known in this object (org.freedesktop.DBus.Error.UnknownInterface)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.UnknownObject">
            <summary>The object path points to an object that does not exist (org.freedesktop.DBus.Error.UnknownObject)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.UnknownProperty">
            <summary>The property does not exist in this interface (org.freedesktop.DBus.Error.UnknownProperty)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.PropertyReadOnly">
            <summary>The property set failed because the property is read-only (org.freedesktop.DBus.Error.PropertyReadOnly)</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.InternalError">
            <summary>An internal error occurred</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.InvalidService">
            <summary>The service requested is invalid.</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.InvalidObjectPath">
            <summary>The object path provided is invalid.</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.InvalidInterface">
            <summary>The interface is invalid.</summary>
        </member>
        <member name="F:QtDBus.QDBusError.ErrorType.InvalidMember">
            <summary>The member is invalid.</summary>
        </member>
        <member name="T:QtDBus.QDBusMessage">
            <summary>
            <para>The QDBusMessage class represents one message sent or received over the D-Bus bus.</para>
            </summary>
            <remarks>
            <para>This object can represent any of the four different types of messages (MessageType) that can occur on the bus:</para>
            <para></para>
            <para>Method calls</para>
            <para>Method return values</para>
            <para>Signal emissions</para>
            <para>Error codes</para>
            <para></para>
            <para>Objects of this type are created with the static createError(), createMethodCall() and createSignal() functions. Use the QDBusConnection::send() function to send the messages.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusMessage.#ctor">
            <summary>
            <para>Constructs an empty, invalid QDBusMessage object.</para>
            <para>See also createError(), createMethodCall(), and createSignal().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.#ctor(QtDBus.QDBusMessage)">
            <summary>
            <para>Constructs a copy of the object given by other.</para>
            <para>Note: QDBusMessage objects are shared. Modifications made to the copy will affect the original one as well. See setDelayedReply() for more information.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateReply(QtCore.QVariant)">
            <summary>
            <para>Constructs a new DBus message representing a reply, with the given argument.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateErrorReply(System.String,System.String)">
            <summary>
            <para>Constructs a new DBus message representing an error reply message, with the given name and msg.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateErrorReply(QtDBus.QDBusError)">
            <summary>
            <para>Constructs a new DBus message representing an error reply message, from the given error object.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateErrorReply(QtDBus.QDBusError.ErrorType,System.String)">
            <summary>
            <para>Constructs a new DBus reply message for the error type type using the message msg. Returns the DBus message.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateSignal(System.String,System.String,System.String)">
            <summary>
            <para>Constructs a new DBus message with the given path, interface and name, representing a signal emission.</para>
            <para>A DBus signal is emitted from one application and is received by all applications that are listening for that signal from that interface.</para>
            <para>The QDBusMessage object that is returned can be sent using the QDBusConnection::send() function.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateTargetedSignal(System.String,System.String,System.String,System.String)">
            <summary>
            <para>Constructs a new DBus message with the given path, interface and name, representing a signal emission to a specific destination.</para>
            <para>A DBus signal is emitted from one application and is received only by the application owning the destination service name.</para>
            <para>The QDBusMessage object that is returned can be sent using the QDBusConnection::send() function.</para>
            <para>This function was introduced in  Qt 5.6.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateMethodCall(System.String,System.String,System.String,System.String)">
            <summary>
            <para>Constructs a new DBus message representing a method call. A method call always informs its destination address (service, path, interface and method).</para>
            <para>The DBus bus allows calling a method on a given remote object without specifying the destination interface, if the method name is unique. However, if two interfaces on the remote object export the same method name, the result is undefined (one of the two may be called or an error may be returned).</para>
            <para>When using DBus in a peer-to-peer context (i.e., not on a bus), the service parameter is optional.</para>
            <para>The QDBusInterface class provides a simpler abstraction to synchronous method calling.</para>
            <para>This function returns a QDBusMessage object that can be sent with QDBusConnection::call().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateError(System.String,System.String)">
            <summary>
            <para>Constructs a new DBus message representing an error, with the given name and msg.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateError(QtDBus.QDBusError)">
            <summary>
            <para>Constructs a new DBus message representing the given error.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusMessage.CreateError(QtDBus.QDBusError.ErrorType,System.String)">
            <summary>
            <para>Constructs a new DBus message for the error type type using the message msg. Returns the DBus message.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.DelayedReply">
            <summary>
            <para>Returns the delayed reply flag, as set by setDelayedReply(). By default, this flag is false, which means Qt D-Bus will generate automatic replies when necessary.</para>
            <para></para>
            <para>Sets whether the message will be replied later (if enable is true) or if an automatic reply should be generated by Qt D-Bus (if enable is false).</para>
            <para>In D-Bus, all method calls must generate a reply to the caller, unless the caller explicitly indicates otherwise (see isReplyRequired()). QtDBus automatically generates such replies for any slots being called, but it also allows slots to indicate whether they will take responsibility of sending the reply at a later time, after the function has finished processing.</para>
            <para>See also isDelayedReply() and Delayed Replies.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.AutoStartService">
            <summary>
            <para>Returns the auto start flag, as set by setAutoStartService(). By default, this flag is true, which means Qt D-Bus will auto start a service, if it is not running already.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also setAutoStartService().</para>
            <para></para>
            <para>Sets the auto start flag to enable. This flag only makes sense for method call messages, where it tells the D-Bus server to either auto start the service responsible for the service name, or not to auto start it.</para>
            <para>By default this flag is true, i.e. a service is autostarted. This means:</para>
            <para>When the service that this method call is sent to is already running, the method call is sent to it. If the service is not running yet, the D-Bus daemon is requested to autostart the service that is assigned to this service name. This is handled by .service files that are placed in a directory known to the D-Bus server. These files then each contain a service name and the path to a program that should be executed when this service name is requested.</para>
            <para>This function was introduced in  Qt 4.7.</para>
            <para>See also autoStartService().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.Service">
            <summary>
            <para>Returns the name of the service or the bus address of the remote method call.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.Path">
            <summary>
            <para>Returns the path of the object that this message is being sent to (in the case of a method call) or being received from (for a signal).</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.Interface">
            <summary>
            <para>Returns the interface of the method being called (in the case of a method call) or of the signal being received from.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.Member">
            <summary>
            <para>Returns the name of the signal that was emitted or the name of the method that was called.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.ErrorName">
            <summary>
            <para>Returns the name of the error that was received.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.ErrorMessage">
            <summary>
            <para>Returns the human-readable message associated with the error that was received.</para>
            <para>This function was introduced in  Qt 4.3.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.Type">
            <summary>
            <para>Returns the message type.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.Signature">
            <summary>
            <para>Returns the signature of the signal that was received or for the output arguments of a method call.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusMessage.IsReplyRequired">
            <summary>
            <para>Returns the flag that indicates if this message should see a reply or not. This is only meaningful for method call messages: any other kind of message cannot have replies and this function will always return false for them.</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusMessage.MessageType">
            <summary>
            <para>The possible message types:</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusMessage.MessageType.InvalidMessage">
            <summary>an invalid message: this is never set on messages received from D-Bus</summary>
        </member>
        <member name="F:QtDBus.QDBusMessage.MessageType.MethodCallMessage">
            <summary>a message representing an outgoing or incoming method call</summary>
        </member>
        <member name="F:QtDBus.QDBusMessage.MessageType.ReplyMessage">
            <summary>a message representing the return values of a method call</summary>
        </member>
        <member name="F:QtDBus.QDBusMessage.MessageType.ErrorMessage">
            <summary>a message representing an error condition in response to a method call</summary>
        </member>
        <member name="F:QtDBus.QDBusMessage.MessageType.SignalMessage">
            <summary>a message representing an outgoing or incoming signal emission</summary>
        </member>
        <member name="T:QtDBus.QDBusObjectPath">
            <summary>
            <para>The QDBusObjectPath class enables the programmer to identify the OBJECT_PATH type provided by the D-Bus typesystem.</para>
            </summary>
            <remarks>
            <para>See also The Qt D-Bus Type System.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusObjectPath.#ctor">
            <summary>
            <para>Constructs a new object path.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusObjectPath.#ctor(System.String)">
            <summary>
            <para>Constructs a new object path from the given path.</para>
            <para>See also setPath().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusObjectPath.#ctor(QtCore.QLatin1String)">
            <summary>
            <para>Constructs a new object path from the given path.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusObjectPath.Path">
            <summary>
            <para>Returns this object path.</para>
            <para>See also setPath().</para>
            <para></para>
            <para>Assigns the value of the given path to this object path.</para>
            <para>See also path().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusSignature">
            <summary>
            <para>The QDBusSignature class enables the programmer to identify the SIGNATURE type provided by the D-Bus typesystem.</para>
            </summary>
            <remarks>
            <para>See also The Qt D-Bus Type System.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusSignature.#ctor">
            <summary>
            <para>Constructs a new signature.</para>
            <para>See also setSignature().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusSignature.#ctor(System.String)">
            <summary>
            <para>Constructs a new signature from the given signature.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusSignature.#ctor(QtCore.QLatin1String)">
            <summary>
            <para>Constructs a new signature from the given signature.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusSignature.Signature">
            <summary>
            <para>Returns this signature.</para>
            <para>See also setSignature().</para>
            <para></para>
            <para>Assigns the value of the given signature to this signature.</para>
            <para>See also signature().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusVariant">
            <summary>
            <para>The QDBusVariant class enables the programmer to identify the variant type provided by the D-Bus typesystem.</para>
            </summary>
            <remarks>
            <para>A D-Bus function that takes an integer, a D-Bus variant and a string as parameters can be called with the following argument list (see QDBusMessage::setArguments()):</para>
            <para></para>
            <para></para>
            <para>      QList&lt;QVariant&gt; arguments;</para>
            <para>      arguments &lt;&lt; QVariant(42) &lt;&lt; QVariant::fromValue(QDBusVariant(43)) &lt;&lt; QVariant(&quot;hello&quot;);</para>
            <para>      myDBusMessage.setArguments(arguments);</para>
            <para></para>
            <para></para>
            <para>When a D-Bus function returns a D-Bus variant, it can be retrieved as follows:</para>
            <para></para>
            <para></para>
            <para>      // call a D-Bus function that returns a D-Bus variant</para>
            <para>      QVariant v = callMyDBusFunction();</para>
            <para>      // retrieve the D-Bus variant</para>
            <para>      QDBusVariant dbusVariant = qvariant_cast&lt;QDBusVariant&gt;(v);</para>
            <para>      // retrieve the actual value stored in the D-Bus variant</para>
            <para>      QVariant result = dbusVariant.variant();</para>
            <para></para>
            <para></para>
            <para>The QVariant within a QDBusVariant is required to distinguish between a normal D-Bus value and a value within a D-Bus variant.</para>
            <para></para>
            <para>See also The Qt D-Bus Type System.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusVariant.#ctor">
            <summary>
            <para>Constructs a new D-Bus variant.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusVariant.#ctor(QtCore.QVariant)">
            <summary>
            <para>Constructs a new D-Bus variant from the given Qt variant.</para>
            <para>See also setVariant().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusVariant.Variant">
            <summary>
            <para>Returns this D-Bus variant as a QVariant object.</para>
            <para>See also setVariant().</para>
            <para></para>
            <para>Assigns the value of the given Qt variant to this D-Bus variant.</para>
            <para>See also variant().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusConnection">
            <summary>
            <para>The QDBusConnection class represents a connection to the D-Bus bus daemon.</para>
            </summary>
            <remarks>
            <para>This class is the initial point in a D-Bus session. Using it, you can get access to remote objects, interfaces; connect remote signals to your object's slots; register objects, etc.</para>
            <para>D-Bus connections are created using the connectToBus() function, which opens a connection to the server daemon and does the initial handshaking, associating that connection with a name. Further attempts to connect using the same name will return the same connection.</para>
            <para>The connection is then torn down using the disconnectFromBus() function.</para>
            <para>Once disconnected, calling connectToBus() will not reestablish a connection, you must create a new QDBusConnection instance.</para>
            <para>As a convenience for the two most common connection types, the sessionBus() and systemBus() functions return open connections to the session server daemon and the system server daemon, respectively. Those connections are opened when first used and are closed when the QCoreApplication destructor is run.</para>
            <para>D-Bus also supports peer-to-peer connections, without the need for a bus server daemon. Using this facility, two applications can talk to each other and exchange messages. This can be achieved by passing an address to connectToBus() function, which was opened by another D-Bus application using QDBusServer.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusConnection.#ctor(System.String)">
            <summary>
            <para>Creates a QDBusConnection object attached to the connection with name name.</para>
            <para>This does not open the connection. You have to call connectToBus() to open it.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.#ctor(QtDBus.QDBusConnection)">
            <summary>
            <para>Creates a copy of the other connection.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Send(QtDBus.QDBusMessage)">
            <summary>
            <para>Sends the message over this connection, without waiting for a reply. This is suitable for errors, signals, and return values as well as calls whose return values are not necessary.</para>
            <para>Returns true if the message was queued successfully, false otherwise.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.CallWithCallback(QtDBus.QDBusMessage,QtCore.QObject,System.String,System.String,System.Int32)">
            <summary>
            <para>Sends the message over this connection and returns immediately. When the reply is received, the method returnMethod is called in the receiver object. If an error occurs, the method errorMethod will be called instead.</para>
            <para>If no reply is received within timeout milliseconds, an automatic error will be delivered indicating the expiration of the call. The default timeout is -1, which will be replaced with an implementation-defined value that is suitable for inter-process communications (generally, 25 seconds).</para>
            <para>This function is suitable for method calls only. It is guaranteed that the slot will be called exactly once with the reply, as long as the parameter types match and no error occurs.</para>
            <para>Returns true if the message was sent, or false if the message could not be sent.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.CallWithCallback(QtDBus.QDBusMessage,QtCore.QObject,System.String,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sends the message over this connection and returns immediately. When the reply is received, the method returnMethod is called in the receiver object.</para>
            <para>This function is suitable for method calls only. It is guaranteed that the slot will be called exactly once with the reply, as long as the parameter types match and no error occurs.</para>
            <para>This function is dangerous because it cannot report errors, including the expiration of the timeout.</para>
            <para>Returns true if the message was sent, or false if the message could not be sent.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Call(QtDBus.QDBusMessage,QtDBus.QDBus.CallMode,System.Int32)">
            <summary>
            <para>Sends the message over this connection and blocks, waiting for a reply, for at most timeout milliseconds. This function is suitable for method calls only. It returns the reply message as its return value, which will be either of type QDBusMessage::ReplyMessage or QDBusMessage::ErrorMessage.</para>
            <para>If no reply is received within timeout milliseconds, an automatic error will be delivered indicating the expiration of the call. The default timeout is -1, which will be replaced with an implementation-defined value that is suitable for inter-process communications (generally, 25 seconds).</para>
            <para>See the QDBusInterface::call() function for a more friendly way of placing calls.</para>
            <para>Warning: If mode is QDBus::BlockWithGui, this function will reenter the Qt event loop in order to wait for the reply. During the wait, it may deliver signals and other method calls to your application. Therefore, it must be prepared to handle a reentrancy whenever a call is placed with call().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.AsyncCall(QtDBus.QDBusMessage,System.Int32)">
            <summary>
            <para>Sends the message over this connection and returns immediately. This function is suitable for method calls only. It returns an object of type QDBusPendingCall which can be used to track the status of the reply.</para>
            <para>If no reply is received within timeout milliseconds, an automatic error will be delivered indicating the expiration of the call. The default timeout is -1, which will be replaced with an implementation-defined value that is suitable for inter-process communications (generally, 25 seconds). This timeout is also the upper limit for waiting in QDBusPendingCall::waitForFinished().</para>
            <para>See the QDBusInterface::asyncCall() function for a more friendly way of placing calls.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Connect(System.String,System.String,System.String,System.String,QtCore.QObject,System.String)">
            <summary>
            <para>Connects the signal specified by the service, path, interface and name parameters to the slot slot in object receiver. The arguments service and path can be empty, denoting a connection to any signal of the (interface, name) pair, from any remote application.</para>
            <para>Returns true if the connection was successful.</para>
            <para>Warning: The signal will only be delivered to the slot if the parameters match. This verification can be done only when the signal is received, not at connection time.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Connect(System.String,System.String,System.String,System.String,System.String,QtCore.QObject,System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Connects the signal to the slot slot in object receiver. Unlike the previous connect() overload, this function allows one to specify the parameter signature to be connected using the signature variable. The function will then verify that this signature can be delivered to the slot specified by slot and return false otherwise.</para>
            <para>Returns true if the connection was successful.</para>
            <para>Note: This function verifies that the signal signature matches the slot's parameters, but it does not verify that the actual signal exists with the given signature in the remote service.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Connect(System.String,System.String,System.String,System.String,QtCore.QStringList,System.String,QtCore.QObject,System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Connects the signal to the slot slot in object receiver. Unlike the previous connect() overload, this function allows one to specify the parameter signature to be connected using the signature variable. The function will then verify that this signature can be delivered to the slot specified by slot and return false otherwise.</para>
            <para>The argumentMatch parameter lists the string parameters to be matched, in sequential order. Note that, to match an empty string, you need to pass a QString that is empty but not null (i.e., QString(&quot;&quot;)). A null QString skips matching at that position.</para>
            <para>Returns true if the connection was successful.</para>
            <para>Note: This function verifies that the signal signature matches the slot's parameters, but it does not verify that the actual signal exists with the given signature in the remote service.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Disconnect(System.String,System.String,System.String,System.String,QtCore.QObject,System.String)">
            <summary>
            <para>Disconnects the signal specified by the service, path, interface and name parameters from the slot slot in object receiver. The arguments must be the same as passed to the connect() function.</para>
            <para>Returns true if the disconnection was successful.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Disconnect(System.String,System.String,System.String,System.String,System.String,QtCore.QObject,System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Disconnects the signal specified by the service, path, interface, name, and signature parameters from the slot slot in object receiver. The arguments must be the same as passed to the connect() function.</para>
            <para>Returns true if the disconnection was successful.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.Disconnect(System.String,System.String,System.String,System.String,QtCore.QStringList,System.String,QtCore.QObject,System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Disconnects the signal specified by the service, path, interface, name, argumentMatch, and signature parameters from the slot slot in object receiver. The arguments must be the same as passed to the connect() function.</para>
            <para>Returns true if the disconnection was successful.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.RegisterObject(System.String,QtCore.QObject,QtDBus.QDBusConnection.RegisterOption)">
            <summary>
            <para>Registers the object object at path path and returns true if the registration was successful. The options parameter specifies how much of the object object will be exposed through D-Bus.</para>
            <para>This function does not replace existing objects: if there is already an object registered at path path, this function will return false. Use unregisterObject() to unregister it first.</para>
            <para>You cannot register an object as a child object of an object that was registered with QDBusConnection::ExportChildObjects.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.RegisterObject(System.String,System.String,QtCore.QObject,QtDBus.QDBusConnection.RegisterOption)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Registers the object object at path path with interface name interface and returns true if the registration was successful. The options parameter specifies how much of the object object will be exposed through D-Bus.</para>
            <para>This function does not replace existing objects: if there is already an object registered at path path, this function will return false. Use unregisterObject() to unregister it first.</para>
            <para>You cannot register an object as a child object of an object that was registered with QDBusConnection::ExportChildObjects.</para>
            <para>This function was introduced in  Qt 5.5.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.UnregisterObject(System.String,QtDBus.QDBusConnection.UnregisterMode)">
            <summary>
            <para>Unregisters an object that was registered with the registerObject() at the object path given by path and, if mode is QDBusConnection::UnregisterTree, all of its sub-objects too.</para>
            <para>Note that you cannot unregister objects that were not registered with registerObject().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.ObjectRegisteredAt(System.String)">
            <summary>
            <para>Return the object that was registered with the registerObject() at the object path given by path.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.RegisterService(System.String)">
            <summary>
            <para>Attempts to register the serviceName on the D-Bus server and returns true if the registration succeeded. The registration will fail if the name is already registered by another application.</para>
            <para>See also unregisterService() and QDBusConnectionInterface::registerService().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.UnregisterService(System.String)">
            <summary>
            <para>Unregisters the service serviceName that was previously registered with registerService() and returns true if it succeeded.</para>
            <para>See also registerService() and QDBusConnectionInterface::unregisterService().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.ConnectToBus(QtDBus.QDBusConnection.BusType,System.String)">
            <summary>
            <para>Opens a connection of type type to one of the known busses and associate with it the connection name name. Returns a QDBusConnection object associated with that connection.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.ConnectToBus(System.String,System.String)">
            <summary>
            <para>Opens a connection to a private bus on address address and associate with it the connection name name. Returns a QDBusConnection object associated with that connection.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.ConnectToPeer(System.String,System.String)">
            <summary>
            <para>Opens a peer-to-peer connection on address address and associate with it the connection name name. Returns a QDBusConnection object associated with that connection.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.DisconnectFromBus(System.String)">
            <summary>
            <para>Closes the bus connection of name name.</para>
            <para>Note that if there are still QDBusConnection objects associated with the same connection, the connection will not be closed until all references are dropped. However, no further references can be created using the QDBusConnection constructor.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusConnection.DisconnectFromPeer(System.String)">
            <summary>
            <para>Closes the peer connection of name name.</para>
            <para>Note that if there are still QDBusConnection objects associated with the same connection, the connection will not be closed until all references are dropped. However, no further references can be created using the QDBusConnection constructor.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.IsConnected">
            <summary>
            <para>Returns true if this QDBusConnection object is connected.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.BaseService">
            <summary>
            <para>Returns the unique connection name for this connection, if this QDBusConnection object is connected, or an empty QString otherwise.</para>
            <para>A Unique Connection Name is a string in the form &quot;:x.xxx&quot; (where x are decimal digits) that is assigned by the D-Bus server daemon upon connection. It uniquely identifies this client in the bus.</para>
            <para>This function returns an empty QString for peer-to-peer connections.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.LastError">
            <summary>
            <para>Returns the last error that happened in this connection.</para>
            <para>This function is provided for low-level code. If you're using QDBusInterface::call(), error codes are reported by its return value.</para>
            <para>See also QDBusInterface and QDBusMessage.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.Name">
            <summary>
            <para>Returns the connection name for this connection, as given as the name parameter to connectToBus().</para>
            <para>The connection name can be used to uniquely identify actual underlying connections to buses. Copies made from a single connection will always implicitly share the underlying connection, and hence will have the same connection name.</para>
            <para>Inversely, two connections having different connection names will always either be connected to different buses, or have a different unique name (as returned by baseService()) on that bus.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also connectToBus() and disconnectFromBus().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.ConnectionCapabilities">
            <summary>
            <para>Returns the capabilities of this connection as negotiated with the bus server or peer. If this QDBusConnection is not connected, this function returns no capabilities.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.Interface">
            <summary>
            <para>Returns a QDBusConnectionInterface object that represents the D-Bus server interface on this connection.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.LocalMachineId">
            <summary>
            <para>Returns the local machine ID as known to the D-Bus system. Each node or host that runs D-Bus has a unique identifier that can be used to distinguish it from other hosts if they are sharing resources like the filesystem.</para>
            <para>Note that the local machine ID is not guaranteed to be persistent across boots of the system, so this identifier should not be stored in persistent storage (like the filesystem). It is guaranteed to remain constant only during the lifetime of this boot session.</para>
            <para>This function was introduced in  Qt 4.8.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.SessionBus">
            <summary>
            <para>Returns a QDBusConnection object opened with the session bus. The object reference returned by this function is valid until the application terminates, at which point the connection will be closed and the object deleted.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.SystemBus">
            <summary>
            <para>Returns a QDBusConnection object opened with the system bus. The object reference returned by this function is valid until the QCoreApplication's destructor is run, when the connection will be closed and the object, deleted.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusConnection.Sender">
            <summary>
            <para>Always returns a disconnected, invalid QDBusConnection object. For the old functionality of determining the sender connection, please use QDBusContext.</para>
            <para>See also QDBusContext.</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusConnection.BusType">
            <summary>
            <para>Specifies the type of the bus connection. The valid bus types are:</para>
            <para>On the Session Bus, one can find other applications by the same user that are sharing the same desktop session (hence the name). On the System Bus, however, processes shared for the whole system are usually found.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.BusType.SessionBus">
            <summary>the session bus, associated with the running desktop session</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.BusType.SystemBus">
            <summary>the system bus, used to communicate with system-wide processes</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.BusType.ActivationBus">
            <summary>the activation bus, the "alias" for the bus that started the service</summary>
        </member>
        <member name="T:QtDBus.QDBusConnection.RegisterOption">
            <summary>
            <para>Specifies the options for registering objects with the connection. The possible values are:</para>
            <para>The RegisterOptions type is a typedef for QFlags&lt;RegisterOption&gt;. It stores an OR combination of RegisterOption values.</para>
            <para>See also registerObject(), QDBusAbstractAdaptor, and Using adaptors.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportAdaptors">
            <summary>export the contents of adaptors found in this object</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportScriptableSlots">
            <summary>export this object's scriptable slots</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportScriptableSignals">
            <summary>export this object's scriptable signals</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportScriptableProperties">
            <summary>export this object's scriptable properties</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportScriptableInvokables">
            <summary>export this object's scriptable invokables</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportScriptableContents">
            <summary>shorthand form for ExportScriptableSlots | ExportScriptableSignals | ExportScriptableProperties</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportNonScriptableSlots">
            <summary>export this object's non-scriptable slots</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportNonScriptableSignals">
            <summary>export this object's non-scriptable signals</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportNonScriptableProperties">
            <summary>export this object's non-scriptable properties</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportNonScriptableInvokables">
            <summary>export this object's non-scriptable invokables</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportNonScriptableContents">
            <summary>shorthand form for ExportNonScriptableSlots | ExportNonScriptableSignals | ExportNonScriptableProperties</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportAllSlots">
            <summary>export all of this object's slots</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportAllSignals">
            <summary>export all of this object's signals</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportAllProperties">
            <summary>export all of this object's properties</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportAllInvokables">
            <summary>export all of this object's invokables</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportAllContents">
            <summary>export all of this object's contents</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.RegisterOption.ExportChildObjects">
            <summary>export this object's child objects</summary>
        </member>
        <member name="T:QtDBus.QDBusConnection.UnregisterMode">
            <summary>
            <para>The mode for unregistering an object path:</para>
            <para>Note, however, if this object was registered with the ExportChildObjects option, UnregisterNode will unregister the child objects too.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.UnregisterMode.UnregisterNode">
            <summary>unregister this node only: do not unregister child objects</summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.UnregisterMode.UnregisterTree">
            <summary>unregister this node and all its sub-tree</summary>
        </member>
        <member name="T:QtDBus.QDBusConnection.ConnectionCapability">
            <summary>
            <para>This enum describes the available capabilities for a D-Bus connection.</para>
            <para>This enum was introduced or modified in  Qt 4.8.</para>
            <para>The ConnectionCapabilities type is a typedef for QFlags&lt;ConnectionCapability&gt;. It stores an OR combination of ConnectionCapability values.</para>
            <para>See also connectionCapabilities().</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusConnection.ConnectionCapability.UnixFileDescriptorPassing">
            <summary>enables passing of Unix file descriptors to other processes (see QDBusUnixFileDescriptor)</summary>
        </member>
        <member name="T:QtDBus.QDBus.CallMode">
            <summary>
            <para>This enum describes the various ways of placing a function call. The valid modes are:</para>
            <para>When using BlockWithGui, applications must be prepared for reentrancy in any function.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBus.CallMode.NoBlock">
            <summary>Place the call but don't wait for the reply (the reply's contents will be discarded).</summary>
        </member>
        <member name="F:QtDBus.QDBus.CallMode.Block">
            <summary>Don't use an event loop to wait for a reply, but instead block on network operations while waiting. This means the user-interface may not be updated until the function returns.</summary>
        </member>
        <member name="F:QtDBus.QDBus.CallMode.BlockWithGui">
            <summary>Use the Qt event loop to wait for a reply. This means that the user-interface will stay responsive (processing input events), but it also means other events may happen, like signal delivery and other D-Bus method calls.</summary>
        </member>
        <member name="F:QtDBus.QDBus.CallMode.AutoDetect">
            <summary>Automatically detect if the called function has a reply.</summary>
        </member>
        <member name="T:QtDBus.QDBusAbstractInterface">
            <summary>
            <para>The QDBusAbstractInterface class is the base class for all D-Bus interfaces in the Qt D-Bus binding, allowing access to remote interfaces</para>
            </summary>
            <remarks>
            <para>Generated-code classes also derive from QDBusAbstractInterface, all methods described here are also valid for generated-code classes. In addition to those described here, generated-code classes provide member functions for the remote methods, which allow for compile-time checking of the correct parameters and return values, as well as property type-matching and signal parameter-matching.</para>
            <para></para>
            <para>See also The QDBus compiler and QDBusInterface.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusAbstractInterface.Call(System.String,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant)">
            <summary>
            <para>Calls the method method on this interface and passes the parameters to this function to the method.</para>
            <para>The parameters to call are passed on to the remote function via D-Bus as input arguments. Output arguments are returned in the QDBusMessage reply. If the reply is an error reply, lastError() will also be set to the contents of the error message.</para>
            <para>This function can be used with up to 8 parameters, passed in arguments arg1, arg2, arg3, arg4, arg5, arg6, arg7 and arg8. If you need more than 8 parameters or if you have a variable number of parameters to be passed, use callWithArgumentList().</para>
            <para>It can be used the following way:</para>
            <para></para>
            <para></para>
            <para>  QString value = retrieveValue();</para>
            <para>  QDBusMessage reply;</para>
            <para></para>
            <para>  QDBusReply&lt;int&gt; api = interface-&gt;call(QLatin1String(&quot;GetAPIVersion&quot;));</para>
            <para>  if (api &gt;= 14)</para>
            <para>    reply = interface-&gt;call(QLatin1String(&quot;ProcessWorkUnicode&quot;), value);</para>
            <para>  else</para>
            <para>    reply = interface-&gt;call(QLatin1String(&quot;ProcessWork&quot;), QLatin1String(&quot;UTF-8&quot;), value.toUtf8());</para>
            <para></para>
            <para></para>
            <para>This example illustrates function calling with 0, 1 and 2 parameters and illustrates different parameter types passed in each (the first call to &quot;ProcessWorkUnicode&quot; will contain one Unicode string, the second call to &quot;ProcessWork&quot; will contain one string and one byte array).</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusAbstractInterface.Call(QtDBus.QDBus.CallMode,System.String,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Calls the method method on this interface and passes the parameters to this function to the method. If mode is NoWaitForReply, then this function will return immediately after placing the call, without waiting for a reply from the remote method. Otherwise, mode indicates whether this function should activate the Qt Event Loop while waiting for the reply to arrive.</para>
            <para>This function can be used with up to 8 parameters, passed in arguments arg1, arg2, arg3, arg4, arg5, arg6, arg7 and arg8. If you need more than 8 parameters or if you have a variable number of parameters to be passed, use callWithArgumentList().</para>
            <para>If this function reenters the Qt event loop in order to wait for the reply, it will exclude user input. During the wait, it may deliver signals and other method calls to your application. Therefore, it must be prepared to handle a reentrancy whenever a call is placed with call().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusAbstractInterface.AsyncCall(System.String,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant,QtCore.QVariant)">
            <summary>
            <para>Calls the method method on this interface and passes the parameters to this function to the method.</para>
            <para>The parameters to call are passed on to the remote function via D-Bus as input arguments. The returned QDBusPendingCall object can be used to find out information about the reply.</para>
            <para>This function can be used with up to 8 parameters, passed in arguments arg1, arg2, arg3, arg4, arg5, arg6, arg7 and arg8. If you need more than 8 parameters or if you have a variable number of parameters to be passed, use asyncCallWithArgumentList().</para>
            <para>It can be used the following way:</para>
            <para></para>
            <para></para>
            <para>  QString value = retrieveValue();</para>
            <para>  QDBusPendingCall pcall = interface-&gt;asyncCall(QLatin1String(&quot;Process&quot;), value);</para>
            <para></para>
            <para>  QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(pcall, this);</para>
            <para></para>
            <para>  QObject::connect(watcher, SIGNAL(finished(QDBusPendingCallWatcher*)),</para>
            <para>                   this, SLOT(callFinishedSlot(QDBusPendingCallWatcher*)));</para>
            <para></para>
            <para></para>
            <para>This example illustrates function calling with 0, 1 and 2 parameters and illustrates different parameter types passed in each (the first call to &quot;ProcessWorkUnicode&quot; will contain one Unicode string, the second call to &quot;ProcessWork&quot; will contain one string and one byte array).</para>
            <para>This function was introduced in  Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractInterface.Timeout">
            <summary>
            <para>Returns the current value of the timeout in milliseconds. -1 means the default DBus timeout (usually 25 seconds).</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also setTimeout().</para>
            <para></para>
            <para>Sets the timeout in milliseconds for all future DBus calls to timeout. -1 means the default DBus timeout (usually 25 seconds).</para>
            <para>This function was introduced in  Qt 4.8.</para>
            <para>See also timeout().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractInterface.IsValid">
            <summary>
            <para>Returns true if this is a valid reference to a remote object. It returns false if there was an error during the creation of this interface (for instance, if the remote application does not exist).</para>
            <para>Note: when dealing with remote objects, it is not always possible to determine if it exists when creating a QDBusInterface.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractInterface.Connection">
            <summary>
            <para>Returns the connection this interface is assocated with.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractInterface.Service">
            <summary>
            <para>Returns the name of the service this interface is associated with.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractInterface.Path">
            <summary>
            <para>Returns the object path that this interface is associated with.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractInterface.Interface">
            <summary>
            <para>Returns the name of this interface.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusAbstractInterface.LastError">
            <summary>
            <para>Returns the error the last operation produced, or an invalid error if the last operation did not produce an error.</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusArgument">
            <summary>
            <para>The QDBusArgument class is used to marshall and demarshall D-Bus arguments.</para>
            </summary>
            <remarks>
            <para>The class is used to send arguments over D-Bus to remote applications and to receive them back. D-Bus offers an extensible type system, based on a few primitive types and associations of them. See the Qt D-Bus Type System page for more information on the type system.</para>
            <para>QDBusArgument is the central class in the Qt D-Bus type system, providing functions to marshall and demarshall the primitive types. The compound types are then created by association of one or more of the primitive types in arrays, dictionaries or structures.</para>
            <para>The following example illustrates how a structure containing an integer and a string can be constructed using the Qt D-Bus type system:</para>
            <para></para>
            <para></para>
            <para>  struct MyStructure</para>
            <para>  {</para>
            <para>      int count;</para>
            <para>      QString name;</para>
            <para>  };</para>
            <para>  Q_DECLARE_METATYPE(MyStructure)</para>
            <para></para>
            <para>  // Marshall the MyStructure data into a D-Bus argument</para>
            <para>  QDBusArgument &amp;operator&lt;&lt;(QDBusArgument &amp;argument, const MyStructure &amp;mystruct)</para>
            <para>  {</para>
            <para>      argument.beginStructure();</para>
            <para>      argument &lt;&lt; mystruct.count &lt;&lt; mystruct.name;</para>
            <para>      argument.endStructure();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para>  // Retrieve the MyStructure data from the D-Bus argument</para>
            <para>  const QDBusArgument &amp;operator&gt;&gt;(const QDBusArgument &amp;argument, MyStructure &amp;mystruct)</para>
            <para>  {</para>
            <para>      argument.beginStructure();</para>
            <para>      argument &gt;&gt; mystruct.count &gt;&gt; mystruct.name;</para>
            <para>      argument.endStructure();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>The type has to be registered with qDBusRegisterMetaType() before it can be used with QDBusArgument. Therefore, somewhere in your program, you should add the following code:</para>
            <para></para>
            <para></para>
            <para>  qDBusRegisterMetaType&lt;MyStructure&gt;();</para>
            <para></para>
            <para></para>
            <para>Once registered, a type can be used in outgoing method calls (placed with QDBusAbstractInterface::call()), signal emissions from registered objects or in incoming calls from remote applications.</para>
            <para>It is important to note that the operator&lt;&lt; and operator&gt;&gt; streaming functions must always produce the same number of entries in case of structures, both in reading and in writing (marshalling and demarshalling), otherwise calls and signals may start to silently fail.</para>
            <para>The following example illustrates this wrong usage in context of a class that may contain invalid data:</para>
            <para></para>
            <para></para>
            <para>  //bad code</para>
            <para>      // Wrongly marshall the MyTime data into a D-Bus argument</para>
            <para>      QDBusArgument &amp;operator&lt;&lt;(QDBusArgument &amp;argument, const MyTime &amp;mytime)</para>
            <para>      {</para>
            <para>          argument.beginStructure();</para>
            <para>          if (mytime.isValid)</para>
            <para>              argument &lt;&lt; true &lt;&lt; mytime.hour</para>
            <para>                       &lt;&lt; mytime.minute &lt;&lt; mytime.second;</para>
            <para>          else</para>
            <para>              argument &lt;&lt; false;</para>
            <para>          argument.endStructure();</para>
            <para>          return argument;</para>
            <para>      }</para>
            <para></para>
            <para></para>
            <para>In this example, both the operator&lt;&lt; and the operator&gt;&gt; functions may produce a different number of reads/writes. This can confuse the Qt D-Bus type system and should be avoided.</para>
            <para></para>
            <para>See also QDBusAbstractInterface, The Qt D-Bus type system, Using Adaptors, and qdbus_cast().</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusArgument.#ctor">
            <summary>
            <para>Constructs an empty QDBusArgument argument.</para>
            <para>An empty QDBusArgument object does not allow either reading or writing to be performed.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.#ctor(QtDBus.QDBusArgument)">
            <summary>
            <para>Constructs a copy of the other QDBusArgument object.</para>
            <para>Both objects will therefore contain the same state from this point forward. QDBusArguments are explicitly shared and, therefore, any modification to either copy will affect the other one too.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.op_LeftShift(QtDBus.QDBusArgument,System.Int32)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Appends the primitive value arg of type INT32 to the D-Bus stream.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.BeginStructure">
            <summary>
            <para>Opens a new D-Bus structure suitable for appending new arguments.</para>
            <para>This function is used usually in operator&lt;&lt; streaming operators, as in the following example:</para>
            <para></para>
            <para></para>
            <para>  QDBusArgument &amp;operator&lt;&lt;(QDBusArgument &amp;argument, const MyStructure &amp;mystruct)</para>
            <para>  {</para>
            <para>      argument.beginStructure();</para>
            <para>      argument &lt;&lt; mystruct.member1 &lt;&lt; mystruct.member2 &lt;&lt; ... ;</para>
            <para>      argument.endStructure();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Structures can contain other structures, so the following code is also valid:</para>
            <para></para>
            <para></para>
            <para>  QDBusArgument &amp;operator&lt;&lt;(QDBusArgument &amp;argument, const MyStructure &amp;mystruct)</para>
            <para>  {</para>
            <para>      argument.beginStructure();</para>
            <para>      argument &lt;&lt; mystruct.member1 &lt;&lt; mystruct.member2;</para>
            <para></para>
            <para>      argument.beginStructure();</para>
            <para>      argument &lt;&lt; mystruct.member3.subMember1 &lt;&lt; mystruct.member3.subMember2;</para>
            <para>      argument.endStructure();</para>
            <para></para>
            <para>      argument &lt;&lt; mystruct.member4;</para>
            <para>      argument.endStructure();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>See also endStructure(), beginArray(), and beginMap().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.EndStructure">
            <summary>
            <para>Closes a D-Bus structure opened with beginStructure(). This function must be called same number of times that beginStructure() is called.</para>
            <para>See also beginStructure(), endArray(), and endMap().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.BeginArray(System.Int32)">
            <summary>
            <para>Opens a new D-Bus array suitable for appending elements of meta-type id.</para>
            <para>This function is used usually in operator&lt;&lt; streaming operators, as in the following example:</para>
            <para></para>
            <para></para>
            <para>  // append an array of MyElement types</para>
            <para>  QDBusArgument &amp;operator&lt;&lt;(QDBusArgument &amp;argument, const MyArray &amp;myarray)</para>
            <para>  {</para>
            <para>      argument.beginArray( qMetaTypeId&lt;MyElement&gt;() );</para>
            <para>      for ( int i = 0; i &lt; myarray.length; ++i )</para>
            <para>          argument &lt;&lt; myarray.elements[i];</para>
            <para>      argument.endArray();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>If the type you want to marshall is a QList, QVector or any of the Qt's Container Classes that take one template parameter, you need not declare an operator&lt;&lt; function for it, since Qt D-Bus provides generic templates to do the job of marshalling the data. The same applies for STL's sequence containers, such as std::list, std::vector, etc.</para>
            <para>See also endArray(), beginStructure(), and beginMap().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.EndArray">
            <summary>
            <para>Closes a D-Bus array opened with beginArray(). This function must be called same number of times that beginArray() is called.</para>
            <para>See also beginArray(), endStructure(), and endMap().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.BeginMap(System.Int32,System.Int32)">
            <summary>
            <para>Opens a new D-Bus map suitable for appending elements. Maps are containers that associate one entry (the key) to another (the value), such as Qt's QMap or QHash. The ids of the map's key and value meta types must be passed in kid and vid respectively.</para>
            <para>This function is used usually in operator&lt;&lt; streaming operators, as in the following example:</para>
            <para></para>
            <para></para>
            <para>  // append a dictionary that associates ints to MyValue types</para>
            <para>  QDBusArgument &amp;operator&lt;&lt;(QDBusArgument &amp;argument, const MyDictionary &amp;mydict)</para>
            <para>  {</para>
            <para>      argument.beginMap( QVariant::Int, qMetaTypeId&lt;MyValue&gt;() );</para>
            <para>      for ( int i = 0; i &lt; mydict.length; ++i ) {</para>
            <para>          argument.beginMapEntry();</para>
            <para>          argument &lt;&lt; mydict.data[i].key &lt;&lt; mydict.data[i].value;</para>
            <para>          argument.endMapEntry();</para>
            <para>      }</para>
            <para>      argument.endMap();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>If the type you want to marshall is a QMap or QHash, you need not declare an operator&lt;&lt; function for it, since Qt D-Bus provides generic templates to do the job of marshalling the data.</para>
            <para>See also endMap(), beginStructure(), beginArray(), and beginMapEntry().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.EndMap">
            <summary>
            <para>Closes a D-Bus map opened with beginMap(). This function must be called same number of times that beginMap() is called.</para>
            <para>See also beginMap(), endStructure(), and endArray().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.BeginMapEntry">
            <summary>
            <para>Opens a D-Bus map entry suitable for appending the key and value entries. This function is only valid when a map has been opened with beginMap().</para>
            <para>See beginMap() for an example of usage of this function.</para>
            <para>See also endMapEntry() and beginMap().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.EndMapEntry">
            <summary>
            <para>Closes a D-Bus map entry opened with beginMapEntry(). This function must be called same number of times that beginMapEntry() is called.</para>
            <para>See also beginMapEntry().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.BeginArray">
            <summary>
            <para>Recurses into the D-Bus array to allow extraction of the array elements.</para>
            <para>This function is used usually in operator&gt;&gt; streaming operators, as in the following example:</para>
            <para></para>
            <para></para>
            <para>  // extract a MyArray array of MyElement elements</para>
            <para>  const QDBusArgument &amp;operator&gt;&gt;(const QDBusArgument &amp;argument, MyArray &amp;myarray)</para>
            <para>  {</para>
            <para>      argument.beginArray();</para>
            <para>      myarray.clear();</para>
            <para></para>
            <para>      while ( !argument.atEnd() ) {</para>
            <para>          MyElement element;</para>
            <para>          argument &gt;&gt; element;</para>
            <para>          myarray.append( element );</para>
            <para>      }</para>
            <para></para>
            <para>      argument.endArray();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>If the type you want to demarshall is a QList, QVector or any of the Qt's Container Classes that take one template parameter, you need not declare an operator&gt;&gt; function for it, since Qt D-Bus provides generic templates to do the job of demarshalling the data. The same applies for STL's sequence containers, such as std::list, std::vector, etc.</para>
            <para>See also atEnd(), beginStructure(), and beginMap().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.BeginMap">
            <summary>
            <para>Recurses into the D-Bus map to allow extraction of the map's elements.</para>
            <para>This function is used usually in operator&gt;&gt; streaming operators, as in the following example:</para>
            <para></para>
            <para></para>
            <para>  // extract a MyDictionary map that associates ints to MyValue elements</para>
            <para>  const QDBusArgument &amp;operator&gt;&gt;(const QDBusArgument &amp;argument, MyDictionary &amp;mydict)</para>
            <para>  {</para>
            <para>      argument.beginMap();</para>
            <para>      mydict.clear();</para>
            <para></para>
            <para>      while ( !argMap.atEnd() ) {</para>
            <para>          int key;</para>
            <para>          MyValue value;</para>
            <para>          argument.beginMapEntry();</para>
            <para>          argument &gt;&gt; key &gt;&gt; value;</para>
            <para>          argument.endMapEntry();</para>
            <para>          mydict.append( key, value );</para>
            <para>      }</para>
            <para></para>
            <para>      argument.endMap();</para>
            <para>      return argument;</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>If the type you want to demarshall is a QMap or QHash, you need not declare an operator&gt;&gt; function for it, since Qt D-Bus provides generic templates to do the job of demarshalling the data.</para>
            <para>See also endMap(), beginStructure(), beginArray(), and beginMapEntry().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.Qdbus_cast(QtDBus.QDBusArgument,QtCore.QVariant)">
            <summary>
            <para>Attempts to demarshall the contents of argument into the type T. For example:</para>
            <para></para>
            <para></para>
            <para>  MyType item = qdbus_cast&lt;Type&gt;(argument);</para>
            <para></para>
            <para></para>
            <para>Note that it is equivalent to the following:</para>
            <para></para>
            <para></para>
            <para>  MyType item;</para>
            <para>  argument &gt;&gt; item;</para>
            <para></para>
            <para></para>
            <para>This function was introduced in  Qt 4.2.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusArgument.Qdbus_cast(QtCore.QVariant,QtCore.QVariant)">
            <summary>
            <para>Attempts to demarshall the contents of argument into the type T. For example:</para>
            <para></para>
            <para></para>
            <para>  MyType item = qdbus_cast&lt;Type&gt;(argument);</para>
            <para></para>
            <para></para>
            <para>Note that it is equivalent to the following:</para>
            <para></para>
            <para></para>
            <para>  MyType item;</para>
            <para>  argument &gt;&gt; item;</para>
            <para></para>
            <para></para>
            <para>This function was introduced in  Qt 4.2.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusArgument.CurrentType">
            <summary>
            <para>Returns the classification of the current element type. If an error decoding the type occurs or if we're at the end of the argument, this function returns QDBusArgument::UnknownType.</para>
            <para>This function only makes sense when demarshalling arguments. If it is used while marshalling, it will always return UnknownType.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusArgument.AtEnd">
            <summary>
            <para>Returns true if there are no more elements to be extracted from this QDBusArgument. This function is usually used in QDBusArgument objects returned from beginMap() and beginArray().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusArgument.AsVariant">
            <summary>
            <para>Returns the current argument in the form of a QVariant. Basic types will be decoded and returned in the QVariant, but for complex types, this function will return a QDBusArgument object in the QVariant. It is the caller's responsibility to decode the argument (for example, by calling asVariant() in it).</para>
            <para>For example, if the current argument is an INT32, this function will return a QVariant with an argument of type QVariant::Int. For an array of INT32, it will return a QVariant containing a QDBusArgument.</para>
            <para>If an error occurs or if there are no more arguments to decode (i.e., we are at the end of the argument list), this function will return an invalid QVariant.</para>
            <para>This function was introduced in  Qt 4.5.</para>
            <para>See also atEnd().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusArgument.ElementType">
            <summary>
            <para>This enum describes the type of element held by the argument.</para>
            <para>This enum was introduced or modified in  Qt 4.5.</para>
            <para>See also currentType().</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusArgument.ElementType.BasicType">
            <summary>A basic element, which is understood by QVariant. The following types are considered basic: bool, byte, short, ushort, int, uint, qint64, quint64, double, QString, QByteArray, QDBusObjectPath, QDBusSignature</summary>
        </member>
        <member name="F:QtDBus.QDBusArgument.ElementType.VariantType">
            <summary>The variant element (QDBusVariant)</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:QtDBus.QDBusArgument.ElementType.ArrayType" -->
        <member name="F:QtDBus.QDBusArgument.ElementType.StructureType">
            <summary>A custom type represented by a structure, like QDateTime, QPoint, etc.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:QtDBus.QDBusArgument.ElementType.MapType" -->
        <member name="F:QtDBus.QDBusArgument.ElementType.MapEntryType">
            <summary>One entry in an associative container: both the key and the value form one map-entry type.</summary>
        </member>
        <member name="F:QtDBus.QDBusArgument.ElementType.UnknownType">
            <summary>The type is unknown or we have reached the end of the list.</summary>
        </member>
        <member name="T:QtDBus.QDBusPendingCall">
            <summary>
            <para>The QDBusPendingCall class refers to one pending asynchronous call</para>
            </summary>
            <remarks>
            <para>A QDBusPendingCall object is a reference to a method call that was sent over D-Bus without waiting for a reply. QDBusPendingCall is an opaque type, meant to be used as a handle for a pending reply.</para>
            <para>In most programs, the QDBusPendingCall class will not be used directly. It can be safely replaced with the template-based QDBusPendingReply, in order to access the contents of the reply or wait for it to be complete.</para>
            <para>The QDBusPendingCallWatcher class allows one to connect to a signal that will indicate when the reply has arrived or if the call has timed out. It also provides the QDBusPendingCallWatcher::waitForFinished() method which will suspend the execution of the program until the reply has arrived.</para>
            <para>Note: If you create a copy of a QDBusPendingCall object, all information will be shared among the many copies. Therefore, QDBusPendingCall is an explicitly-shared object and does not provide a method of detaching the copies (since they refer to the same pending call)</para>
            <para></para>
            <para>See also QDBusPendingReply, QDBusPendingCallWatcher, and QDBusAbstractInterface::asyncCall().</para>
            </remarks>
        </member>
        <member name="T:QtDBus.IQDBusPendingCall">
            <summary>
            <para>The QDBusPendingCall class refers to one pending asynchronous call</para>
            </summary>
            <remarks>
            <para>A QDBusPendingCall object is a reference to a method call that was sent over D-Bus without waiting for a reply. QDBusPendingCall is an opaque type, meant to be used as a handle for a pending reply.</para>
            <para>In most programs, the QDBusPendingCall class will not be used directly. It can be safely replaced with the template-based QDBusPendingReply, in order to access the contents of the reply or wait for it to be complete.</para>
            <para>The QDBusPendingCallWatcher class allows one to connect to a signal that will indicate when the reply has arrived or if the call has timed out. It also provides the QDBusPendingCallWatcher::waitForFinished() method which will suspend the execution of the program until the reply has arrived.</para>
            <para>Note: If you create a copy of a QDBusPendingCall object, all information will be shared among the many copies. Therefore, QDBusPendingCall is an explicitly-shared object and does not provide a method of detaching the copies (since they refer to the same pending call)</para>
            <para></para>
            <para>See also QDBusPendingReply, QDBusPendingCallWatcher, and QDBusAbstractInterface::asyncCall().</para>
            </remarks>
        </member>
        <member name="M:QtDBus.IQDBusPendingCall.Swap(QtDBus.IQDBusPendingCall)">
            <summary>
            <para>Swaps this pending call instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtDBus.IQDBusPendingCall.WaitForFinished">
            <summary>
            <para>Suspends the execution of the calling thread until the reply is received and processed. After this function returns, isFinished() should return true, indicating the reply's contents are ready to be processed.</para>
            <para>See also QDBusPendingReply::waitForFinished().</para>
            </summary>
        </member>
        <member name="P:QtDBus.IQDBusPendingCall.IsFinished">
            <summary>
            <para>Returns true if the pending call has finished processing and the reply has been received.</para>
            <para>Note that this function only changes state if you call waitForFinished() or if an external D-Bus event happens, which in general only happens if you return to the event loop execution.</para>
            <para>See also QDBusPendingReply::isFinished().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusPendingCall.#ctor(QtDBus.IQDBusPendingCall)">
            <summary>
            <para>Creates a copy of the other pending asynchronous call. Note that both objects will refer to the same pending call.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusPendingCall.Swap(QtDBus.IQDBusPendingCall)">
            <summary>
            <para>Swaps this pending call instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusPendingCall.WaitForFinished">
            <summary>
            <para>Suspends the execution of the calling thread until the reply is received and processed. After this function returns, isFinished() should return true, indicating the reply's contents are ready to be processed.</para>
            <para>See also QDBusPendingReply::waitForFinished().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusPendingCall.FromError(QtDBus.QDBusError)">
            <summary>
            <para>Creates a QDBusPendingCall object based on the error condition error. The resulting pending call object will be in the &quot;finished&quot; state and QDBusPendingReply::isError() will return true.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also fromCompletedCall().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusPendingCall.FromCompletedCall(QtDBus.QDBusMessage)">
            <summary>
            <para>Creates a QDBusPendingCall object based on the message msg. The message must be of type QDBusMessage::ErrorMessage or QDBusMessage::ReplyMessage (that is, a message that is typical of a completed call).</para>
            <para>This function is useful for code that requires simulating a pending call, but that has already finished.</para>
            <para>This function was introduced in  Qt 4.6.</para>
            <para>See also fromError().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusPendingCall.IsFinished">
            <summary>
            <para>Returns true if the pending call has finished processing and the reply has been received.</para>
            <para>Note that this function only changes state if you call waitForFinished() or if an external D-Bus event happens, which in general only happens if you return to the event loop execution.</para>
            <para>See also QDBusPendingReply::isFinished().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusPendingCallWatcher">
            <summary>
            <para>The QDBusPendingCallWatcher class provides a convenient way for waiting for asynchronous replies</para>
            </summary>
            <remarks>
            <para>The QDBusPendingCallWatcher provides the finished() signal that will be emitted when a reply arrives.</para>
            <para>It is usually used like the following example:</para>
            <para></para>
            <para></para>
            <para>      QDBusPendingCall async = iface-&gt;asyncCall(&quot;RemoteMethod&quot;, value1, value2);</para>
            <para>      QDBusPendingCallWatcher *watcher = new QDBusPendingCallWatcher(async, this);</para>
            <para></para>
            <para>      QObject::connect(watcher, SIGNAL(finished(QDBusPendingCallWatcher*)),</para>
            <para>                       this, SLOT(callFinishedSlot(QDBusPendingCallWatcher*)));</para>
            <para></para>
            <para></para>
            <para>Note that it is not necessary to keep the original QDBusPendingCall object around since QDBusPendingCallWatcher inherits from that class too.</para>
            <para>The slot connected to by the above code could be something similar to the following:</para>
            <para></para>
            <para></para>
            <para>  void MyClass::callFinishedSlot(QDBusPendingCallWatcher *call)</para>
            <para>  {</para>
            <para>      QDBusPendingReply&lt;QString, QByteArray&gt; reply = *call;</para>
            <para>      if (reply.isError()) {</para>
            <para>          showError();</para>
            <para>      } else {</para>
            <para>          QString text = reply.argumentAt&lt;0&gt;();</para>
            <para>          QByteArray data = reply.argumentAt&lt;1&gt;();</para>
            <para>          showReply(text, data);</para>
            <para>      }</para>
            <para>      call-&gt;deleteLater();</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>Note the use of QDBusPendingReply to validate the argument types in the reply. If the reply did not contain exactly two arguments (one string and one QByteArray), QDBusPendingReply::isError() will return true.</para>
            <para></para>
            <para>See also QDBusPendingReply and QDBusAbstractInterface::asyncCall().</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusPendingCallWatcher.#ctor(QtDBus.IQDBusPendingCall,QtCore.QObject)">
            <summary>
            <para>Creates a QDBusPendingCallWatcher object to watch for replies on the asynchronous pending call call and sets this object's parent to parent.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusPendingCallWatcher.WaitForFinished">
            <summary>
            <para>Suspends the execution of the calling thread until the reply is received and processed. After this function returns, isFinished() should return true, indicating the reply's contents are ready to be processed.</para>
            <para>See also QDBusPendingReply::waitForFinished().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusPendingCallWatcher.Swap(QtDBus.IQDBusPendingCall)">
            <summary>
            <para>Swaps this pending call instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusPendingCallWatcher.Finished">
            <summary>
            <para>This signal is emitted when the pending call has finished and its reply is available. The self parameter is a pointer to the object itself, passed for convenience so that the slot can access the properties and determine the contents of the reply.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusPendingCallWatcher.IsFinished">
            <summary>
            <para>Returns true if the pending call has finished processing and the reply has been received.</para>
            <para>Note that this function only changes state if you call waitForFinished() or if an external D-Bus event happens, which in general only happens if you return to the event loop execution.</para>
            <para>See also QDBusPendingReply::isFinished().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusConnectionInterface">
            <summary>
            <para>The QDBusConnectionInterface class provides access to the D-Bus bus daemon service.</para>
            </summary>
            <remarks>
            <para>The D-Bus bus server daemon provides one special interface org.freedesktop.DBus that allows clients to access certain properties of the bus, such as the current list of clients connected. The QDBusConnectionInterface class provides access to that interface.</para>
            <para>The most common uses of this class are to register and unregister service names on the bus using the registerService() and unregisterService() functions, query about existing names using the isServiceRegistered(), registeredServiceNames() and serviceOwner() functions, and to receive notification that a client has registered or de-registered through the serviceRegistered(), serviceUnregistered() and serviceOwnerChanged() signals.</para>
            </remarks>
        </member>
        <member name="E:QtDBus.QDBusConnectionInterface.ServiceRegistered">
            <summary>
            <para>This signal is emitted by the D-Bus server when the bus service name (unique connection name or well-known service name) given by serviceName is acquired by this application.</para>
            <para>Acquisition happens after this application has requested a name using registerService().</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusConnectionInterface.ServiceUnregistered">
            <summary>
            <para>This signal is emitted by the D-Bus server when this application loses ownership of the bus service name given by serviceName.</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusConnectionInterface.ServiceOwnerChanged">
            <summary>
            <para>Use QDBusServiceWatcher instead.</para>
            <para>This signal is emitted by the D-Bus server whenever a service ownership change happens in the bus, including apparition and disparition of names.</para>
            <para>This signal means the application oldOwner lost ownership of bus name name to application newOwner. If oldOwner is an empty string, it means the name name has just been created; if newOwner is empty, the name name has no current owner and is no longer available.</para>
            <para>Note: connecting to this signal will make the application listen for and receive every single service ownership change on the bus. Depending on how many services are running, this make the application be activated to receive more signals than it needs. To avoid this problem, use the QDBusServiceWatcher class, which can listen for specific changes.</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusConnectionInterface.CallWithCallbackFailed">
            <summary>
            <para>This signal is emitted when there is an error during a QDBusConnection::callWithCallback(). error specifies the error. call is the message that couldn't be delivered.</para>
            <para>See also QDBusConnection::callWithCallback().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusConnectionInterface.ServiceQueueOptions">
            <summary>
            <para>Flags for determining how a service registration should behave, in case the service name is already registered.</para>
            <para>See also ServiceReplacementOptions.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.ServiceQueueOptions.DontQueueService">
            <summary>If an application requests a name that is already owned, no queueing will be performed. The registeredService() call will simply fail. This is the default.</summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.ServiceQueueOptions.QueueService">
            <summary>Attempts to register the requested service, but do not try to replace it if another application already has it registered. Instead, simply put this application in queue, until it is given up. The serviceRegistered() signal will be emitted when that happens.</summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.ServiceQueueOptions.ReplaceExistingService">
            <summary>If another application already has the service name registered, attempt to replace it.</summary>
        </member>
        <member name="T:QtDBus.QDBusConnectionInterface.ServiceReplacementOptions">
            <summary>
            <para>Flags for determining if the D-Bus server should allow another application to replace a name that this application has registered with the ReplaceExistingService option.</para>
            <para>The possible values are:</para>
            <para>See also ServiceQueueOptions.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.ServiceReplacementOptions.DontAllowReplacement">
            <summary>Do not allow another application to replace us. The service must be explicitly unregistered with unregisterService() for another application to acquire it. This is the default.</summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.ServiceReplacementOptions.AllowReplacement">
            <summary>Allow other applications to replace us with the ReplaceExistingService option to registerService() without intervention. If that happens, the serviceUnregistered() signal will be emitted.</summary>
        </member>
        <member name="T:QtDBus.QDBusConnectionInterface.RegisterServiceReply">
            <summary>
            <para>The possible return values from registerService():</para>
            <para>The serviceRegistered() signal will be emitted when the service is acquired by this application.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.RegisterServiceReply.ServiceNotRegistered">
            <summary>The call failed and the service name was not registered.</summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.RegisterServiceReply.ServiceRegistered">
            <summary>The caller is now the owner of the service name.</summary>
        </member>
        <member name="F:QtDBus.QDBusConnectionInterface.RegisterServiceReply.ServiceQueued">
            <summary>The caller specified the QueueService flag and the service was already registered, so we are in queue.</summary>
        </member>
        <member name="T:QtDBus.QDBusContext">
            <summary>
            <para>The QDBusContext class allows slots to determine the D-Bus context of the calls.</para>
            </summary>
            <remarks>
            <para>When a slot is called in an object due to a signal delivery or due to a remote method call, it is sometimes necessary to know the context in which that happened. In particular, if the slot determines that it wants to send the reply at a later opportunity or if it wants to reply with an error, the context is needed.</para>
            <para>The QDBusContext class is an alternative to accessing the context that doesn't involve modifying the code generated by the Qt D-Bus XML compiler (qdbusxml2cpp).</para>
            <para>QDBusContext is used by subclassing it from the objects being exported using QDBusConnection::registerObject(). The following example illustrates the usage:</para>
            <para></para>
            <para></para>
            <para>  class MyObject: public QObject,</para>
            <para>                  protected QDBusContext</para>
            <para>  {</para>
            <para>      Q_OBJECT</para>
            <para>      QDBusConnection conn;</para>
            <para>      QDBusMessage msg;</para>
            <para></para>
            <para>  ...</para>
            <para></para>
            <para>  protected slots:</para>
            <para>      void process();</para>
            <para>  public slots:</para>
            <para>      void methodWithError();</para>
            <para>      QString methodWithDelayedReply();</para>
            <para>  };</para>
            <para></para>
            <para>  void MyObject::methodWithError()</para>
            <para>  {</para>
            <para>      sendErrorReply(QDBusError::NotSupported,</para>
            <para>                     &quot;The method call 'methodWithError()' is not supported&quot;);</para>
            <para>  }</para>
            <para></para>
            <para>  QString MyObject::methodWithDelayedReply()</para>
            <para>  {</para>
            <para>      conn = connection();</para>
            <para>      msg = message();</para>
            <para>      setDelayedReply(true);</para>
            <para>      QMetaObject::invokeMethod(this, &quot;process&quot;, Qt::QueuedConnection);</para>
            <para>      return QString();</para>
            <para>  }</para>
            <para></para>
            <para></para>
            <para>The example illustrates the two typical uses, that of sending error replies and that of delayed replies.</para>
            <para>Note: do not subclass QDBusContext and QDBusAbstractAdaptor at the same time. QDBusContext should appear in the real object, not the adaptor. If it's necessary from the adaptor code to determine the context, use a public inheritance and access the functions via QObject::parent().</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusContext.#ctor">
            <summary>
            <para>Constructs an empty QDBusContext.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusContext.SendErrorReply(System.String,System.String)">
            <summary>
            <para>Sends an error name as a reply to the caller. The optional msg parameter is a human-readable text explaining the failure.</para>
            <para>If an error is sent, the return value and any output parameters from the called slot will be ignored by Qt D-Bus.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusContext.SendErrorReply(QtDBus.QDBusError.ErrorType,System.String)">
            <summary>
            <para>This is an overloaded function.</para>
            <para>Sends an error type as a reply to the caller. The optional msg parameter is a human-readable text explaining the failure.</para>
            <para>If an error is sent, the return value and any output parameters from the called slot will be ignored by Qt D-Bus.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusContext.DelayedReply">
            <summary>
            <para>Returns true if this call will have a delayed reply.</para>
            <para>See also setDelayedReply().</para>
            <para></para>
            <para>Sets whether this call will have a delayed reply or not.</para>
            <para>If enable is false, Qt D-Bus will automatically generate a reply back to the caller, if needed, as soon as the called slot returns.</para>
            <para>If enable is true, Qt D-Bus will not generate automatic replies. It will also ignore the return value from the slot and any output parameters. Instead, the called object is responsible for storing the incoming message and send a reply or error at a later time.</para>
            <para>Failing to send a reply will result in an automatic timeout error being generated by D-Bus.</para>
            <para>See also isDelayedReply().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusContext.CalledFromDBus">
            <summary>
            <para>Returns true if we are processing a D-Bus call. If this function returns true, the rest of the functions in this class are available.</para>
            <para>Accessing those functions when this function returns false is undefined and may lead to crashes.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusContext.Connection">
            <summary>
            <para>Returns the connection from which this call was received.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusContext.Message">
            <summary>
            <para>Returns the message that generated this call.</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusInterface">
            <summary>
            <para>The QDBusInterface class is a proxy for interfaces on remote objects.</para>
            </summary>
            <remarks>
            <para>QDBusInterface is a generic accessor class that is used to place calls to remote objects, connect to signals exported by remote objects and get/set the value of remote properties. This class is useful for dynamic access to remote objects: that is, when you do not have a generated code that represents the remote interface.</para>
            <para>Calls are usually placed by using the call() function, which constructs the message, sends it over the bus, waits for the reply and decodes the reply. Signals are connected to by using the normal QObject::connect() function. Finally, properties are accessed using the QObject::property() and QObject::setProperty() functions.</para>
            <para>The following code snippet demonstrates how to perform a mathematical operation of &quot;2 + 2&quot; in a remote application called com.example.Calculator, accessed via the session bus.</para>
            <para></para>
            <para></para>
            <para>  QDBusInterface remoteApp( &quot;com.example.Calculator&quot;, &quot;/Calculator/Operations&quot;,</para>
            <para>                            &quot;org.mathematics.RPNCalculator&quot; );</para>
            <para>  remoteApp.call( &quot;PushOperand&quot;, 2 );</para>
            <para>  remoteApp.call( &quot;PushOperand&quot;, 2 );</para>
            <para>  remoteApp.call( &quot;ExecuteOperation&quot;, &quot;+&quot; );</para>
            <para>  QDBusReply&lt;int&gt; reply = remoteApp.call( &quot;PopOperand&quot; );</para>
            <para></para>
            <para>  if ( reply.isValid() )</para>
            <para>      printf( &quot;%d&quot;, reply.value() );          // prints 4</para>
            <para></para>
            <para></para>
            <para></para>
            <para>See also Qt D-Bus XML compiler (qdbusxml2cpp).</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusInterface.#ctor(System.String,System.String,System.String,QtDBus.QDBusConnection,QtCore.QObject)">
            <summary>
            <para>Creates a dynamic QDBusInterface object associated with the interface interface on object at path path on service service, using the given connection. If interface is an empty string, the object created will refer to the merging of all interfaces found in that object.</para>
            <para>parent is passed to the base class constructor.</para>
            <para>If the remote service service is not present or if an error occurs trying to obtain the description of the remote interface interface, the object created will not be valid (see isValid()).</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusInterface.#ctor(System.String,System.String,System.String)">
            <summary>
            <para>Creates a dynamic QDBusInterface object associated with the interface interface on object at path path on service service, using the given connection. If interface is an empty string, the object created will refer to the merging of all interfaces found in that object.</para>
            <para>parent is passed to the base class constructor.</para>
            <para>If the remote service service is not present or if an error occurs trying to obtain the description of the remote interface interface, the object created will not be valid (see isValid()).</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusServer">
            <summary>
            <para>The QDBusServer class provides peer-to-peer communication between processes on the same computer.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusServer.#ctor(System.String,QtCore.QObject)">
            <summary>
            <para>Constructs a QDBusServer with the given address, and the given parent.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusServer.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QDBusServer with the given parent. The server will listen for connections in /tmp (on Unix systems) or on a TCP port bound to localhost (elsewhere).</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusServer.NewConnection">
            <summary>
            <para>This signal is emitted when a new client connection connection is established to the server.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusServer.AnonymousAuthenticationAllowed">
            <summary>
            <para>Returns true if anonymous authentication is allowed.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            <para>See also setAnonymousAuthenticationAllowed().</para>
            <para></para>
            <para>If value is set to true, an incoming connection can proceed even if the connecting client is not authenticated as a user.</para>
            <para>By default, this value is false.</para>
            <para>This function was introduced in  Qt 5.3.</para>
            <para>See also isAnonymousAuthenticationAllowed().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusServer.IsConnected">
            <summary>
            <para>Returns true if this QDBusServer object is connected.</para>
            <para>If it isn't connected, you need to call the constructor again.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusServer.LastError">
            <summary>
            <para>Returns the last error that happened in this server.</para>
            <para>This function is provided for low-level code.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusServer.Address">
            <summary>
            <para>Returns the address this server is associated with.</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusServiceWatcher">
            <summary>
            <para>The QDBusServiceWatcher class allows the user to watch for a bus service change.</para>
            </summary>
            <remarks>
            <para>A QDBusServiceWatcher object can be used to notify the application about an ownership change of a service name on the bus. It has three watch modes:</para>
            <para></para>
            <para>Watching for service registration only.</para>
            <para>Watching for service unregistration only.</para>
            <para>Watching for any kind of service ownership change (the default mode).</para>
            <para></para>
            <para>Besides being created or deleted, services may change owners without a unregister/register operation happening. So the serviceRegistered() and serviceUnregistered() signals may not be emitted if that happens.</para>
            <para>This class is more efficient than using the QDBusConnectionInterface::serviceOwnerChanged() signal because it allows one to receive only the signals for which the class is interested in.</para>
            <para></para>
            <para>See also QDBusConnection.</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusServiceWatcher.#ctor(QtCore.QObject)">
            <summary>
            <para>Creates a QDBusServiceWatcher object. Note that until you set a connection with setConnection(), this object will not emit any signals.</para>
            <para>The parent parameter is passed to QObject to set the parent of this object.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusServiceWatcher.#ctor(System.String,QtDBus.QDBusConnection,QtDBus.QDBusServiceWatcher.WatchModeFlag,QtCore.QObject)">
            <summary>
            <para>Creates a QDBusServiceWatcher object and attaches it to the connection connection. Also, this function immediately starts watching for watchMode changes to service service.</para>
            <para>The parent parameter is passed to QObject to set the parent of this object.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusServiceWatcher.AddWatchedService(System.String)">
            <summary>
            <para>Adds newService to the list of services to be watched by this object. This function is more efficient than setWatchedServices() and should be used whenever possible to add services.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusServiceWatcher.RemoveWatchedService(System.String)">
            <summary>
            <para>Removes the service from the list of services being watched by this object. Note that D-Bus notifications are asynchronous, so there may still be signals pending delivery about service. Those signals will still be emitted whenever the D-Bus messages are processed.</para>
            <para>This function returns true if any services were removed.</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusServiceWatcher.ServiceRegistered">
            <summary>
            <para>This signal is emitted whenever this object detects that the service serviceName became available on the bus.</para>
            <para>See also serviceUnregistered() and serviceOwnerChanged().</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusServiceWatcher.ServiceUnregistered">
            <summary>
            <para>This signal is emitted whenever this object detects that the service serviceName was unregistered from the bus and is no longer available.</para>
            <para>See also serviceRegistered() and serviceOwnerChanged().</para>
            </summary>
        </member>
        <member name="E:QtDBus.QDBusServiceWatcher.ServiceOwnerChanged">
            <summary>
            <para>This signal is emitted whenever this object detects that there was a service ownership change relating to the serviceName service. The oldOwner parameter contains the old owner name and newOwner is the new owner. Both oldOwner and newOwner are unique connection names.</para>
            <para>Note that this signal is also emitted whenever the serviceName service was registered or unregistered. If it was registered, oldOwner will contain an empty string, whereas if it was unregistered, newOwner will contain an empty string.</para>
            <para>If you need only to find out if the service is registered or unregistered only, without being notified that the ownership changed, consider using the specific modes for those operations. This class is more efficient if you use the more specific modes.</para>
            <para>See also serviceRegistered() and serviceUnregistered().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusServiceWatcher.WatchedServices">
            <summary>
            <para>The servicesWatched property holds the list of services watched.</para>
            <para>Note that modifying this list with setServicesWatched() is an expensive operation. If you can, prefer to change it by way of addWatchedService() and removeWatchedService().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusServiceWatcher.WatchMode">
            <summary>
            <para>The watchMode property holds the current watch mode for this QDBusServiceWatcher object. The default value for this property is QDBusServiceWatcher::WatchForOwnershipChange.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusServiceWatcher.Connection">
            <summary>
            <para>Returns the QDBusConnection that this object is attached to.</para>
            <para>See also setConnection().</para>
            <para></para>
            <para>Sets the D-Bus connection that this object is attached to be connection. All services watched will be transferred to this connection.</para>
            <para>Note that QDBusConnection objects are reference counted: QDBusServiceWatcher will keep a reference for this connection while it exists. The connection is not closed until the reference count drops to zero, so this will ensure that any notifications are received while this QDBusServiceWatcher object exists.</para>
            <para>See also connection().</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusServiceWatcher.WatchModeFlag">
            <summary>
            <para>QDBusServiceWatcher supports three different watch modes, which are configured by this flag:</para>
            <para>The WatchMode type is a typedef for QFlags&lt;WatchModeFlag&gt;. It stores an OR combination of WatchModeFlag values.</para>
            </summary>
        </member>
        <member name="F:QtDBus.QDBusServiceWatcher.WatchModeFlag.WatchForRegistration">
            <summary>watch for service registration only, ignoring any signals related to other service ownership change.</summary>
        </member>
        <member name="F:QtDBus.QDBusServiceWatcher.WatchModeFlag.WatchForUnregistration">
            <summary>watch for service unregistration only, ignoring any signals related to other service ownership change.</summary>
        </member>
        <member name="F:QtDBus.QDBusServiceWatcher.WatchModeFlag.WatchForOwnerChange">
            <summary>watch for any kind of service ownership change.</summary>
        </member>
        <member name="T:QtDBus.QDBusUnixFileDescriptor">
            <summary>
            <para>The QDBusUnixFileDescriptor class holds one Unix file descriptor.</para>
            </summary>
            <remarks>
            <para>The QDBusUnixFileDescriptor class is used to hold one Unix file descriptor for use with the Qt D-Bus module. This allows applications to send and receive Unix file descriptors over the D-Bus connection, mapping automatically to the D-Bus type 'h'.</para>
            <para>Objects of type QDBusUnixFileDescriptors can be used also as parameters in signals and slots that get exported to D-Bus by registering with QDBusConnection::registerObject.</para>
            <para>QDBusUnixFileDescriptor does not take ownership of the file descriptor. Instead, it will use the Unix system call dup(2) to make a copy of the file descriptor. This file descriptor belongs to the QDBusUnixFileDescriptor object and should not be stored or closed by the user. Instead, you should make your own copy if you need that.</para>
            <para></para>
            <para>Availability</para>
            <para>Unix file descriptor passing is not available in all D-Bus connections. This feature is present with D-Bus library and bus daemon version 1.4 and upwards on Unix systems. Qt D-Bus automatically enables the feature if such a version was found at compile-time and run-time.</para>
            <para>To verify that your connection does support passing file descriptors, check if the QDBusConnection::UnixFileDescriptorPassing capability is set with QDBusConnection::connectionCapabilities(). If the flag is not active, then you will not be able to make calls to methods that have QDBusUnixFileDescriptor as arguments or even embed such a type in a variant. You will also not receive calls containing that type.</para>
            <para>Note also that remote applications may not have support for Unix file descriptor passing. If you make a D-Bus to a remote application that cannot receive such a type, you will receive an error reply. If you try to send a signal containing a D-Bus file descriptor or return one from a method call, the message will be silently dropped.</para>
            <para>Even if the feature is not available, QDBusUnixFileDescriptor will continue to operate, so code need not have compile-time checks for the availability of this feature.</para>
            <para>On non-Unix systems, QDBusUnixFileDescriptor will always report an invalid state and QDBusUnixFileDescriptor::isSupported() will return false.</para>
            <para></para>
            <para>See also QDBusConnection::ConnectionCapabilities and QDBusConnection::connectionCapabilities().</para>
            </remarks>
        </member>
        <member name="M:QtDBus.QDBusUnixFileDescriptor.#ctor">
            <summary>
            <para>Constructs a QDBusUnixFileDescriptor without a wrapped file descriptor. This is equivalent to constructing the object with an invalid file descriptor (like -1).</para>
            <para>See also fileDescriptor() and isValid().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusUnixFileDescriptor.#ctor(System.Int32)">
            <summary>
            <para>Constructs a QDBusUnixFileDescriptor object by copying the fileDescriptor parameter. The original file descriptor is not touched and must be closed by the user.</para>
            <para>Note that the value returned by fileDescriptor() will be different from the fileDescriptor parameter passed.</para>
            <para>If the fileDescriptor parameter is not valid, isValid() will return false and fileDescriptor() will return -1.</para>
            <para>See also setFileDescriptor() and fileDescriptor().</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusUnixFileDescriptor.#ctor(QtDBus.QDBusUnixFileDescriptor)">
            <summary>
            <para>Constructs a QDBusUnixFileDescriptor object by copying other.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusUnixFileDescriptor.Swap(QtDBus.QDBusUnixFileDescriptor)">
            <summary>
            <para>Swaps this file descriptor instance with other. This function is very fast and never fails.</para>
            <para>This function was introduced in  Qt 5.0.</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusUnixFileDescriptor.FileDescriptor">
            <summary>
            <para>Returns the Unix file descriptor contained by this QDBusUnixFileDescriptor object. An invalid file descriptor is represented by the value -1.</para>
            <para>Note that the file descriptor returned by this function is owned by the QDBusUnixFileDescriptor object and must not be stored past the lifetime of this object. It is ok to use it while this object is valid, but if one wants to store it for longer use, the file descriptor should be cloned using the Unix dup(2), dup2(2) or dup3(2) functions.</para>
            <para>See also setFileDescriptor() and isValid().</para>
            <para></para>
            <para>Sets the file descriptor that this QDBusUnixFileDescriptor object holds to a copy of fileDescriptor. The original file descriptor is not touched and must be closed by the user.</para>
            <para>Note that the value returned by fileDescriptor() will be different from the fileDescriptor parameter passed.</para>
            <para>If the fileDescriptor parameter is not valid, isValid() will return false and fileDescriptor() will return -1.</para>
            <para>See also isValid() and fileDescriptor().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusUnixFileDescriptor.IsValid">
            <summary>
            <para>Returns true if this Unix file descriptor is valid. A valid Unix file descriptor is not -1.</para>
            <para>See also fileDescriptor().</para>
            </summary>
        </member>
        <member name="P:QtDBus.QDBusUnixFileDescriptor.IsSupported">
            <summary>
            <para>Returns true if Unix file descriptors are supported on this platform. In other words, this function returns true if this is a Unix platform.</para>
            <para>Note that QDBusUnixFileDescriptor continues to operate even if this function returns false. The only difference is that the QDBusUnixFileDescriptor objects will always be in the isValid() == false state and fileDescriptor() will always return -1. The class will not consume any operating system resources.</para>
            </summary>
        </member>
        <member name="T:QtDBus.QDBusVirtualObject">
            <summary>
            <para>The QDBusVirtualObject class is used to handle several DBus paths with one class.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusVirtualObject.#ctor(QtCore.QObject)">
            <summary>
            <para>Constructs a QDBusVirtualObject with parent.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusVirtualObject.Introspect(System.String)">
            <summary>
            <para>This function needs to handle the introspection of the virtual object on path. It must return xml of the form:</para>
            <para></para>
            <para></para>
            <para>  &lt;interface name=&quot;org.qtproject.QtDBus.MyObject&quot; &gt;</para>
            <para>      &lt;property access=&quot;readwrite&quot; type=&quot;i&quot; name=&quot;prop1&quot; /&gt;</para>
            <para>  &lt;/interface&gt;</para>
            <para></para>
            <para></para>
            <para>If you pass the SubPath option, this introspection has to include all child nodes. Otherwise QDBus handles the introspection of the child nodes.</para>
            </summary>
        </member>
        <member name="M:QtDBus.QDBusVirtualObject.HandleMessage(QtDBus.QDBusMessage,QtDBus.QDBusConnection)">
            <summary>
            <para>This function needs to handle all messages to the path of the virtual object, when the SubPath option is specified. The service, path, interface and methos are all part of the message. Parameter connection is the connection handle. Must return true when the message is handled, otherwise false (will generate dbus error message).</para>
            </summary>
        </member>
    </members>
</doc>
